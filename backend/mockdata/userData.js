module.exports = [
    {
        id: 0,
        username: "null",
        password: "null",
        is_admin: false,
        articles: [
            {
                aid: 1,
                title: '日记',
                content: 'Null',
                date: 'Null',
            }
        ]
    },

    {
        id: 1,
        username: "admin",
        password: "123",
        is_admin: true,
        articles: [
            {
                aid: 1,
                title: '日记',
                content: "<h2>总览</h2>\n<blockquote>\n<p><a href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">快速排序 O(nlogn~N^2)</a> &gt; <a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</a> &gt; <a href=\"#%E4%BA%8C%E5%88%86\">二分</a> &gt; <a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6\">高精度</a> &gt; <a href=\"#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86\">前缀和与差分</a> &gt; <a href=\"#%E5%8F%8C%E6%8C%87%E9%92%88\">双指针</a> &gt; <a href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97\">位运算</a> &gt; <a href=\"#%E7%A6%BB%E6%95%A3%E5%8C%96\">离散化</a> &gt; <a href=\"#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6\">区间合并</a></p>\n</blockquote>\n<pre><code class=\"language-cpp\">/*\n快排\n`i=l-1,j=r+1,x=q[(l+r+1)/2]`\n\n二分\n为什么补上+1 下取整 l=r-1 [就一个数字] 不补的话 l+r/2 就是 l 如果check成功放回true 更新为 l=mid=l 为 [mid,r]=&gt;[l,r]死循环\n\n高精度\n#include &lt;vector&gt;\n只能用cin\nstring a,b; 逆序输入a[i] 从逻辑地位 物理高位开始算\n\n双指针问题\n\n要保证单调性 一个往前走 另一个也会一直某个方向走 特别是判断顺序某类题目\n\n前缀和差分\n差分和前缀矩阵很相似 但是 主要区别在于 构造差分是 增加减少是影响下边区域的 而前缀则是求上边区域的\n*/\n</code></pre>\n<h3>快速排序</h3>\n<pre><code class=\"language-cpp\">/*\n快速排序的思想 分治\n\n1. 确定分界点 直接取边界x q[l] q[l+r/2] q[r] 随机\n\n2. 调整区间 使得 所有小于等于x的在x的左边  所有大于等于x的在x的右边 [这里不一定x在中间位置\n由于等于 取边界的时候 也可以划分两块 q[l] 那么 第一个是 q[l] 那么第二个就是 &gt;=q[l] 和x相等的时候 在左边和在右边都是可以的]\n\n3. 递归处理左右两段\n\n关键点在于 调整区间这一部分 如何快速的调整两部分\n\n方法1(暴力方法)\n1.开a[] b[]\n2.q[l~r]\n    - 小于等于x x-&gt;a[]\n    - 大于x x-&gt;b[]\n3. a放入q b放入q\n\n方法2\n双指针\nij\n如果i指向的数小于等于x 往后走 直到大于x\n如果j指向的数大于等于x 往前走 直到小于x\nswap q[i] q[j]\n直到ij相遇为止 有很多边界问题 一般都背诵模板\n*/\nvoid quick_soft(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int i=l-1,j=r+1,x=q[(l+r+1)/2];\n    while(i&lt;j){\n        do i++;while(q[i]&lt;x);\n        do j--;while(q[j]&gt;x);\n        if(i&lt;j) swap(q[i],q[j]);\n    }\n    quick_soft(q,l,i-1);\n    quick_soft(q,i,r);\n}\n</code></pre>\n<h4>Acwing.786 第 k 个数</h4>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=1e5+10;\nint q[N];\n\nvoid quick_sort(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int i=l-1,j=r+1,x=q[(l+r+1)/2];\n    while(i&lt;j){\n        do i++;while(q[i]&lt;x);\n        do j--;while(q[j]&gt;x);\n        if(i&lt;j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,i-1);\n    quick_sort(q,i,r);\n}\nint main(){\n    int n,k;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i]);\n    quick_sort(q,1,n);\n    printf(&quot;%d&quot;,q[k]);\n    return 0;\n}\n</code></pre>\n<h3>归并排序</h3>\n<h4>Acwing 787. 归并排序</h4>\n<pre><code class=\"language-c\">void merge_sort(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int mid=l+r&gt;&gt;1;\n    merge_sort(q,l,mid),merge_sort(q,mid+1,r);\n\n    int i=l,j=mid+1,k=0,tmp[r-l+1];\n    while(i&lt;=mid&amp;&amp;j&lt;=r){\n        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];\n        else tmp[k++]=q[j++];\n    }\n    while(i&lt;=mid) tmp[k++]=q[i++];\n    while(j&lt;=r) tmp[k++]=q[j++];\n    for(int i=l,k=0;i&lt;=r;i++,k++) q[i]=tmp[k];\n\n\n}\n//针对奇数情况 3 2=&gt; 2 1 2 =&gt; 1 1 1 1 1 =&gt; 2这种情况(因为是递归 感觉来看 应该先分入栈 然后再进行调用) 因此 使用调试语句 前五个都是\n//不会改变 之后根据栈情况来进行调用 因此1 3 2 4 5 此时 进行奇数的操作 1 3 2 进行排序 而 1 3是已经服从顺序的 只需要比较就可以了\n/*\n1 5 2 3 4 6 7 下去整 一定是 mid可以取到 3 则为 3 4 那么先对3排序 然后对4排序 变成\n1 2 5 3 4 6 7\n\n这种情况对于两边的数组 都是前边的先入 q[i] 因此是正确的 之后如果有剩余 一定是比前边所有已经进入tmp的要大的\n\n总体来看 归并排序是基于分治思想 接近根节点为 两两排序 先划分 然后再进行调用 所以有如此顺序 此外 可以查阅归并排序链接查看运行原理图解\n\n做完这题 感觉就来了 所谓模板 就是立刻想到一个简单的例题或者样例 立刻可以背诵出来本篇代码 这对于算法是很有利的\n*/\n</code></pre>\n<h4>Acwing 788. 逆序对的数量</h4>\n<pre><code class=\"language-cpp\">/*\ntypedef long long LL;\nconst int N=1e5+10;\n//最坏情况下 第一个和后边所有逆序 n-1+n-2...-&gt; n(n-1)/2=&gt;long long 来存\nint q[N];\nint tmp[N];\n对于某次情况 i和j q[i]&gt;q[j] 那么q[j]和后边所有q[i]都成为逆序对 因为i是有序的 j也是有序的 右边是mid个数\nprintf(&quot;%lld&quot;,merge_sort(q,0,n-1));\n*/\nLL merge_sort(int q[],int l,int r){\n    if(l&gt;=r) return 0;\n    int mid=l+r&gt;&gt;1;\n    LL res=merge_sort(q,l,mid)+merge_sort(q,mid+1,r);\n    int i=l,j=mid+1,k=0;\n    while(i&lt;=mid&amp;&amp;j&lt;=r){\n        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];\n        else {\n            tmp[k++]=q[j++];\n            res+=mid-i+1;//这里是i到mid个元素 要求上边条件必须是 q[i]&lt;=q[j] 这个等号 因为逆序对的要求就是这样\n        }\n    }\n    while(i&lt;=mid) tmp[k++]=q[i++];\n    while(j&lt;=r) tmp[k++]=q[j++];\n    for(int i=l,s=0;i&lt;=r;i++,s++) q[i]=tmp[s];\n    return res;\n}\n</code></pre>\n<h3>二分</h3>\n<h4>Acwing 789. 数的范围</h4>\n<pre><code class=\"language-cpp\">\n/*\n二分 分为两大块 一块是整数二分 会有很多边界问题\n\n\n一共有两个模板 核心区别就是除以2的时候 是不是要加上1\n\n\n//区间被分为 [l,mid]和 [mid+1,r]使用\nint bsearch_1(int l,int r){\n    while(l&lt;r){\n        int mid=l+r&gt;&gt;1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    return l;\n}\n\n//区间被分为 [l,mid-1]和[mid-1,r]时使用\nint bsearch_2(int l,int r){\n    while(l&lt;r){\n        int mid=l+r+1&gt;&gt;1;\n        if(check(mid)) l=mid;\n        else r=mid-1;\n    }\n    return l;\n}\n\n二分的本质 有单调性一定可以二分 但是可以二分的题目不一定非得有单调性 所以二分的本质并不是单调性 是边界\n左边不满足这个性质 右边满足这个性质 二分找的是这个性质的边界点 我们定义的mid  是用来缩小区间的 但是边界点是固定的\n并在不断地二分过程中 逐渐接近并确定边界点 二分红色点和绿色点 就是我们的不同的模板了\n\n找到中间值 mid=l+r/2 if(check(mid))[假如条件是符合左边的性质]\n        true mid一定在左边 那么边界点就在mid右边 就需要更新是 l=mid  =&gt;[mid,r]\n        false mid不满足 在mid右边  边界点在mid左边[不包含mid 最多就是mid下一个位置 mid-1] 就更新为 r=mid-1   =&gt;[l,mid-1]\n        按照模板 mid应该是 l+r+1/2\n    2. 当我们想要二分绿颜色的分界点的时候 mid=l+r/2 if(check(mid))\n        true 满足的话 边界点就在mid左边 并且又可能在mid上 那么更新为 [l,mid]\n        false 不满足 边界点在Mid右边 不包含mid  那么就分为 [mid+1,r]\n\n一个二分问题 先写一个check函数 想一下这个check函数 我们应该如何更新\n    如果说是 l=mid r=mid-1 那么就补上+1\n    如果说是 r=mid l=mid+1 就不需要补上了\n\n二分的主要思想 每次选择答案所在的区间进行处理 每次都保证里边都有答案 长度是1 这个区间里边的数就是答案\n无解的时候 二分的时候一定有解的 题目有可能无解 但是二分一定有解的 定义的一个性质 一定是有解的 只不过答案可能并不是题目的解\n\n*/\nint l=0,r=n-1;//每次二分都是 从l到r结束 最终缩小到一个点\nwhile(l&lt;r){//确定左边界  当循环结束的时候 l和r相等\n    int mid=l+r&gt;&gt;1;\n    if(q[mid]&gt;=x) r=mid;//左边界就是 通过 右边大于等于x  来做这个条件的边界点 确定mid不加1\n    else l=mid+1;\n}\n\nif(q[l]!=x) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;//如果找到这个边界不是x 说明无解\nelse{\n    cout&lt;&lt;l&lt;&lt;&quot; &quot;;//所以这里输出l 或者 r 都可以\n    int l=0,r=n-1;//找到右边界 点\n    while(l&lt;r){\n        int mid=l+r+1&gt;&gt;1;//将小于等于x 为满足条件\n        if(q[mid]&lt;=x) l=mid;//那么成立的时候 mid在边界点的左边 l=mid 需要补 +1\n        else r=mid-1;\n    }\n    cout&lt;&lt;l&lt;&lt;endl;\n}\n</code></pre>\n<h4>Acwing 790. 数的三次方根</h4>\n<pre><code class=\"language-cpp\">\n/*\n二分的第一步是确定我们的边界\n我们不应该在0-n里边找边界 因为这是错误的 有可能n是小于1的 这是不正确的 所以应该取它的范围 -10000-10000\n\n\n\n经验之谈 要求保留6位 就取10^-8 如果保留4位 就取10^-6 这个是 while的边界条件 while(r-l&gt;10-8)\n此外 次方不能用这个 &#39;^&#39;写 这个是亦或符号 因该使用 mid * mid * mid 来写\n*/\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// double res;\n// typedef offset 1e-7;\n\nint main(){\n   double x;\n   cin&gt;&gt;x;\n   double l=-10000,r=10000;\n   while(r-l&gt;1e-8){\n       double mid=(l+r)/2;\n       if(mid*mid*mid&gt;=x) r=mid;\n       else l=mid;//这个不用加一减一 因为这个是浮点数\n   }\n\n    printf(&quot;%lf&quot;,l);//printf()默认保留六位小数 输出l和r都是可以的 因为这两个数足够接近\n    return 0;\n}\n</code></pre>\n<h3>高精度</h3>\n<h4>Acwing 791. 高精度加法</h4>\n<pre><code class=\"language-cpp\">/*\n只能用cin\nstring a,b;\ncin&gt;&gt;a&gt;&gt;b;// 输入字符串更快\nvector&lt;int&gt; A,B;\nfor(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#39;0&#39;);// 转化为int型变量 并且从低位开始\nfor(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#39;0&#39;);\n*/\nvector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){ // 数组整数 &amp; 表示只是拿来地址 不需要额外的copy一遍 更快\n    vector&lt;int&gt; C;\n    int t=0;// 进位\n    for(int i=0;i&lt;A.size()||i&lt;B.size();i++){// 前边执行成功 不会向后 A大于B长度 小于则继续相加\n        if(i&lt;A.size()) t+=A[i];// 只有小于 才说明这个位置的A有数\n        if(i&lt;B.size()) t+=B[i];\n        C.push_back(t%10);// 只需要保留个位 直接推送 不需要i来加入\n        t/=10;// 进位 大于10 保留1 小于10 保留0\n    }\n    if(t) C.push_back(1); // 最后仍然有进位 则保留1\n    return C;\n}\n</code></pre>\n<h4>Acwing 792. 高精度减法</h4>\n<pre><code class=\"language-cpp\">/*\nif(cmp(a,b)){\n    auto c=sub(a,b);\n    for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);\n}\nelse{\n    auto c=sub(b,a);\n    printf(&quot;-&quot;);\n    for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);\n}\n*/\n/*\n高精度减法 是需要两个函数 一个cmp 一个sub  需要大树减小数 然后相减 有可能出现前导零 1000-999=0001\n*/\nusing namespace std;\n\nbool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt;&amp;B){//A&gt;=B? true false\n    if(A.size()!=B.size()) return A.size()&gt;B.size();\n    for(int i=A.size();i&gt;=0;i--)\n        if(A[i]!=B[i])\n            return A[i]&gt;B[i];\n    return true;\n}\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){\n    vector&lt;int&gt; c;\n    for(int i=0,t=0;i&lt;=A.size()-1;i++){\n        t=A[i]-t;\n        if(i&lt;B.size()) t-=B[i];\n        c.push_back((t+10)%10);\n        if(t&lt;0) t=1;\n        else t=0;\n    }\n\n\n    // for(int i=c.size();i&gt;=0;i--){\n    //     int k=c.pop();\n    //     if(!k) continue;\n    //     else {\n    //         c.push_back(k);\n    //         break;\n    //     }\n    // }\n    while(c.size()&gt;1&amp;&amp;c.back()==0) c.pop_back();\n    return c;\n}\n</code></pre>\n<h4>Acwing 793. 高精度乘法</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nvector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){\n    vector&lt;int&gt; C;\n    int t=0;\n    for(int i=0;i&lt;A.size()||t;i++){// 要么是A没有循环玩 要么是t不是0 主要解决解决进位\n        if(i&lt;A.size())t+=A[i]*b;\n        C.push_back(t%10);\n        t/=10;\n\n    }\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n</code></pre>\n<h4>Acwing 794. 高精度除法</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nvector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b,int &amp;r){//返回一个余数 引用\n    //c=A/b 商 余数是R\n    vector&lt;int&gt; C;// 最高位开始算的 只有除法 正着存储好一点 除法存储倒着来存\n    r=0;\n    for(int i=A.size()-1;i&gt;=0;i--){//这个是最高位开始\n        r=r*10+A[i];\n        C.push_back(r/b);//因为r=0 所以 A[i]就是第一位 之后r才会更改\n        r%=b;\n    }\n    reverse(C.begin(),C.end());//统一一下 并且容易去除前导0\n    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();\n\n\n    return C;\n}\n</code></pre>\n<h3>前缀和与差分</h3>\n<h4>Acwing 795. 前缀和</h4>\n<pre><code class=\"language-cpp\">/*\n前缀和的作用是 取中间某一段 不需要循环(O(n))了 之际计算出来的 时间复杂度是O1\nios::sync_with_studio(false) 提高cin读取速度 不能使用scanf了\n*/\n\nscanf(&quot;%d%d&quot;,&amp;n,&amp;m);//scanf比cin 快一倍\nfor(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //输入 从1开始 是因为定义s[0]=0 这样不用考虑边界s[1]的问题\nfor(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i];//得出s数组\n\n// 或者新的就是\nvoid sum(int q[],int l,int r){\n    for(int i=l;i&lt;=r;i++){\n        q[i]=q[i-1]+q[i];//q[i-1]是最新的 q[i]是旧的\n    }\n}\n// 注意输出的位置\nprintf(&quot;%d\\n&quot;,q[r]-q[l-1]);\n</code></pre>\n<h4>Acwing 796. 子矩阵的和</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nfor(int i=1;i&lt;=n;i++)\n        for(int j=1;j&lt;=m;j++)\n            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//左边矩形 上边矩形 减去重合部分 +a[i][j]\nprintf(&quot;%d\\n&quot;,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);//起点减去终点\n</code></pre>\n<h4>Acwing 797. 差分</h4>\n<pre><code class=\"language-js\">//差分是用来 构造bi=ai-a[i-1] ai=b1+b2+..bi ai叫做前缀和 bi叫做差分\n//对b求一下前缀和就可以求出来原数组 只要有B数组 用On的时间得到A\n//有需求 对A数组[l j] 全部加上C al+c  ar+c O(n) 用差分就是O1 B\n//球员来的数组 对b求一下前缀和就可以求出来原数组\n// A是B的前缀和 Bl+C 算Al(Al就会自动加上C) Al+1也会加上C 一直到an\n//只需要br+1-C就可以了 (从R+1开始之后全部减去C)\n//想让A数组某段加数值 只需要改一下两个数 bl br+1 时间复杂度就变成o1了\n//拿空间换时间 算法竞赛进阶指南 假定a全是0 看成N次插入操作 b1是1 1 插入a1 b2是2 2插入a2\nvoid insert(int l,int r,int c){\n    b[l]+=c;\n    b[r+1]-=c;\n}\nfor(int i=1;i&lt;=n;i++) insert(i,i,a[i]); //获得差分数组\n</code></pre>\n<h4>Acwing 798. 差分矩阵</h4>\n<pre><code class=\"language-cpp\">\n/*\n差分和前缀矩阵很相似 但是 主要区别在于 构造差分是 增加减少是影响下边区域的 而前缀则是求上边区域的\n构造的同时 插入的是本来的元素 最后求一下前缀和就可以了 对差分求前缀和 这里还是用的b[i][j] 所以这里是\nb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1] 需要这里的b[i][j]\n*/\nvoid insert(int x1,int y1,int x2,int y2,int c){\n    b[x1][y1]+=c;\n    b[x1][y2+1]-=c;\n    b[x2+1][y1]-=c;\n    b[x2+1][y2+1]+=c;\n}\n// 求差分矩阵的原矩阵 求原来的矩阵\nfor(int i=1;i&lt;=n;i++){\n        for(int j=1;j&lt;=m;j++){\n            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n        }\n    }\n</code></pre>\n<h3>双指针算法</h3>\n<h4>Acwing 799. 最长连续不重复子序列</h4>\n<pre><code class=\"language-cpp\">/*\n//我们发现 当对于区间 [j,i-1]来讲 这个区间是单调递增的 而当 [j,i] 时 一旦出现重复\n//只能说明a[i]在前边的区间已经出现过了 因此 我们检测a[i] s[N]是用来检测a[N]中元素出现次数的 一旦重复 就移动j到i这个地方\n//j往前移动 说明 这个区间中出去一个元素 为 a[j] 我们将它从s[N]中减少一次 j继续往前移动 直到移动到 数值同样为a[i]的位置\n//此时 区间重新开始计数 i继续向前走 这个主要用到的时单调性的性质\n*/\nfor(int i=0,j=0;i&lt;n;i++){//一定是a[i]重复了\n        s[a[i]]++;\n        while(s[a[i]]&gt;1){\n            s[a[j]]--;\n            j++;\n        }\n        res=max(res,i-j+1);\n    }\n</code></pre>\n<h4>Acwing 800. 数组元素的目标和</h4>\n<pre><code class=\"language-cpp\">/*\n先想下暴力怎么做 然后针对暴力做优化就可以了\n\n双指针算法就是单调性 AB都是单调上升的 对于每个i来言 我们找到一个满足条件的 Ai+Bi&gt;=X 并且j最小\n我们就可以发现 i往后走的过程中 j一定是向前走的\n\nfor(i=0;i&lt;n;i++) while(j&gt;=0&amp;&amp;Ai+Bi&gt;x) j-- O(n+m)  j总共是m次\nA 1 2 4 7\nB 3 4 6 8 9\n\n总结一下 双指针算法都是先暴力写出来 然后看有没有单调性 如果有单调性的话 就可以把我们的时间复杂度 降低一位\n*/\nfor(int i=0,j=m-1;i&lt;n;i++){\n        while(j&gt;=0&amp;&amp;a[i]+b[j]&gt;x) j--;\n        if(a[i]+b[j]==x){\n            printf(&quot;%d %d\\n&quot;,i,j);\n            break;\n        }\n    }\n</code></pre>\n<h4>Acwing 2816. 判断子序列</h4>\n<pre><code class=\"language-cpp\">/*\n从前往后扫描B这个数组 每次扫描到一个数的时候 判断一下B的当前数是不是和A的当前数一样\n如果一样的话 就将A的当前数 匹配到B的当前数\n\n证明 我们这种方法可以找到B里边的一种匹配方式\n但是我们只能证明可以找到 也要反过来证明一下 里边有解 我们一定可以找到 这种匹配\n假如已经有一种匹配 我们发现和我们匹配的结果不一样 我们匹配的点 一定在B给定匹配前边 那么我们就可以把他调整为我们双指针匹配的\n情况 我们可以发现 调整之后 不会影响后边的匹配 改变之后 还是合法的匹配 这就说明 但凡出现一种匹配 我们的双指针算法必然可以找到\n所以 我们的算法 可以匹配到任意解 (实际上就是在证明贪心 )\n*/\nint i=0,j=0;\n    while(i&lt;n&amp;&amp;j&lt;m){\n        if(a[i]==b[j]) i++;\n        j++;\n    }\n    if(i==n) puts(&quot;Yes&quot;);\n</code></pre>\n<h3>位运算</h3>\n<h4>Acwing 801. 二进制中 1 的个数</h4>\n<pre><code class=\"language-cpp\">//位运算\n\n//常见的位运算的操作 1:n的二进制表示中第K位是几 n&gt;&gt;k&amp;&amp;1\n\n// n=15=11111           (43210) 先把第K位 移到最后一位 n&gt;&gt;k(右移运算)\n# 个位是几 x与1\nn&gt;&gt;k&amp;&amp;1 //右移是将某位移到个位 1010 &gt;&gt;3 1\n\n// 2.lowbit 树状数组的基本操作 返回x的最后一位1  1010&gt;10 101000&gt;1000[返回的是最后一位1 是一个数字 10=&gt;2 1000=&gt;8]\n// x&amp;-x返回最后一个1 补码 -x=~x+1 x&amp;-x=x&amp;(~x+1)\n// lowbit的运用 可以统计x的个数 每次把最后一位1去掉 x=0时可以统计多少个1  lowbit(n)=n&amp;-n;\n// 经典的面试算法先学\n\n//原码 反码 补码 [补码=~X+1 x的反码+1]\n// int n=10;\n// unsigned int x=-n;\n// for(int i=31;i&gt;=0;i--)\n// cout&lt;&lt;(x&gt;&gt;i&amp;1); i=31 是为了展示前边的1\n\n// 为什么要用补码 : -x=0-x;\n                    // 32个0-x 不够 实际上是向前借一位然后减去 等于\n                    // 反码+1=~x+1=-x\n// 位运算 第k位数字 n&gt;&gt;k&amp;1\nn的最后一位1 //lowbit(n)=n&amp;-n\n//人类做题的过程其实是dfs的过程 首先暴力搜索 一层树 每次继续细分 经典问题 叶节点就是我们学过的算法\n// 各种各样的基础算法  提高班来解决这些东西\n</code></pre>\n<h3>离散化</h3>\n<h4>Acwing 802. 区间和</h4>\n<pre><code class=\"language-cpp\">/*\nprintf(&quot;%d %d&quot;,1e7,6e6);为什么这个输出结果为0\n在C语言中，当你尝试使用%d格式说明符来打印一个浮点数时，它不会进行类型转换，而是直接解释浮点数在内存中的位模式作为整数。\n由于浮点数的内部表示和整数通常不同，因此这种解释通常会产生不可预测或错误的结果。\n\n一个Int范围 32位 共 +- 21亿\n\n\n本题的关键是 n是10^9 是10亿  而 int最多1e7+6e6 所以需要映射一下\n将所有输入都存储起来 然后加起来\n此外还需要查询 我们将所有可能用到的坐标压缩到一个vector 然后去重 得到的数组根据find(二分法来找到分配的坐标)\n加完之后应用一下就可以了 这样可以直接求出来前缀和\n然后循环一下query 就可以了\n\n\nvector&lt;int&gt; alls;//所有代离散的值\nsort(alls.begin(),alls().end()) ;所有值排序\nalls.erase(unique(alls.begin(),alls.end()),alls.end()); 曲中 二分查出x的离散值\n\n*/\nint find(int x){\n    int l=0,r=alls.size()-1;\n    while(l&lt;r){\n        int mid=(l+r)/2;\n        if(alls[mid]&gt;=x) r=mid;\n        else l=mid+1;//返回的all[i] 中的位置 就是这个x在alls中排第几个 然后赋值给a[i] 这样做的好处 就是 将大坐标压缩到一个小数组中\n        //尽管数值很大 但是我们的个数是很少的 只需要占用数字个数的空间\n    }\n    return l+1;\n}\n</code></pre>\n<h3>区间合并</h3>\n<pre><code class=\"language-cpp\">/*\n//这种方式不太好 感觉优点混淆 还是合并一下 放进res 然后直接输出res.size()就可以了\n// int res;\n// void merge(vector&lt;PII&gt; &amp;segs){\n\n//     sort(segs.begin(),segs.end());\n//     int st=-2e9,ed=-2e9;\n//     for(auto seg:segs){\n//         if(ed&lt;seg.first) {\n//             st=seg.first;\n//             ed=seg.second;\n//             res++;\n//         }\n//         else {\n//             ed=max(ed,seg.second);\n//         }\n//     }\n// }\n*/\n\n/*\n首先使用pair来存储所有区间 然后根据左端点排序(sort对pair自动按照左端点进行排序)\n然后使用st来保持上一个的片段 如果当前seg&lt;ed 说明没有交集 如果st不为空 推入res 如果seg.f&gt;ed 说明有交集\n比较一下当前seg.s和上一个片段的ed 取一个最大值就可以了\n使用st ed一开始指向为空(-2e9)\n*/\ntypedef pair&lt;int,int&gt; PII;\n\nconst int N=1e5+10;\n\nvector&lt;PII&gt; segs,res;\n\n\nvoid merge(vector&lt;PII&gt; &amp;segs){\n    sort(segs.begin(),segs.end());\n    int st=-2e9,ed=-2e9;\n    for(auto seg:segs){\n        if(ed&lt;seg.first){\n            if(st!=-2e9) res.push_back({st,ed});//把上的一段推送进入res st更新为当前的\n            st=seg.first,ed=seg.second;\n        }else{\n            ed=max(ed,seg.second);\n        }\n    }\n    if(st!=-2e9) res.push_back({st,ed});//最后会剩余一段 (当前段) 进入res\n    return;\n\n}\n</code></pre>\n",
                date: '2024-4-25',
            },
            {
                aid: 2,
                title: '日记',
                content: '花了好长时间写这个RPC',
                date: '2024-4-25',
            }
        ]
    }]