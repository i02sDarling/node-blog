module.exports = [{"id":1,"title":"ch1-基础算法","date":"2024-04-24","content":"<h2>总览</h2>\n<blockquote>\n<p><a href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">快速排序 O(nlogn~N^2)</a> &gt; <a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</a> &gt; <a href=\"#%E4%BA%8C%E5%88%86\">二分</a> &gt; <a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6\">高精度</a> &gt; <a href=\"#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86\">前缀和与差分</a> &gt; <a href=\"#%E5%8F%8C%E6%8C%87%E9%92%88\">双指针</a> &gt; <a href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97\">位运算</a> &gt; <a href=\"#%E7%A6%BB%E6%95%A3%E5%8C%96\">离散化</a> &gt; <a href=\"#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6\">区间合并</a></p>\n</blockquote>\n<pre><code class=\"language-cpp\">/*\n快排\n`i=l-1,j=r+1,x=q[(l+r+1)/2]`\n\n二分\n为什么补上+1 下取整 l=r-1 [就一个数字] 不补的话 l+r/2 就是 l 如果check成功放回true 更新为 l=mid=l 为 [mid,r]=&gt;[l,r]死循环\n\n高精度\n#include &lt;vector&gt;\n只能用cin\nstring a,b; 逆序输入a[i] 从逻辑地位 物理高位开始算\n\n双指针问题\n\n要保证单调性 一个往前走 另一个也会一直某个方向走 特别是判断顺序某类题目\n\n前缀和差分\n差分和前缀矩阵很相似 但是 主要区别在于 构造差分是 增加减少是影响下边区域的 而前缀则是求上边区域的\n*/\n</code></pre>\n<h3>快速排序</h3>\n<pre><code class=\"language-cpp\">/*\n快速排序的思想 分治\n\n1. 确定分界点 直接取边界x q[l] q[l+r/2] q[r] 随机\n\n2. 调整区间 使得 所有小于等于x的在x的左边  所有大于等于x的在x的右边 [这里不一定x在中间位置\n由于等于 取边界的时候 也可以划分两块 q[l] 那么 第一个是 q[l] 那么第二个就是 &gt;=q[l] 和x相等的时候 在左边和在右边都是可以的]\n\n3. 递归处理左右两段\n\n关键点在于 调整区间这一部分 如何快速的调整两部分\n\n方法1(暴力方法)\n1.开a[] b[]\n2.q[l~r]\n    - 小于等于x x-&gt;a[]\n    - 大于x x-&gt;b[]\n3. a放入q b放入q\n\n方法2\n双指针\nij\n如果i指向的数小于等于x 往后走 直到大于x\n如果j指向的数大于等于x 往前走 直到小于x\nswap q[i] q[j]\n直到ij相遇为止 有很多边界问题 一般都背诵模板\n*/\nvoid quick_soft(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int i=l-1,j=r+1,x=q[(l+r+1)/2];\n    while(i&lt;j){\n        do i++;while(q[i]&lt;x);\n        do j--;while(q[j]&gt;x);\n        if(i&lt;j) swap(q[i],q[j]);\n    }\n    quick_soft(q,l,i-1);\n    quick_soft(q,i,r);\n}\n</code></pre>\n<h4>Acwing.786 第 k 个数</h4>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=1e5+10;\nint q[N];\n\nvoid quick_sort(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int i=l-1,j=r+1,x=q[(l+r+1)/2];\n    while(i&lt;j){\n        do i++;while(q[i]&lt;x);\n        do j--;while(q[j]&gt;x);\n        if(i&lt;j) swap(q[i],q[j]);\n    }\n    quick_sort(q,l,i-1);\n    quick_sort(q,i,r);\n}\nint main(){\n    int n,k;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;q[i]);\n    quick_sort(q,1,n);\n    printf(&quot;%d&quot;,q[k]);\n    return 0;\n}\n</code></pre>\n<h3>归并排序</h3>\n<h4>Acwing 787. 归并排序</h4>\n<pre><code class=\"language-c\">void merge_sort(int q[],int l,int r){\n    if(l&gt;=r) return;\n    int mid=l+r&gt;&gt;1;\n    merge_sort(q,l,mid),merge_sort(q,mid+1,r);\n\n    int i=l,j=mid+1,k=0,tmp[r-l+1];\n    while(i&lt;=mid&amp;&amp;j&lt;=r){\n        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];\n        else tmp[k++]=q[j++];\n    }\n    while(i&lt;=mid) tmp[k++]=q[i++];\n    while(j&lt;=r) tmp[k++]=q[j++];\n    for(int i=l,k=0;i&lt;=r;i++,k++) q[i]=tmp[k];\n\n\n}\n//针对奇数情况 3 2=&gt; 2 1 2 =&gt; 1 1 1 1 1 =&gt; 2这种情况(因为是递归 感觉来看 应该先分入栈 然后再进行调用) 因此 使用调试语句 前五个都是\n//不会改变 之后根据栈情况来进行调用 因此1 3 2 4 5 此时 进行奇数的操作 1 3 2 进行排序 而 1 3是已经服从顺序的 只需要比较就可以了\n/*\n1 5 2 3 4 6 7 下去整 一定是 mid可以取到 3 则为 3 4 那么先对3排序 然后对4排序 变成\n1 2 5 3 4 6 7\n\n这种情况对于两边的数组 都是前边的先入 q[i] 因此是正确的 之后如果有剩余 一定是比前边所有已经进入tmp的要大的\n\n总体来看 归并排序是基于分治思想 接近根节点为 两两排序 先划分 然后再进行调用 所以有如此顺序 此外 可以查阅归并排序链接查看运行原理图解\n\n做完这题 感觉就来了 所谓模板 就是立刻想到一个简单的例题或者样例 立刻可以背诵出来本篇代码 这对于算法是很有利的\n*/\n</code></pre>\n<h4>Acwing 788. 逆序对的数量</h4>\n<pre><code class=\"language-cpp\">/*\ntypedef long long LL;\nconst int N=1e5+10;\n//最坏情况下 第一个和后边所有逆序 n-1+n-2...-&gt; n(n-1)/2=&gt;long long 来存\nint q[N];\nint tmp[N];\n对于某次情况 i和j q[i]&gt;q[j] 那么q[j]和后边所有q[i]都成为逆序对 因为i是有序的 j也是有序的 右边是mid个数\nprintf(&quot;%lld&quot;,merge_sort(q,0,n-1));\n*/\nLL merge_sort(int q[],int l,int r){\n    if(l&gt;=r) return 0;\n    int mid=l+r&gt;&gt;1;\n    LL res=merge_sort(q,l,mid)+merge_sort(q,mid+1,r);\n    int i=l,j=mid+1,k=0;\n    while(i&lt;=mid&amp;&amp;j&lt;=r){\n        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];\n        else {\n            tmp[k++]=q[j++];\n            res+=mid-i+1;//这里是i到mid个元素 要求上边条件必须是 q[i]&lt;=q[j] 这个等号 因为逆序对的要求就是这样\n        }\n    }\n    while(i&lt;=mid) tmp[k++]=q[i++];\n    while(j&lt;=r) tmp[k++]=q[j++];\n    for(int i=l,s=0;i&lt;=r;i++,s++) q[i]=tmp[s];\n    return res;\n}\n</code></pre>\n<h3>二分</h3>\n<h4>Acwing 789. 数的范围</h4>\n<pre><code class=\"language-cpp\">\n/*\n二分 分为两大块 一块是整数二分 会有很多边界问题\n\n\n一共有两个模板 核心区别就是除以2的时候 是不是要加上1\n\n\n//区间被分为 [l,mid]和 [mid+1,r]使用\nint bsearch_1(int l,int r){\n    while(l&lt;r){\n        int mid=l+r&gt;&gt;1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    return l;\n}\n\n//区间被分为 [l,mid-1]和[mid-1,r]时使用\nint bsearch_2(int l,int r){\n    while(l&lt;r){\n        int mid=l+r+1&gt;&gt;1;\n        if(check(mid)) l=mid;\n        else r=mid-1;\n    }\n    return l;\n}\n\n二分的本质 有单调性一定可以二分 但是可以二分的题目不一定非得有单调性 所以二分的本质并不是单调性 是边界\n左边不满足这个性质 右边满足这个性质 二分找的是这个性质的边界点 我们定义的mid  是用来缩小区间的 但是边界点是固定的\n并在不断地二分过程中 逐渐接近并确定边界点 二分红色点和绿色点 就是我们的不同的模板了\n\n找到中间值 mid=l+r/2 if(check(mid))[假如条件是符合左边的性质]\n        true mid一定在左边 那么边界点就在mid右边 就需要更新是 l=mid  =&gt;[mid,r]\n        false mid不满足 在mid右边  边界点在mid左边[不包含mid 最多就是mid下一个位置 mid-1] 就更新为 r=mid-1   =&gt;[l,mid-1]\n        按照模板 mid应该是 l+r+1/2\n    2. 当我们想要二分绿颜色的分界点的时候 mid=l+r/2 if(check(mid))\n        true 满足的话 边界点就在mid左边 并且又可能在mid上 那么更新为 [l,mid]\n        false 不满足 边界点在Mid右边 不包含mid  那么就分为 [mid+1,r]\n\n一个二分问题 先写一个check函数 想一下这个check函数 我们应该如何更新\n    如果说是 l=mid r=mid-1 那么就补上+1\n    如果说是 r=mid l=mid+1 就不需要补上了\n\n二分的主要思想 每次选择答案所在的区间进行处理 每次都保证里边都有答案 长度是1 这个区间里边的数就是答案\n无解的时候 二分的时候一定有解的 题目有可能无解 但是二分一定有解的 定义的一个性质 一定是有解的 只不过答案可能并不是题目的解\n\n*/\nint l=0,r=n-1;//每次二分都是 从l到r结束 最终缩小到一个点\nwhile(l&lt;r){//确定左边界  当循环结束的时候 l和r相等\n    int mid=l+r&gt;&gt;1;\n    if(q[mid]&gt;=x) r=mid;//左边界就是 通过 右边大于等于x  来做这个条件的边界点 确定mid不加1\n    else l=mid+1;\n}\n\nif(q[l]!=x) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;//如果找到这个边界不是x 说明无解\nelse{\n    cout&lt;&lt;l&lt;&lt;&quot; &quot;;//所以这里输出l 或者 r 都可以\n    int l=0,r=n-1;//找到右边界 点\n    while(l&lt;r){\n        int mid=l+r+1&gt;&gt;1;//将小于等于x 为满足条件\n        if(q[mid]&lt;=x) l=mid;//那么成立的时候 mid在边界点的左边 l=mid 需要补 +1\n        else r=mid-1;\n    }\n    cout&lt;&lt;l&lt;&lt;endl;\n}\n</code></pre>\n<h4>Acwing 790. 数的三次方根</h4>\n<pre><code class=\"language-cpp\">\n/*\n二分的第一步是确定我们的边界\n我们不应该在0-n里边找边界 因为这是错误的 有可能n是小于1的 这是不正确的 所以应该取它的范围 -10000-10000\n\n\n\n经验之谈 要求保留6位 就取10^-8 如果保留4位 就取10^-6 这个是 while的边界条件 while(r-l&gt;10-8)\n此外 次方不能用这个 &#39;^&#39;写 这个是亦或符号 因该使用 mid * mid * mid 来写\n*/\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// double res;\n// typedef offset 1e-7;\n\nint main(){\n   double x;\n   cin&gt;&gt;x;\n   double l=-10000,r=10000;\n   while(r-l&gt;1e-8){\n       double mid=(l+r)/2;\n       if(mid*mid*mid&gt;=x) r=mid;\n       else l=mid;//这个不用加一减一 因为这个是浮点数\n   }\n\n    printf(&quot;%lf&quot;,l);//printf()默认保留六位小数 输出l和r都是可以的 因为这两个数足够接近\n    return 0;\n}\n</code></pre>\n<h3>高精度</h3>\n<h4>Acwing 791. 高精度加法</h4>\n<pre><code class=\"language-cpp\">/*\n只能用cin\nstring a,b;\ncin&gt;&gt;a&gt;&gt;b;// 输入字符串更快\nvector&lt;int&gt; A,B;\nfor(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-&#39;0&#39;);// 转化为int型变量 并且从低位开始\nfor(int i=b.size()-1;i&gt;=0;i--) B.push_back(b[i]-&#39;0&#39;);\n*/\nvector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){ // 数组整数 &amp; 表示只是拿来地址 不需要额外的copy一遍 更快\n    vector&lt;int&gt; C;\n    int t=0;// 进位\n    for(int i=0;i&lt;A.size()||i&lt;B.size();i++){// 前边执行成功 不会向后 A大于B长度 小于则继续相加\n        if(i&lt;A.size()) t+=A[i];// 只有小于 才说明这个位置的A有数\n        if(i&lt;B.size()) t+=B[i];\n        C.push_back(t%10);// 只需要保留个位 直接推送 不需要i来加入\n        t/=10;// 进位 大于10 保留1 小于10 保留0\n    }\n    if(t) C.push_back(1); // 最后仍然有进位 则保留1\n    return C;\n}\n</code></pre>\n<h4>Acwing 792. 高精度减法</h4>\n<pre><code class=\"language-cpp\">/*\nif(cmp(a,b)){\n    auto c=sub(a,b);\n    for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);\n}\nelse{\n    auto c=sub(b,a);\n    printf(&quot;-&quot;);\n    for(int i=c.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,c[i]);\n}\n*/\n/*\n高精度减法 是需要两个函数 一个cmp 一个sub  需要大树减小数 然后相减 有可能出现前导零 1000-999=0001\n*/\nusing namespace std;\n\nbool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt;&amp;B){//A&gt;=B? true false\n    if(A.size()!=B.size()) return A.size()&gt;B.size();\n    for(int i=A.size();i&gt;=0;i--)\n        if(A[i]!=B[i])\n            return A[i]&gt;B[i];\n    return true;\n}\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B){\n    vector&lt;int&gt; c;\n    for(int i=0,t=0;i&lt;=A.size()-1;i++){\n        t=A[i]-t;\n        if(i&lt;B.size()) t-=B[i];\n        c.push_back((t+10)%10);\n        if(t&lt;0) t=1;\n        else t=0;\n    }\n\n\n    // for(int i=c.size();i&gt;=0;i--){\n    //     int k=c.pop();\n    //     if(!k) continue;\n    //     else {\n    //         c.push_back(k);\n    //         break;\n    //     }\n    // }\n    while(c.size()&gt;1&amp;&amp;c.back()==0) c.pop_back();\n    return c;\n}\n</code></pre>\n<h4>Acwing 793. 高精度乘法</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nvector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b){\n    vector&lt;int&gt; C;\n    int t=0;\n    for(int i=0;i&lt;A.size()||t;i++){// 要么是A没有循环玩 要么是t不是0 主要解决解决进位\n        if(i&lt;A.size())t+=A[i]*b;\n        C.push_back(t%10);\n        t/=10;\n\n    }\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n}\n</code></pre>\n<h4>Acwing 794. 高精度除法</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nvector&lt;int&gt; div(vector&lt;int&gt;&amp;A,int b,int &amp;r){//返回一个余数 引用\n    //c=A/b 商 余数是R\n    vector&lt;int&gt; C;// 最高位开始算的 只有除法 正着存储好一点 除法存储倒着来存\n    r=0;\n    for(int i=A.size()-1;i&gt;=0;i--){//这个是最高位开始\n        r=r*10+A[i];\n        C.push_back(r/b);//因为r=0 所以 A[i]就是第一位 之后r才会更改\n        r%=b;\n    }\n    reverse(C.begin(),C.end());//统一一下 并且容易去除前导0\n    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();\n\n\n    return C;\n}\n</code></pre>\n<h3>前缀和与差分</h3>\n<h4>Acwing 795. 前缀和</h4>\n<pre><code class=\"language-cpp\">/*\n前缀和的作用是 取中间某一段 不需要循环(O(n))了 之际计算出来的 时间复杂度是O1\nios::sync_with_studio(false) 提高cin读取速度 不能使用scanf了\n*/\n\nscanf(&quot;%d%d&quot;,&amp;n,&amp;m);//scanf比cin 快一倍\nfor(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); //输入 从1开始 是因为定义s[0]=0 这样不用考虑边界s[1]的问题\nfor(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i];//得出s数组\n\n// 或者新的就是\nvoid sum(int q[],int l,int r){\n    for(int i=l;i&lt;=r;i++){\n        q[i]=q[i-1]+q[i];//q[i-1]是最新的 q[i]是旧的\n    }\n}\n// 注意输出的位置\nprintf(&quot;%d\\n&quot;,q[r]-q[l-1]);\n</code></pre>\n<h4>Acwing 796. 子矩阵的和</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nfor(int i=1;i&lt;=n;i++)\n        for(int j=1;j&lt;=m;j++)\n            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//左边矩形 上边矩形 减去重合部分 +a[i][j]\nprintf(&quot;%d\\n&quot;,s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);//起点减去终点\n</code></pre>\n<h4>Acwing 797. 差分</h4>\n<pre><code class=\"language-js\">//差分是用来 构造bi=ai-a[i-1] ai=b1+b2+..bi ai叫做前缀和 bi叫做差分\n//对b求一下前缀和就可以求出来原数组 只要有B数组 用On的时间得到A\n//有需求 对A数组[l j] 全部加上C al+c  ar+c O(n) 用差分就是O1 B\n//球员来的数组 对b求一下前缀和就可以求出来原数组\n// A是B的前缀和 Bl+C 算Al(Al就会自动加上C) Al+1也会加上C 一直到an\n//只需要br+1-C就可以了 (从R+1开始之后全部减去C)\n//想让A数组某段加数值 只需要改一下两个数 bl br+1 时间复杂度就变成o1了\n//拿空间换时间 算法竞赛进阶指南 假定a全是0 看成N次插入操作 b1是1 1 插入a1 b2是2 2插入a2\nvoid insert(int l,int r,int c){\n    b[l]+=c;\n    b[r+1]-=c;\n}\nfor(int i=1;i&lt;=n;i++) insert(i,i,a[i]); //获得差分数组\n</code></pre>\n<h4>Acwing 798. 差分矩阵</h4>\n<pre><code class=\"language-cpp\">\n/*\n差分和前缀矩阵很相似 但是 主要区别在于 构造差分是 增加减少是影响下边区域的 而前缀则是求上边区域的\n构造的同时 插入的是本来的元素 最后求一下前缀和就可以了 对差分求前缀和 这里还是用的b[i][j] 所以这里是\nb[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1] 需要这里的b[i][j]\n*/\nvoid insert(int x1,int y1,int x2,int y2,int c){\n    b[x1][y1]+=c;\n    b[x1][y2+1]-=c;\n    b[x2+1][y1]-=c;\n    b[x2+1][y2+1]+=c;\n}\n// 求差分矩阵的原矩阵 求原来的矩阵\nfor(int i=1;i&lt;=n;i++){\n        for(int j=1;j&lt;=m;j++){\n            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];\n        }\n    }\n</code></pre>\n<h3>双指针算法</h3>\n<h4>Acwing 799. 最长连续不重复子序列</h4>\n<pre><code class=\"language-cpp\">/*\n//我们发现 当对于区间 [j,i-1]来讲 这个区间是单调递增的 而当 [j,i] 时 一旦出现重复\n//只能说明a[i]在前边的区间已经出现过了 因此 我们检测a[i] s[N]是用来检测a[N]中元素出现次数的 一旦重复 就移动j到i这个地方\n//j往前移动 说明 这个区间中出去一个元素 为 a[j] 我们将它从s[N]中减少一次 j继续往前移动 直到移动到 数值同样为a[i]的位置\n//此时 区间重新开始计数 i继续向前走 这个主要用到的时单调性的性质\n*/\nfor(int i=0,j=0;i&lt;n;i++){//一定是a[i]重复了\n        s[a[i]]++;\n        while(s[a[i]]&gt;1){\n            s[a[j]]--;\n            j++;\n        }\n        res=max(res,i-j+1);\n    }\n</code></pre>\n<h4>Acwing 800. 数组元素的目标和</h4>\n<pre><code class=\"language-cpp\">/*\n先想下暴力怎么做 然后针对暴力做优化就可以了\n\n双指针算法就是单调性 AB都是单调上升的 对于每个i来言 我们找到一个满足条件的 Ai+Bi&gt;=X 并且j最小\n我们就可以发现 i往后走的过程中 j一定是向前走的\n\nfor(i=0;i&lt;n;i++) while(j&gt;=0&amp;&amp;Ai+Bi&gt;x) j-- O(n+m)  j总共是m次\nA 1 2 4 7\nB 3 4 6 8 9\n\n总结一下 双指针算法都是先暴力写出来 然后看有没有单调性 如果有单调性的话 就可以把我们的时间复杂度 降低一位\n*/\nfor(int i=0,j=m-1;i&lt;n;i++){\n        while(j&gt;=0&amp;&amp;a[i]+b[j]&gt;x) j--;\n        if(a[i]+b[j]==x){\n            printf(&quot;%d %d\\n&quot;,i,j);\n            break;\n        }\n    }\n</code></pre>\n<h4>Acwing 2816. 判断子序列</h4>\n<pre><code class=\"language-cpp\">/*\n从前往后扫描B这个数组 每次扫描到一个数的时候 判断一下B的当前数是不是和A的当前数一样\n如果一样的话 就将A的当前数 匹配到B的当前数\n\n证明 我们这种方法可以找到B里边的一种匹配方式\n但是我们只能证明可以找到 也要反过来证明一下 里边有解 我们一定可以找到 这种匹配\n假如已经有一种匹配 我们发现和我们匹配的结果不一样 我们匹配的点 一定在B给定匹配前边 那么我们就可以把他调整为我们双指针匹配的\n情况 我们可以发现 调整之后 不会影响后边的匹配 改变之后 还是合法的匹配 这就说明 但凡出现一种匹配 我们的双指针算法必然可以找到\n所以 我们的算法 可以匹配到任意解 (实际上就是在证明贪心 )\n*/\nint i=0,j=0;\n    while(i&lt;n&amp;&amp;j&lt;m){\n        if(a[i]==b[j]) i++;\n        j++;\n    }\n    if(i==n) puts(&quot;Yes&quot;);\n</code></pre>\n<h3>位运算</h3>\n<h4>Acwing 801. 二进制中 1 的个数</h4>\n<pre><code class=\"language-cpp\">//位运算\n\n//常见的位运算的操作 1:n的二进制表示中第K位是几 n&gt;&gt;k&amp;&amp;1\n\n// n=15=11111           (43210) 先把第K位 移到最后一位 n&gt;&gt;k(右移运算)\n# 个位是几 x与1\nn&gt;&gt;k&amp;&amp;1 //右移是将某位移到个位 1010 &gt;&gt;3 1\n\n// 2.lowbit 树状数组的基本操作 返回x的最后一位1  1010&gt;10 101000&gt;1000[返回的是最后一位1 是一个数字 10=&gt;2 1000=&gt;8]\n// x&amp;-x返回最后一个1 补码 -x=~x+1 x&amp;-x=x&amp;(~x+1)\n// lowbit的运用 可以统计x的个数 每次把最后一位1去掉 x=0时可以统计多少个1  lowbit(n)=n&amp;-n;\n// 经典的面试算法先学\n\n//原码 反码 补码 [补码=~X+1 x的反码+1]\n// int n=10;\n// unsigned int x=-n;\n// for(int i=31;i&gt;=0;i--)\n// cout&lt;&lt;(x&gt;&gt;i&amp;1); i=31 是为了展示前边的1\n\n// 为什么要用补码 : -x=0-x;\n                    // 32个0-x 不够 实际上是向前借一位然后减去 等于\n                    // 反码+1=~x+1=-x\n// 位运算 第k位数字 n&gt;&gt;k&amp;1\nn的最后一位1 //lowbit(n)=n&amp;-n\n//人类做题的过程其实是dfs的过程 首先暴力搜索 一层树 每次继续细分 经典问题 叶节点就是我们学过的算法\n// 各种各样的基础算法  提高班来解决这些东西\n</code></pre>\n<h3>离散化</h3>\n<h4>Acwing 802. 区间和</h4>\n<pre><code class=\"language-cpp\">/*\nprintf(&quot;%d %d&quot;,1e7,6e6);为什么这个输出结果为0\n在C语言中，当你尝试使用%d格式说明符来打印一个浮点数时，它不会进行类型转换，而是直接解释浮点数在内存中的位模式作为整数。\n由于浮点数的内部表示和整数通常不同，因此这种解释通常会产生不可预测或错误的结果。\n\n一个Int范围 32位 共 +- 21亿\n\n\n本题的关键是 n是10^9 是10亿  而 int最多1e7+6e6 所以需要映射一下\n将所有输入都存储起来 然后加起来\n此外还需要查询 我们将所有可能用到的坐标压缩到一个vector 然后去重 得到的数组根据find(二分法来找到分配的坐标)\n加完之后应用一下就可以了 这样可以直接求出来前缀和\n然后循环一下query 就可以了\n\n\nvector&lt;int&gt; alls;//所有代离散的值\nsort(alls.begin(),alls().end()) ;所有值排序\nalls.erase(unique(alls.begin(),alls.end()),alls.end()); 曲中 二分查出x的离散值\n\n*/\nint find(int x){\n    int l=0,r=alls.size()-1;\n    while(l&lt;r){\n        int mid=(l+r)/2;\n        if(alls[mid]&gt;=x) r=mid;\n        else l=mid+1;//返回的all[i] 中的位置 就是这个x在alls中排第几个 然后赋值给a[i] 这样做的好处 就是 将大坐标压缩到一个小数组中\n        //尽管数值很大 但是我们的个数是很少的 只需要占用数字个数的空间\n    }\n    return l+1;\n}\n</code></pre>\n<h3>区间合并</h3>\n<pre><code class=\"language-cpp\">/*\n//这种方式不太好 感觉优点混淆 还是合并一下 放进res 然后直接输出res.size()就可以了\n// int res;\n// void merge(vector&lt;PII&gt; &amp;segs){\n\n//     sort(segs.begin(),segs.end());\n//     int st=-2e9,ed=-2e9;\n//     for(auto seg:segs){\n//         if(ed&lt;seg.first) {\n//             st=seg.first;\n//             ed=seg.second;\n//             res++;\n//         }\n//         else {\n//             ed=max(ed,seg.second);\n//         }\n//     }\n// }\n*/\n\n/*\n首先使用pair来存储所有区间 然后根据左端点排序(sort对pair自动按照左端点进行排序)\n然后使用st来保持上一个的片段 如果当前seg&lt;ed 说明没有交集 如果st不为空 推入res 如果seg.f&gt;ed 说明有交集\n比较一下当前seg.s和上一个片段的ed 取一个最大值就可以了\n使用st ed一开始指向为空(-2e9)\n*/\ntypedef pair&lt;int,int&gt; PII;\n\nconst int N=1e5+10;\n\nvector&lt;PII&gt; segs,res;\n\n\nvoid merge(vector&lt;PII&gt; &amp;segs){\n    sort(segs.begin(),segs.end());\n    int st=-2e9,ed=-2e9;\n    for(auto seg:segs){\n        if(ed&lt;seg.first){\n            if(st!=-2e9) res.push_back({st,ed});//把上的一段推送进入res st更新为当前的\n            st=seg.first,ed=seg.second;\n        }else{\n            ed=max(ed,seg.second);\n        }\n    }\n    if(st!=-2e9) res.push_back({st,ed});//最后会剩余一段 (当前段) 进入res\n    return;\n\n}\n</code></pre>\n"},{"id":2,"title":"ch2-数据结构","date":"2024-04-24","content":"<h2>总览</h2>\n<blockquote>\n<p><a href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\">单链表</a> &gt; <a href=\"#%E5%8F%8C%E9%93%BE%E8%A1%A8\">双链表</a> &gt; <a href=\"#%E6%A0%88\">栈</a> &gt; <a href=\"#%E9%98%9F%E5%88%97\">队列</a> &gt; <a href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\">单调栈</a> &gt; <a href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\">单调队列</a> &gt; <a href=\"#KMP\">KMP</a> &gt; <a href=\"#Trie\">Trie</a> &gt; <a href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\">并查集</a> &gt; <a href=\"#%E5%A0%86\">堆</a> &gt; <a href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8\">哈希表</a></p>\n</blockquote>\n<pre><code class=\"language-cpp\">/*\n\n单调栈 当我们枚举到某个元素x的时候 如果x小于x前边的所有元素 那么针对后边的元素 x前边所有的元素都是没有用的\n所以这个就是关键点\n\n双链表\nr[0]=1,l[1]=0,idx=2;\n注意 第k个数 那么就是k-1个数 下标就是k+1 0是左端点 1是右端点 l[1]是右端点前一个点 r[0]是左端点后一个点\n\nkmp\n这个就是next数组的含义 next[i]的意思是 以i位终点的后缀  和从1开始的前缀相等 而且 后缀长度最长\n这个next[i]=j 的含义就是 p[1,j]=p[i-j+1,i]\n下标从1开始 匹配从1开始 计算ne从2开始\n\n并查集 一开始每个集合的父亲就是自己 char op[2];scanf(&quot;%s&quot;,op)因为%c会读入空格 所以要用%s 合并集合\n\nTire字符串\nson[N][26] 每个字符都有26条出路 这个N是数据范围 应该包含总的个数不超过多少 所以不需要担心会MLE 用来做提示词\n\nHash 存放X 询问X是不是在集合中出现过(数据访问) 拉链法和开放寻址法 前者所有的位置开一个链表 也是H[N] ne[N] 开放寻址法 find x 是否出现过(下标) 分配的位置 (下标) -10^9~10^9 那么空为 0x3f3f3f3f 数据空间要开 2~3倍数据空间 开发寻址 模数要取空间略大的质数 while(h[k]!=null&amp;&amp;h[k]!=x)\n\n字符串Hash Hash基 判断字符串是不是相同 这个就是字符串hash 131或者 13331\n*/\n</code></pre>\n<h3>单链表<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 826. 单链表</h4>\n<pre><code class=\"language-cpp\">/*\n// 章节导入 我们使用数组模拟链表 链表 可以通过结构体加指针来实现 也可以通过数组来实现(这里数组是效率问题 效率很快)\n// 链表与邻接表\n// 栈与队列 使用stl容器\n// kmp\n// 笔试都i用静态链表 不用new 因为太耗时间了 优化(初始化N个 这么做就和数组模拟一样了)\n// 双链表用来优化某些问题\n// 单链表最大的用处是写邻接表 邻接表最大的用处是用来存储图和树\n// 双链表用来优化某些问题\n// 单链表只能先前看 只能从头开始遍历 O(1)的时间找到下一个元素 但是却找不到上一个点的位置\n// 算法题 用空间换来时间 用1s来讲算法跑完 浪费就浪费了 要不然会将自己绕进去\n// 工程 动态链表 可能需要考虑内存泄露的问题\n// 尾插法O1 可以O1\n// 题目描述 这里说的是  D k删除下标是k-1的数字\n// 题目中定义了 第K个数 所以使用idx用来标识下标位置的做法是正确的\n\n//一定要注意删除的是 第K个插入的数  而不是第K个数(不会减少)\n#include &lt;iostream&gt;\n\nusing namespace std;\nconst int N=100010;\n\nint head,e[N],ne[N],idx;//idx 表示当前用到了哪些数 同样的 我们删除第K个数字 只是让他没有办法被链表访问 没有指针指向它\n\n\n// 初始化\n*/\nvoid init(){\n    head=-1;\n    idx=0;\n}\nvoid add(int x){\n    e[idx]=x,ne[idx]=head,head=idx++;////为x分配空间 x指向head指向的元素 head指向x idx++\n}\nvoid insert(int k,int x){\n    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;\n}\nvoid remove(int k){\n    ne[k]=ne[ne[k]];////k指向为 k下一个元素指向的元素\n}\n</code></pre>\n<h3>双链表<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 827. 双链表</h4>\n<pre><code class=\"language-cpp\">/*\n\n\n\n我们就吧 0号点和1号点用过了 这个是确定的 那么idx=2开始 第一个插入的数 下标是 2\n那么第k个数就是 k+1[坐标从0开始 下标为k+1] remove就是针对下标为a进行操作的\n\n写的是在a的右边插入一个数 那么在第k个数(下标为k+1) 左边插入一个数 应该通过指针来做\n而不是按照下标来做 remove(l[k+1])\n*/\nvoid insert(int a,int x){//在a的右边插入一个数字\n    e[idx]=x,l[idx]=a,r[idx]=r[a];\n    l[r[a]]=idx,r[a]=idx++;\n}\n\nvoid remove(int a){\n    r[l[a]]=r[a];\n    l[r[a]]=l[a];\n}\n//e[0]为空 e[1]为空 他们两个互相指向  0号点是左端点 1号点是右端点 idx从2号点开始\nr[0]=1,l[1]=0,idx=2;\n//第k个数 那么就是k-1个数 下标就是k+1 0是左端点 1是右端点 l[1]是右端点前一个点 r[0]是左端点后一个点\ncin&gt;&gt;op;\nif(op==&quot;L&quot;){\n    cin&gt;&gt;x;\n    add(0,x);\n}else if(op==&quot;R&quot;){\n    cin&gt;&gt;x;\n    add(l[1],x);//注意这里 在尾部插入x\n}else if(op==&quot;D&quot;){\n    cin&gt;&gt;k;\n    remove(k+1);//第k个数 对应链表中的k-1+2//从2开始是0号点\n}else if(op==&quot;IL&quot;){\n    cin&gt;&gt;k&gt;&gt;x;\n    add(l[k+1],x);\n}else if(op==&quot;IR&quot;){\n    cin&gt;&gt;k&gt;&gt;x;\n    add(k+1,x);\n}\n</code></pre>\n<h3>栈<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 828. 模拟栈</h4>\n<pre><code class=\"language-cpp\">/*\n*/\nint stk[N],tt;//这里就是tt指向头部 一定考虑好先++还是后++\nvoid push(int x){\n    stk[++tt]=x;\n}\nint query(){\n    return stk[tt];\n}\nvoid pop(){\n    if(tt){\n        tt--;\n    }\n}\nbool empty(){\n    return tt&lt;=0;\n}\n</code></pre>\n<h4>Acwing 3302. 表达式求值</h4>\n<pre><code class=\"language-cpp\">/*\n如果（ 压入\n如果 ）运算直到遇到（ 然后弹出（ 有括号不会压入\n如果其他 op不为空 且 s[i]优先级小于op栈顶元素 运算  压入此运算符 比较运算符要考虑（括号问题\n\n那么实际上 op栈中始终只存在一种运算符\n\n*/\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\n#include &lt;unordered_map&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nstack&lt;char&gt; op;\nstack&lt;int&gt; nums;//操作数\n\nvoid eval(){//取出来两个数和一个操作符 进行运算\n    int b=nums.top();nums.pop();\n    int a=nums.top();nums.pop();\n    char opc=op.top();op.pop();\n    int x;\n    if(opc==&#39;+&#39;) x=a+b;\n    else if(opc==&#39;-&#39;) x=a-b;\n    else if(opc==&#39;*&#39;) x=a*b;\n    else if(opc==&#39;/&#39;) x=a/b;\n    nums.push(x);\n}\n\n\nint main(){\n    unordered_map&lt;char,int&gt; pr{{&#39;+&#39;,1},{&#39;-&#39;,1},{&#39;*&#39;,2},{&#39;/&#39;,2}};//定义优先级\n    string s;\n    cin&gt;&gt;s;\n    for(int i=0;i&lt;s.size();i++){\n        auto c=s[i];\n        if(isdigit(c)){//算一下从i开始 到第一个不为数字的字符之间的数字\n            int j=i,x=0;\n            while(j&lt;s.size()&amp;&amp;isdigit(s[j])){\n                x=x*10+s[j++]-&#39;0&#39;;\n            }\n            nums.push(x);\n            i=j-1;\n        }else if(c==&#39;(&#39;){\n            op.push(c);\n        }else if(c==&#39;)&#39;){\n            while(op.size()&amp;&amp;op.top()!=&#39;(&#39;) eval();\n            op.pop();\n        }else{\n            while(op.size()&amp;&amp;op.top()!=&#39;(&#39;&amp;&amp;pr[c]&lt;=pr[op.top()]) eval();\n            //这里需要注意集合如何访问\n            op.push(c);\n        }\n    }\n    while(op.size()) eval();\n    cout&lt;&lt;nums.top()&lt;&lt;endl;\n    // while(nums.size()) {\n    //     cout&lt;&lt;nums.top()&lt;&lt;&quot; &quot;;\n    //     nums.pop();\n    // }\n    \n    return 0;\n}\n</code></pre>\n<h3>队列<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 829. 模拟队列</h4>\n<pre><code class=\"language-cpp\">\nint q[N],tt,hh;\nvoid pop(){\n    hh++;\n}\nvoid push(int x){\n    q[++tt]=x;\n}\nbool empty(){\n    return tt&lt;hh;\n}\nint query(){\n    return q[hh];\n}\n</code></pre>\n<h3>单调栈<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 830. 单调栈</h4>\n<pre><code class=\"language-cpp\">/*\n单调栈 求每一个数左边 离他最近的且比他小的数字在哪里\n3 4 2 7 5 因为7左边距离最近的是2 5比他小最近的是2\n-1 3 -1 2 2\n双指针是类似的 做法 先想一下暴力做法是什么 然后挖掘一些性质 可以把目光放到比较少的状态里边\n从而降低时间复杂度\n实例 双重循环 二重从i-1 一直向左走 找到比他小的就可以\n性质 i向右走的过程中 可以用栈存起来 i每走一次就向其中加一个数字 每次找的时候 都是从栈顶开始找 找到比i小的数位置\n看栈的性质 有些答案永远不会输出出来  如果a3&gt;=a5 如果目标是a3 那么换成a5一定会更好 并且距离i更近\nx&lt;y ax&gt;=ay 那么ax就可以删掉 剩下的序列一定是单调序列了 stk[tt]&gt;=i 那么i永远是最优解 可以讲stk[tt]删掉了\n\n*/\nfor(int i=0;i&lt;n;i++){\n        int x;\n        scanf(&quot;%d&quot;,&amp;x);\n        while(tt&amp;&amp;stk[tt]&gt;=x) tt--;//栈式不空的 并且栈顶元素式大于我当前这个数的 所以删除一下\n        if(tt) printf(&quot;%d &quot;,stk[tt]);// 做完之后 发现栈顶元素不是空的 那么说明栈顶这个元素就是我们需要找的值\n        else printf(&quot;-1 &quot;);// 如果空返回-1\n\n        stk[++ tt]=x;\n\n    }\n// 可以发现 scanf比cin 快了大概10呗\n// cin.tie(0) 此时 cin和scanf几乎等价 然而后者还是比较快\n//每个元素最多进站一次 出战一次 最多是2n 所以时间复杂度是o(n)\n</code></pre>\n<h3>单调队列<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 154. 滑动窗口</h4>\n<table>\n<thead>\n<tr>\n<th>窗口位置</th>\n<th align=\"center\">最小值</th>\n<th align=\"center\">最大值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[1 3 -1] -3 5 3 6 7</td>\n<td align=\"center\">-1</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td>1 [3 -1 -3] 5 3 6 7</td>\n<td align=\"center\">-3</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td>1 3 [-1 -3 5] 3 6 7</td>\n<td align=\"center\">-3</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>1 3 -1 [-3 5 3] 6 7</td>\n<td align=\"center\">-3</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>1 3 -1 -3 [5 3 6] 7</td>\n<td align=\"center\">3</td>\n<td align=\"center\">6</td>\n</tr>\n<tr>\n<td>1 3 -1 -3 5 [3 6 7]</td>\n<td align=\"center\">3</td>\n<td align=\"center\">7</td>\n</tr>\n</tbody></table>\n<pre><code class=\"language-cpp\">/*\n单调队列 基本上最常用的就几道\n求一下滑动窗口里边的最大值或者最小值\n1 3 -1 -3 5 3 6 7\n暴力怎么做 把其中没有用的元素删掉 得到单调性了 有了单调性就可以求出极值\n就可以把原来需要枚举的时间节省掉\n窗口可以用队列来维护 从空开始 一直插入满3 左出1 右进1 队列来维护 每次求极值 遍历所有元素 时间复杂度o(k) o(nk)//n次操作 每次k\n队列元素是不是某些元素没有用\n只要存在这样的情况 前边有个数 比后边这个数大 所以前边这个点一定没有用 就可以把这个大的点删掉\n删除之后 就一定是单调上升的队列 左端点 q[hh] 单调都是暴力模拟一下 以后看一下那些元素是没有用的\n剩下来的就是有单调性 这样取极值就非常方便了 如果找一个值就用二分 单调问题都是这样\n先考虑暴力怎么做 然后是把没有用的元素删掉 然后考虑单调性 然后有单调性的话看如何取优化这个问题\n怎么看队头元素什么时候出队呢 i是我们枚举的元素 队尾 k是我们的长度 i-k+1就是队头 如果hh不再区间 i-k+1 i 就可以把k去掉\n数组模拟速度快(绝对优点) 比stl c++开o2 和o3 优化 之后stl和数组相差无几 但是比赛的时候不会看o2优化 stl会比数组模拟慢一些\n*/\n\n#include &lt;iostream&gt;//算法竞赛将数据取极限 对java不太好\nusing namespace std;\nconst int N=1000010;\nint n,k;\nint a[N],q[N];\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);\n    for(int i=0;i&lt;n;i++) scanf(&quot;%d &quot;,&amp;a[i]);\n\n    int hh=0,tt=-1;\n    for(int i=0;i&lt;n;i++){\n\n        //判断队头是否已经划出窗口 这里是弹出 队头 正常的范围是 i-k+1 到 i q[hh] 这个主要原因是 全部是递增的 需要出掉队头\n        //q[hh]已经是最小的了 但是旧的区间是\n        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;\n        while(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;//如果遍历的元素小于队尾 将队尾弹出 直到a[q[hh]]是最小的元素\n        //因为a[i]会一直比较 直到a[q[hh]-q[tt]]这个队列中单调递增 (hh是最小的)\n        //如果a[i]是最小的 hh是固定会加的 tt会一直减少 直到序列中留下a[i]这个元素 此时a[q[hh]]就是队头 就是最小的\n        //如果a[i]不是最小的 就会加入队列中 但是可以保证hh一定是最小的端点 我们把最小的端点输出 就是这个区间中最小的\n        //向q[]中添加元素的时候 就决定是单调递增的 如果大于a[i]&gt;a[tt] 就弹出\n\n        q[++ tt]=i;//将遍历的这个i 下标加入q  向q中添加元素 不需要考虑q[]的数值问题\n        //这里其实也对应了tt为什么初始为-1 因为是先加加然后添加元素 如果tt=0 则需要hh&lt;tt 且q[tt++]=i 实际上是等效的\n        if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]);//前k个数不需要输出 需要满足 至少k个数字\n\n\n    }\n    puts(&quot;&quot;);\n\n\n\n\n\n\n    hh=0,tt=-1;\n    for(int i=0;i&lt;n;i++){\n        if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;\n        while(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;\n        q[++ tt]=i;\n        if(i&gt;=k-1) printf(&quot;%d &quot;,a[q[hh]]);\n    }\n    puts(&quot;&quot;);\n    return 0;//152\n}\n\n// for(int j=hh;j&lt;=tt;j++)\n//      printf(&quot;%d &quot;,a[q[j]]);//通过这种方法来查看本次遍历有什么元素\n// printf(&quot;第%d次遍历 \\n&quot;,i);\n//  一句话总结一下 我们维护了一个序列 确保这个序列中是有单调性的 如果有单调性的话 我们直接取端点值就可以\n// 直接获取最大值最小值 要么有单调性 要么就直接是最小值 如果 我们在遍历到这个元素i的时候 就可以直接输出出来q[hh]指向的元素就可以\n// 需要考虑的是hh tt的位移问题 要保证 tt-hh 一定是\n//\n\n//关键点  需要考虑的用到队头相加的操作 if(hh&lt;=tt&amp;&amp;i-k+1&gt;q[hh]) hh++;\n//字面意思来看 hh&lt;=tt 队列不为空  q[hh]且 i-k+1 最小区间 超出\n//实际上也是就是最小区间 但是我们实际上考虑的是为什么不和下一步使用相同方法来通过t--弹出而是用h++\n// 我们选择在算法结束是输出q[tt] 和q[hh] q[tt]是0 1 2 3 4 5 6 7 但是q[hh] 是 0 0 2 3 3 3 5 5\n// 我们定义变量s=0(每次循环都会初始化) 然后输出 发现在q[tt]为6的时候执行了一次h++\n// 我们继续回到这个问题 为什么不和下一步使用相同方法来通过t--弹出而是用h++\n// 关键在执行顺序上 我们执行过q[tt]为5 之后 q[hh-tt]之间的元素\n// 剩下来 -3 3 6这明显是正确的 然而 当为-3的时候 此时窗口长度已经成为了4  但显然我们本身的i还是需要添加进去的\n//只能执行hh++\n//我一开始一位h++只是单纯的 让q[hh] q[tt]这个维护的队列长度为3 并且一直移动恒定为3 实际上q 这个序列从一开始就是固定的\n//q[&gt;k+hh]也是没有值的 我们只是用q来存取窗口中的序列 并不会跟着i一直移动 这点很绕 体系在q[] 实际存储的是下标\n//我想 单纯的提这一点并不能很好的理解\n</code></pre>\n<h3>KMP<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 831. KMP 字符串</h4>\n<pre><code class=\"language-cpp\">/*\n过程比较抽象 字符串 双指针\n暴力做法是怎么做的\n原串 s[N] p[M] 原串 匹配床\nfor(int i=1;i&lt;=n;i++){//当前的起点\n    bool flag=true;\n    for(int j=1;j&lt;=m;j++){//\n        if(s[i+j-1]!=p[j]){\n            flag=false;\n            break;//如果对于固定匹配 一旦有一个字符不相同 就失败\n        }\n    }\n}\n实现上 当前边陪陪成功 m-1 位匹配不成功 那么整体往后移动一位\n匹配不成功的时候 最大右移多少 来让头部从此开始\n就是想要实现 匹配失败前边 i为止  前缀和后缀最大相同长度\n这个就是next数组的含义 next[i]的意思是 以i位终点的后缀  和从1开始的前缀相等 而且 后缀长度最长\n这个next[i]=j 的含义就是 p[1,j]=p[i-j+1,i]的 我们通过ne[i]可以很快的从\n*/\n\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N=100010,M=1000010;\n\nint n,m;\nchar s[M],p[N];\nint ne[N];//next[N]有可能出错 因为next是用过的 所以启成ne\n//ne 的具体含义就是 当取到I项的时候 这个i前边(包含自身)所有元素中 以i位终点的这段和和从1开始的前缀相等 而且 后缀长度最长\n\nint main(){\n\n    cin &gt;&gt; n &gt;&gt; p+1 &gt;&gt; m &gt;&gt; s+1;//p+1 是从p数组的1开始 p[0]是没有值(初始化为 &#39; &#39;)\n\n\n\n    //求ne[j] 每次和i进行匹配 如果i-1都正常 j就更换位ne[j] 退一步 尝试\n    for(int i=2,j=0;i&lt;=n;i++){//从2开始 ne[1]=0 如果匹配失败了 就只能从0开始匹配\n        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];//如果j不是0 并且现在这个值和下一个值不匹配 回退\n        if(p[i]==p[j+1]) j++;//\n        ne[i]=j;//注意这里是加过1的j\n    }\n    /*\n    cin&gt;&gt;n&gt;&gt;(p+1)&gt;&gt;m&gt;&gt;(s+1);//ne[0]不存在 我们要从ne[1]=0开始 如果第一个不匹配 就从0开始 表示从新开始匹配\n    for(int i=2,j=0;i&lt;=n;i++){//p是子串 s是父串 i表示需要匹配的位置 j表示已经匹配的位置 \n        while(j&amp;&amp;p[i]!=p[j+1]) j=ne[j];//如果j!=0  需要匹配的和匹配的下一个不成立 j=ne[j]\n        if(p[i]==p[j+1]) j++;\n        ne[i]=j;//注意 ne[i]寸的是 后边的这个 i始终自增\n    }\n    */ \n\n\n\n\n    //kmp 匹配过程\n    for(int i=1,j=0;i&lt;=m;i++)//next[j]就是匹配的最大长度 i是当前的s[i] 试图匹配的是[j+1]\n    {\n        while(j&amp;&amp;s[i]!=p[j+1]) j=ne[j];\n        //如果j没有退回起点 如果退回七点 含义就是我要重新开始匹配了 j就是ne[j] 最大长度\n        //并且下一位不能和s[i]匹配成功的话\n        if(s[i]==p[j+1]) j++;//如果这个位置相同 i=1 j=0先有i 后有j 就对j++\n        if(j==n){\n            printf(&quot;%d &quot;,i-n);\n            j=ne[j];//可以理解为继续匹配 个人不是很理解 觉得应该是0 就这样写罢\n\n        }\n    }\n    return 0;\n\n}\n/*\n最大前缀和后缀相等 前缀长度1 长度2(满足长度小于自身长度)\ns=&quot;abababc&quot;\np=&quot;abababab&quot;\nnext[1]=0 next[2]=0 next[3]=1 next数组只和P字串本身有影响\n我们代码里边比较的是j+1 i=7的时候 j=6 此时匹配失败\n发现问题所在 j=6的时候 ne[6]=4 j重新指向4 此时c前边的4位\n和P前边的4位相同 意义就是不需要重新比较了 直到跳到开头为止\n时间复杂度是On的 每次i循环的时候 j最多会加上1 j最多加m次 i(循环m步数)\n而while内部 j=ne[j] 每次至少减1 每执行一次while 都会减去1 那么j最多减去m次\n所以时间复杂度是o(2m) o(n)的\n*/\n</code></pre>\n<h3>Trie<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 835. Trie 字符串统计</h4>\n<pre><code class=\"language-cpp\">/*\n支持两个操作 快速存储 和查找字符串的数据结构\nabcd bacd abcf\n遍历每个字母  如果有这个字母就继续往下走 没有就创建\n结尾的地方打上标记\n107 输入输出卡的并不是很严\n\n*/\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N=100010;//每个字符串都可以是N\n\nint son[N][26],cnt[N],idx;//idx为0 既是根节点也是空节点 只包含小写字母 最多连26条边  当前用到了那个下标 竖直方向上\n//cnt 是当前这个节点有多少个\nchar str[N];\n\nvoid insert(char str[]){\n    int p=0;//根节点开始遍历\n    for(int i=0;str[i];i++){\n        int u=str[i]-&#39;a&#39;;//对应的子节点编号\n        if(!son[p][u]) son[p][u]=++idx;//求儿子 son[父元素][子元素的名字]=子元素位置 根据父元素查找子元素\n        p=son[p][u];//因为存储的是位置 (映射到cnt中的位置 每次插入都会申请一个新的位置 所以不会有重合的情况)\n\n    }\n    cnt[p]++;//每个单词都会在cnt中登记一次\n    //单词的每个字母 通过son来映射出来\n\n}\n\nint query(char str[])\n{\n    int p=0;\n    for(int i=0;str[i];i++){\n        int u=str[i]-&#39;a&#39;;\n        if(!son[p][u]) return 0;\n        p=son[p][u];\n    }\n    return cnt[p];\n}\nint main(){\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n    while(n--){\n        char op[2];\n        scanf(&quot;%s%s&quot;,op,str);\n        if(op[0]==&#39;I&#39;) insert(str);\n        else printf(&quot;%d\\n&quot;,query(str));\n    }\n    return 0;\n}\n\n//算法题目里边 题目一定限制字母的种类 不会特别多的 idx 使用到那个节点\n//汉字也是 可以搞得 也是二进制来存储的 都是二进制字节码 个数特别多的话 可以用二进制来存\n//cnt[x]以x结尾的点有多少个 son[x]是x的所有儿子 son[x][1]是x的第一个儿子\n</code></pre>\n<h4>Acwing 143. 最大异或对</h4>\n<h3>并查集<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 836. 合并集合</h4>\n<pre><code class=\"language-cpp\">/*\n并查集 非常喜欢考察\n思路比较精巧 代码比较短\n并查集 快速支持一些操作\n1.将两个集合合并 2.询问连个元素是否在一个集合当中\n定义一个操作 belong[x]=a 用数组来存储每个集合\nif(belong[x]==belong[y])\n但是如果想要合并两个集合就比较难了 将每个元素序号改一下\n近乎O1 的操作支持这两个操作\n基本原理 通过树来维护每个集合 树根的编号就是整个集合的编号 用每个节点存储它的父节点 p[x]表示x的父节点\n问题1 如何判断树根 if(p[x]==x)\n如何求x的集合编号 while(p[x]!=x) x=p[x]; 如果不是树根就继续向上走\n如何合并两个集合 将集合2的根节点搬到集合1父节点下边就可以了 或者 相反的操作\np[x]是x的集合编号 py是y的集合编号 p[x]=y就可以了 找爹认爹操作\n实际上复杂度还是很高的 主要是因为求集合编号的问题上 和高度成正比\n优化 路径压缩 首次遍历一个叶节点 找到父节点之后 直接将路径上所有元素指向根节点\n按支合并 优化不明晰那 用的很少 代码量大\n并查集是用来维护信息的 比较重要的\n\n*/\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=100010;\n\nint n,m;\nint p[N];\n\nint find(int x){//返回x的祖宗节点+路径压缩\n    if(p[x]!=x) p[x]=find(p[x]);//已经压缩了\n    return p[x];\n}\n\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++) p[i]=i;//初始的时候每个元素都是单独的集合 那么集合树根就是自己\n    while(m--)\n    {\n        char op[2];//因为scnaf如果%c的时候会读入空格 %s会自动忽略空格和回车 读一个字符尽量用自字符串%s 出题人有时候会多一个空格\n        int a,b;\n        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);//学的教训和经验\n        if(op[0]==&#39;M&#39;) p[find(a)]=find(b);// find查找元素的祖宗节点 a的祖宗节点的父亲等于b的祖宗节点  将a合并到b的下边去\n        else{\n            if(find(a)==find(b)) puts(&quot;Yes&quot;);\n            else puts(&quot;No&quot;);\n        }\n    }\n    return 0;\n}\n// 人们对于未知是很恐怖的 因为不知道该怎么实现 理解过之后会变得很简单\n// 完全知道怎么写之后 会变得很简单\n</code></pre>\n<h4>Acwing 837. 连通块中点的数量</h4>\n<pre><code class=\"language-cpp\">output :Yes 2 3\n/*\n变集 维护额外的信息 维护一下每个集合有多少格元素\n同一个点 连成一个自环 连通块 a&gt;b b&gt;a都可以走通的话 就说它们在同一个块当中\n最好将题意看一下 将数学问题和题目的输入输出进行了解\n57 39 当我们连接两个连通块的时候 实际上就是将将两个集合合并的过程\n\n*/\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N=100010;\n\nint n,m;\nint p[N],cnt[N];// size 就是表示我们每个集合的大小 每个集合的大小\n// 我们规定 只有根节点的size有意义 将a合并到b中时 size[b]+=size[a];\n\nint find(int x){\n    if(p[x]!=x) p[x]=find(p[x]);\n    return p[x];\n}\n\nint main()\n{\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++) {\n        p[i]=i;\n        cnt[i]=1;//几乎是相同的 因为cnt一开始每个集合单独的自身节点为1\n    }\n    while(m--)\n    {\n        char op[5];\n        int a,b;\n        scanf(&quot;%s&quot;,op);\n        if(op[0]==&#39;C&#39;){// 连接 就相当于将集合合并到另外一个集合 让size转移\n            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n            if(find(a)==find(b)) continue;//如果在相同集合里 集合元素翻倍 肯定不对的\n            cnt[find(b)]+=cnt[find(a)];//这里 continue 是直接跳过本次循环\n            p[find(a)]=find(b);\n        }\n        else if(op[1]==&#39;1&#39;){\n            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n            if(find(a)==find(b)) puts(&quot;Yes&quot;);//这里判断时候在同一个连通块里边 实际上就是在同一个集合里边\n            else puts(&quot;No&quot;);\n        }\n        else{\n            scanf(&quot;%d&quot;,&amp;a);\n            printf(&quot;%d\\n&quot;,cnt[find(a)]);\n        }\n    }\n    return 0;\n}\n//240 find函数是精髓 这道题需要维护到根节点的距离\n</code></pre>\n<h4>Acwing 240. 食物链</h4>\n<h3>堆<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 838. 堆排序</h4>\n<pre><code class=\"language-cpp\">/*\n堆 手写一个堆\n维护一个数据集合\n插入一个数\n求集合当中最小值\n删除最小值\n删除任意一个元素\n修改任意一个元素 //stl是没有办法直接实现 Stl里边的堆就是优先队列\n堆的基本结构 二叉树(完全二叉树) 除了最后一层 上面节点都是满的\n最后一层几点是从左向右排列 小根堆 每个点都是小于左右儿子的 根节点就是最小值\n堆的存储 全新的存储方式 一维数组来存 1号是根节点 节点X的左节点是 2X 右的有儿子是2X+1\ndown(x) up(x) 往下往上调整 五个操作 插入一个比较大的数 down就是将这个数向下移动 就是向下沉\n放进去一个数 然后和左右儿子比较 和较小的数交换位置 直到不能再沉就行了\n  3\n 4  2(6)// 原来是6 修改成2 因为3一定是比4小的 所以只需要和父节点比较就可以了\n如果比较小 就和父节点交换\n在最后一个元素位置插入X heap[++size]=x;up(size);\n2. heap[1]\n3. heap[size]=heap[1];size--;down(1); 先用最后一个元素覆盖掉 然后size-- 然后down(1)\n 删除头节点很困难 但是删除尾巴就可以\n4.删除任意一个点 heap[k]=heap[size];size--;down(k);up(k);//可以比较一下两个值 但其实只会执行一个 就不用多一个判断了\n5. heap[k]=x;down(k);up(k);\n注意从1 开始 0的左儿子还是0 就冲突了\ndown操作是个递归的过程\n本题是一个全新的排序方式 叫做堆排序\n把整个数组建成堆 每次把堆顶输出出来 发现只需要2和3操作 这里只需要使用down操作就可以了\n*/\n\n\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int N=100010;//时间复杂度 和高度成正比 所以是插入删除都是Log(N) 最小值O(1)\n// 建堆 一个一个往里边差 但是时间复杂度是n(logn)的\n\nint n,m;\nint h[N],cnt;\n\nvoid down(int u){\n    int t=u;\n    if(u*2&lt;=cnt&amp;&amp;h[u*2]&lt;h[t]) t=u*2;\n    if(u*2+1&lt;=cnt&amp;&amp;h[u*2+1]&lt;h[t])t=u*2+1;\n    if(u!=t){//如果最小的不是根节点 就交换一下\n        swap(h[u],h[t]);//更换的是数值\n        down(t);\n    }\n}\n\nvoid up(int u){\n    while(u/2&amp;&amp;h[u/2]&gt;h[u]){\n        swap(h[u/2],h[u]);\n        u/=2;\n    }\n}\n\n\nint main(){\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;h[i]);\n    cnt=n;\n\n    for(int i=n/2;i;i--) down(i);\n    //O(n) 完全二叉树 n/2 开始down 最后一层是一个点 不需要down 从高度为1 的层开始down\n    //最后一层非叶节点个数为n/4*1(down1次) 向上为n/8(down2次)\n    // n(1/2方+2/2 3方+3/2 4方...)=S  2S=n(1/2+2/2 2方+3/2 3方)\n    //2S-S=1/2+1/2 2方 +1/2 3方... 小于1 所以小于n\n    while(m--)\n    {\n        printf(&quot;%d &quot;,h[1]);\n        h[1]=h[cnt];\n        cnt--;\n        down(1);\n    }\n    return 0;\n    //144 down只需要保证每个儿子是堆就可以了 因为从下向上 所以这个条件成立\n}\n</code></pre>\n<h4>Acwing 839. 模拟堆</h4>\n<h3>哈希表<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<h4>Acwing 840. 模拟散列表</h4>\n<pre><code class=\"language-cpp\">\n/*\nHash表 与 STL技巧\nHash两块 存储结构 字符串Hash\n\n         ——开放寻址法(根据冲突的处理方式)\n        /\n存储结构|\n        \\\n         ——拉链法(通过映射关系)\nHash主要作用 庞大的空间映射成一小块空间 0~N 10 9-10 5映射到 10 5 - 10 6\n\n1. 怎么写 x Mod  105属于 |0- 10 5\n2. 冲突怎么解决 不同数映射到同一个数里边\n离散化是最特殊的Hash\nHash期望算法时间近似O1 长度为常数\n\n*/\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nconst int N=200003,null=0x3f3f3f3f;//近乎无穷大 0x3f3f3f3f 就是109次方量级的 比109略大\n// 关于N 因为我们开了大概两到三倍的数据空间 一般都不会溢出 溢出的话 一般不会用hash来存储了\nint h[N];\n/*\n取成质数并且距离2非常远(因为这被证明冲突的概率会很小)\nfor(int i=100000;;i++){\n    bool flag=true;\n    for(int j=2;j*j&lt;=2;j++){\n        if(i%j==0){\n            flag=false;\n            break;\n        }\n    }\n    if(flag){\n        cout&lt;&lt;i&lt;&lt;endl;\n    }\n}\n*/\n\n/*\n开放寻址法 只开一个表 如果这一位有人了 就向下继续找 直到找到一个空白的位置 (哈希 主要是用来将离散化稀疏的数据\n映射到一个比较小的区间里) 查找 有人且为x说明找到了 删除 如果找到 就标记删除 方便以后恢复\n要求取模(模数)大小大于20万 且为最小的质数  200003\n\nfind函数X 如果存在就返回位置 如果不存在 就返回应该存储的位置\n\n约定标志 如果等于这个标志 就说明这个地方没有人 这个标志 只需要不再数据范围里边就可以了 约定0x3f3f3f3f为null\n\n*/\nint find(int x){\n    int k=(x%N+N)%N;\n    while(h[k]!=null&amp;&amp;h[k]!=x){// 如果h[k]有人了 并且这个数不是x 就继续找 一旦没人 k就是这个位置(因为先执行的k+)\n    \n        k++;\n        if(k==N) k=0;// 如果k=N 说明我们这个表格找到头了 此时k=0 说明继续从头开始找 先执行k++\n    }\n    return k;\n}\n\n\n\nint main(){\n    int n;\n    scanf(&quot;%d&quot;,&amp;n);\n\n    memset(h,0x3f,sizeof h);//这里h 是填充的内存块 一般是用来填充string的 但是数组也可以\n    // 用int值进行传递 但是填充的是该值的int形式 int 是32位的 0x3f 共8位 填充过一次就是0x3f3f3f3f\n    // 我们通常这样约定 将数组内部的所有数值初始化位为null\n\n    while(n--){\n        char op[2];\n        int x;\n        scanf(&quot;%s%d&quot;,op,&amp;x);\n        int k=find(x);\n        if(*op==&#39;I&#39;){\n            h[k]=x;//如果找到这个位置 k就是find找到的位置\n        }else{\n            if(h[k]!=null) puts(&quot;Yes&quot;);\n            else puts(&quot;No&quot;);\n        }\n    }\n\n    return 0;\n}\n</code></pre>\n<h4>Acwing 841. 字符串哈希</h4>\n<pre><code class=\"language-cpp\">Yes No Yes\n/*\n字符串 哈希 字符串前缀Hash h[0]=0 h[1]=&quot;A&quot; h[2]=&quot;AB&quot; h[3]=&quot;ABC&quot; h[4]=&quot;ABCD&quot; 共&quot;ABCD&quot;\n我们将这个ABCD 看成P(变量)进制的1234 =1*p3 +2*p2 +3*p1 +4*p0 转化成数字 发现实际上这个数值非常大\n我们要将这个数映射到一个比较小的数mod Q\n这样 就可以把任意一个字符串映射到从0-Q-1 的数字了\n注意要从不能映射成0 A=0(P)=0(10) AA=0(P)=0(10)  如果我们人品足够好 不存在冲突\n我们取得值P=131/13331 Q=2 64 这么取得话 99.99%不会发生冲突\n通过这种方式 配上前缀Hash 就可以算出来任意一段字串的Hash值 高位 L  R 低位\n这段字串的Hash H[R]-H[L-1] 的Hash值已经知道了 然后根据高低位 R是0位 第一位是R-1位\n在L-1位里边 L-1是第0位 第1位是L-2位 H[L-1] 向右平移 和H[R]对齐\nH[L-1]*p(r-l+1)  h[r]-h[l]*P(r-l+1) 这个公式 就是从l到r的hash值\n然后这个数字不是需要模上2 64次方Q吗? 实际上我们只需要使用unsigned long long存储所有H 就不需要取模了\n因为溢出就相当于取模了\n求H[i]也很简单 h[i]=h[i-1]*p+str[i]\n快速判断两个子串是否完全相同 算出来两个子串的Hash值 相同就认为字串是相同的\n*/\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nconst int N=100010,P=131;//13331\n\nint n,m;\nchar str[N];\n\nULL h[N],p[N];//先将p预处理出来\n\nULL get(int l,int r){\n    return h[r]-h[l-1]*p[r-l+1];//直接传入差值 就可以移动 (获取出来需要的数值 预处理的好处)\n    //申请空间 插入1000次 和一次插入1000个输入 可能差了1000倍 所以尽量直接初始化执行计算 之后O(1)就可以得到查询的数\n}\nint main(){ \n    scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,str+1);//一定记得从1开始 从1开始 方便计算 a[n]=a[n-1]+A[i] n-1有可能越界\n\n    p[0]=1;\n    for(int i=1;i&lt;=n;i++){\n        p[i]=p[i-1]*P;//这个是计算 P次方 差的数值是和i成比例的\n        h[i]=h[i-1]*P+str[i];//字符串的前缀数值\n        //p[i]和h[i-1]所乘数值保持一致 这样 都能同时模运算\n    }\n    while(m--)\n    {\n        int l1,r1,l2,r2;\n        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);\n\n        if(get(l1,r1)==get(l2,r2)){\n            puts(&quot;Yes&quot;);\n        }else puts(&quot;No&quot;);\n    }\n\n    return 0;\n\n}\n</code></pre>\n<hr>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-04-01-22：33：13（星期一）</em></span></p>\n"},{"id":3,"title":"Markdown补充","date":"2024-04-24","content":"<p><strong>md</strong></p>\n<p><a href=\"https://markdown.com.cn/\">Markdown官方教程-扩展教程</a></p>\n<p>md预览<code>ctrl+shift+v</code> 或者右键可以有预览选项(如果装过插件之后)</p>\n<h3>md特殊效果</h3>\n<p>高亮 <code>==高亮==</code>\n<del>删除线</del> <code>~~删除~~</code></p>\n<h3>代码块高亮</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">引例</th>\n<th align=\"right\">引例</th>\n<th align=\"center\">引例</th>\n<th align=\"center\">引例</th>\n<th align=\"center\">引例</th>\n<th align=\"center\">引例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">csharp</td>\n<td align=\"right\">python</td>\n<td align=\"center\">html</td>\n<td align=\"center\">java</td>\n<td align=\"center\">json</td>\n<td align=\"center\">c++</td>\n</tr>\n<tr>\n<td align=\"left\">cpp</td>\n<td align=\"right\">bash</td>\n<td align=\"center\">xml</td>\n<td align=\"center\">objectivec</td>\n<td align=\"center\">javascript</td>\n<td align=\"center\">vbnet</td>\n</tr>\n</tbody></table>\n<h3>补充</h3>\n<ul>\n<li>超链接</li>\n</ul>\n<p> <code>&lt;a href=&quot;UserManual.md&quot; title=&quot;系统使用说明书&quot;&gt;点击跳转使用说明书&lt;/a&gt;</code></p>\n<ul>\n<li>任务列表</li>\n</ul>\n<p><code>- [ ]</code> 任务列表写法</p>\n<p><code>-[x]</code> 已通过加上x</p>\n<ul>\n<li>使用emoji表情</li>\n</ul>\n<p><code>:tent:</code> UTF-8:这些以冒号开头和结尾，并包含表情符号的名称</p>\n<ul>\n<li>使用删除线</li>\n</ul>\n<p><code>~~</code> 前后两个波浪号</p>\n<ul>\n<li>表格和对齐</li>\n</ul>\n<pre><code>| Syntax      | Description | Test Text     |\n| :---        |    :----:   |          ---: |\n| Header      | Title       | Here&#39;s this   |\n| Paragraph   | Text        | And more      |\n</code></pre>\n<ul>\n<li>本地图片</li>\n</ul>\n<pre><code class=\"language-md\">![812打卡](../.img/812.jpg &quot;812打卡&quot;)//后边这个是悬浮文字提醒\n</code></pre>\n<hr>\n<h3>统计md字数</h3>\n<pre><code class=\"language-bash\">#!/bin/bash\n\n# 检查是否提供了文件名参数\nif [ $# -ne 1 ]; then\n    echo &quot;用法: $0 &lt;文件名&gt;&quot;\n    exit 1\nfi\n\n# 获取文件名参数\nfilename=&quot;$1&quot;\n\n# 检查文件是否存在\nif [ ! -f &quot;$filename&quot; ]; then\n    echo &quot;文件 &#39;$filename&#39; 不存在.&quot;\n    exit 1\nfi\n\n# 统计英文字符数量（假设只包括a-z和A-Z）\nenglish_count=$(cat &quot;$filename&quot; | tr -cd &#39;a-zA-Z&#39; | wc -m)\n\n# 统计中文字符数量（使用grep）\nchinese_count=$(cat &quot;$filename&quot; | grep -oP &quot;[\\x{4e00}-\\x{9fa5}]&quot; | wc -l)\n\n# 输出统计结果\necho &quot;文件 &#39;$filename&#39; 中的英文字符数量：$english_count&quot;\necho &quot;文件 &#39;$filename&#39; 中的中文字符数量：$chinese_count&quot;\n\nread -p &quot;按下回车键继续&quot;\n\n# 使用 ./char.sh name.md 查看所有字符\n</code></pre>\n<p>直接使用所有<code>*.md</code>文件</p>\n<pre><code class=\"language-bash\">find . -type f -name &quot;*.md&quot; -exec grep -oE &#39;[a-zA-Z]+&#39; {} + | tr -d &#39;\\n&#39; | wc -m\nfind . -type f -name &quot;*.md&quot; -exec grep -oE &#39;[\\u4e00-\\u9fff]+&#39; {} + | tr -d &#39;\\n&#39; | wc -m\n</code></pre>\n<hr>\n<p><strong>模板</strong></p>\n<p><strong>你好</strong></p>\n<p>欢迎浏览我的项目</p>\n<p>相关的一切都可以向我发送邮件来了解这个项目</p>\n<pre><code>2668933***\n</code></pre>\n<hr>\n<p>项目介绍</p>\n<p>系统需求说明书(SRS) 应该包含整个系统进行详细描述</p>\n<p>系统使用说明书 应该包含再系统需求数提出的具体需求 </p>\n<p>API文档用来详细指出整个项目使用的外源API</p>\n<hr>\n<p>hoho</p>\n<hr>\n<p>想说的话留言</p>\n<hr>\n<p>版权声明</p>\n<p>readme.md模板</p>\n<p><em>-02的Darling吖</em></p>\n"},{"id":4,"title":"MyKeyMap使用体验","date":"2024-04-24","content":"<p><a href=\"https://xianyukang.com/MyKeymap.html\">作者首页-咸鱼阿康</a></p>\n<p><a href=\"https://www.acwing.com/blog/content/34691/\">回退到导航分享页</a></p>\n<hr>\n<p><a href=\"https://glitch.com/edit\">editCode On android pad</a>\n<a href=\"https://jsbin.com/\">jsbin</a></p>\n<hr>\n<h2>Goal</h2>\n<ul>\n<li><p>算法</p>\n</li>\n<li><p>js/css工具链 vue/react源码刨析 tailwild postcss\n<a href=\"https://juejin.cn/post/6844904086874095623\">工具链</a>\n<a href=\"https://www.youtube.com/watch?v=DNS1H9xGGhE\">How To use toolChain</a>\n<a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Introducing_complete_toolchain\">介绍完整的工具链</a></p>\n</li>\n<li><p>docker的跨平台开发</p>\n</li>\n<li><p>AIGC \n机器学习 线性回归 逻辑回归 决策树 随机森林\n神经网络 卷积神经玩咯 循环神经网络\n<a href=\"https://console.bce.baidu.com/easydl/scene\">模型APi调用</a>\n<a href=\"https://aistudio.baidu.com/course/list/1/1\">课程AiStudio</a></p>\n</li>\n</ul>\n<pre><code class=\"language-js\">李沐，手把手教你深度学习\n吴恩达，Deeplearning\njeremy howard，fastai\nmichael collins，NLP\n学完这些你可以回头去教别人了。这些真正大神的课程全！部！不！收！费！\n</code></pre>\n<ul>\n<li>博客抄袭</li>\n</ul>\n<p><a href=\"https://www.freecodecamp.org/chinese/learn/2022/responsive-web-design/learn-css-flexbox-by-building-a-photo-gallery/step-2\">Online css CampFree</a></p>\n<hr>\n<p><strong>md使用组合键</strong></p>\n<pre><code>ctrl+b 加粗  fg 分割线(-------) \nctrl+i 斜体 lj 输入链接 可以事先选中\nmbg 生成表格(3) \nfmd 打开正在专注的md文件夹\nfut 打开unityBuild文件夹\nbi 加粗斜体 it 斜体\ngl 高亮选中\n</code></pre>\n<p><strong>md符号输入</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">输入</th>\n<th align=\"right\">名称</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">xk</td>\n<td align=\"right\">小括号</td>\n<td align=\"center\">()</td>\n</tr>\n<tr>\n<td align=\"left\">dk</td>\n<td align=\"right\">大括号</td>\n<td align=\"center\">[]</td>\n</tr>\n<tr>\n<td align=\"left\">zk</td>\n<td align=\"right\">中括号</td>\n<td align=\"center\"><code>{}</code></td>\n</tr>\n<tr>\n<td align=\"left\">mh</td>\n<td align=\"right\">冒号</td>\n<td align=\"center\">``</td>\n</tr>\n<tr>\n<td align=\"left\">ss</td>\n<td align=\"right\">双引号</td>\n<td align=\"center\">&quot;&quot;</td>\n</tr>\n<tr>\n<td align=\"left\">fg</td>\n<td align=\"right\">分割线</td>\n<td align=\"center\"><code>-----</code></td>\n</tr>\n</tbody></table>\n<hr>\n<p>新机器更改</p>\n<ol>\n<li>dm 默认是Csharp代码</li>\n</ol>\n<hr>\n<p>md关于VScode的快捷键开发</p>\n<ol>\n<li>选中文本斜体</li>\n</ol>\n<pre><code>^c\n{Del} //上个忘记删除了 可以换成BS\n{text} __   这里是前后有空格的\n{Left 2}多一个空格和_ 需要移动两个\n^v\n</code></pre>\n<hr>\n<p><strong>输入组合键</strong></p>\n<p>在<code>要输入的按键活文本</code>中配置组合键</p>\n<p>其中 # 表示 Win 键<code>{left}</code> 表示左方向键,  另外键盘左下角的四个键都有对应的特殊符号:</p>\n<p><code>^</code> 表示 Ctrl 键\n<code>#</code> 表示 Win 键\n<code>!</code> 表示 Alt 键\n<code>+</code> 表示 Shift 键</p>\n<h4>copy</h4>\n<pre><code>c:\\Windows\\explorer.exe\n</code></pre>\n<p><code>{selected_text}</code>选中的文本 (<em>针对于跳转网址</em>)</p>\n<p><strong>功能键映射到功能键</strong></p>\n<p><code>RALt::RCTRL</code> 如果想把右 Alt 重映射为左 Ctrl 键</p>\n<h3>az命名规则</h3>\n<p>单击分号 &#39;:&#39;状态下</p>\n<pre><code>t dh--&gt;text+电话\n</code></pre>\n<p>c命令下 <code>caps</code></p>\n<pre><code>空格在前 ` `+qq 启动qq\n空格在后 fy+` ` 跳转到网站翻译\n空格在中间 d+&#39; &#39;+q 打开常用文件夹qqfileRec\n</code></pre>\n<p><strong>Cpas模式</strong>\n<img src=\"https://cdn.acwing.com/media/article/image/2023/07/01/168875_7e0b8eb717-Caps.png\" alt=\"Caps.png\"> </p>\n<p><strong>Cpas+F</strong>\n<img src=\"https://cdn.acwing.com/media/article/image/2023/07/01/168875_8e0a467e17-Caps+F.png\" alt=\"Caps+F.png\"> </p>\n<p><strong>J模式</strong>\n<img src=\"https://cdn.acwing.com/media/article/image/2023/07/01/168875_9afa0faa17-J%E6%A8%A1%E5%BC%8F.png\" alt=\"J模式.png\"> </p>\n<p><strong>分号模式</strong>\n<img src=\"https://cdn.acwing.com/media/article/image/2023/07/01/168875_a4e2421517-%E5%88%86%E5%8F%B7%E6%A8%A1%E5%BC%8F.png\" alt=\"分号模式.png\"> </p>\n<p><code>c命令</code> 查看自己配置的键位 需要自己添加备注</p>\n<p>mac有<code>raycast</code> windows有<code>wox</code> 不过还是被小众的<code>MyKeyMap</code>吸引</p>\n<p>有一个明显的好处是 别人用你的电脑带有一定的难度</p>\n<h2>简介</h2>\n<p>MyKeymap 是 Windows 下的一款按键映射 / 快捷键增强工具</p>\n<ol>\n<li>对于普通用户 (1)能利用 caps 命令以一种新颖的方式启动程序\n(2)能利用 caps + f 召唤窗口，解决高频的窗口切换\n(3)还能从 MyKeymap 预设的系统控制，窗口操作中获得一些便利</li>\n<li>对于文字编辑、整理笔记较多的人，J 模式的「 光标控制 」和「 文字选择 」能帮你提高生产力</li>\n<li>对于程序员，除了能享受上述的所有便利，还可以看看「符号输入」和「数字输入」两个功能</li>\n<li>对于我，MyKeymap 最开始是个人日常使用的一套键位映射，它能提高我的操作效率，优化输入体验。\n因为我觉得好用，说不定对其他人也有用，如果能写出一个有用or有帮助的软件，又有何不可呢? 🐶 所以做成了一个软件。</li>\n</ol>\n<p><strong>启动/使用场景</strong></p>\n<p>配置 <code>caps</code>+<code>se</code> 打开设置页 启动开机自启动</p>\n<ol>\n<li><p>全部场景 <code>caps命令</code>+<code>help</code> 查看所有的已经配置完成的命令</p>\n</li>\n<li><p>游戏场景关闭映射 右键关闭/<code>shift</code>+<code>alt</code>+<code>&#39;</code>暂停keymap</p>\n</li>\n</ol>\n<h3>通用场景快速入手</h3>\n<h5>鼠标相关</h5>\n<table>\n<thead>\n<tr>\n<th>鼠标按键</th>\n<th>功能</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>右键+左键</td>\n<td>打开窗口管理器</td>\n<td>用鼠标中键可以关闭窗口</td>\n</tr>\n<tr>\n<td>右键+滚轮滑动</td>\n<td>Ctrl+Tab、Ctrl+Shift+Tab</td>\n<td>比如在浏览器中切换标签，很好用的功能</td>\n</tr>\n</tbody></table>\n<h5>键盘相关</h5>\n<p>须知 主键<code>capslock</code>用来操作keymap </p>\n<p>单击一次激活<strong>caps命令</strong>面板 此状态<code>单击一次</code>/<code>ESC</code>/<code>BackSpace</code>都可以退出这个状态</p>\n<p>配置 <code>caps</code>+<code>se</code> 打开设置页</p>\n<ol>\n<li>caps命令 输入 <code>gj</code> 用来关机</li>\n<li>caps+F  <code>caps+F</code>-&gt;<code>仅松开caps</code>-&gt;<code>按下某件F</code> 启动某软件 比直接输入命令更加快捷</li>\n<li>分号模式 用来映射<code>常用的符号</code>以及<code>表情</code> 不需要按住shift解放双手</li>\n<li>J模式 文本编辑 用来映射<strong>组合键</strong>+<strong>光标移动文本</strong>+<strong>Doc文本样式</strong></li>\n<li>3模式 数字和功能键 用来<strong>输入数字</strong> 和 <strong>功能键</strong></li>\n<li><code>Caps+C</code> 激活音量调节面板</li>\n<li>缩写模式 单击分号 输入文本</li>\n<li></li>\n</ol>\n<hr>\n<h3>个人配置</h3>\n<p>副屏*2 :菲亚特科技 Tb 15 Hdmi/Ips 畅销款 264/14 224</p>\n<p><strong>鼠标</strong>:</p>\n<p>达尔优A950 糖果粉 150 </p>\n<p>鼠标配置:</p>\n<p>DPILoop</p>\n<p>400 800 1200 </p>\n<p>1000HZ回报率 1mmLod高度 鼠标移动速度10 滚动速度3</p>\n<p> <em>csgo</em>  鼠标倍率1.2  狙击镜1.0 打开原始数据输入</p>\n<p><strong>键盘</strong> </p>\n<p>模具:黑吉蛇Dk100 228\n轴体:捕获者长春蓝客制化DIY110颗罐装 68\n键帽:史努比PBT热升华键帽 68\n  近月少女的礼仪露娜PBT热升华键帽定制 188</p>\n<p><strong>耳机</strong></p>\n<p>漫游者W800Plus 200\n倍思e3 99</p>\n<p><strong>生活</strong>\n以后也会在生活物品上选择固定的物品</p>\n<p>沐浴露:\n洗发露:\n卫生纸:真心柔 18卷 16.5cm长度 24\n喝水杯: pdd陶瓷水杯 加油干\n围裙: pdd干饭人围裙</p>\n<pre><code class=\"language-json\">settings.json on vscode\n{\n    &quot;editor.formatOnSave&quot;: true, //保存格式化代码\n    &quot;explorer.confirmDelete&quot;: false, //删除代码时进入废纸篓是否确认\n    &quot;security.workspace.trust.untrustedFiles&quot;: &quot;open&quot;,\n    &quot;workbench.colorTheme&quot;: &quot;Bluloco Light&quot;, //ctrl+N 新保存文件为Utitle-1 hidder\n    &quot;editor.unicodeHighlight.nonBasicASCII&quot;: false,\n    &quot;explorer.compactFolders&quot;: false, //紧凑文件树结构\n    &quot;javascript.updateImportsOnFileMove.enabled&quot;: &quot;always&quot;, //启用移动文件时自动更新导入路径的功能\n    &quot;files.autoSave&quot;: &quot;onFocusChange&quot;,\n    &quot;Codegeex.Privacy&quot;: true,\n    &quot;editor.minimap.enabled&quot;: false, //不显示缩略图\n    &quot;workbench.layoutControl.enabled&quot;: false,\n    &quot;workbench.sideBar.location&quot;: &quot;right&quot;, //在侧栏默认位置右边\n    &quot;window.menuBarVisibility&quot;: &quot;compact&quot;, //菜单(第一个File/Edit)在侧栏为紧凑模式\n    &quot;markdown-preview-enhanced.revealjsTheme&quot;: &quot;black.css&quot;, //\n    &quot;workbench.settings.editor&quot;: &quot;json&quot;, //配置默认使用的设计编辑器\n    &quot;editor.snippetSuggestions&quot;: &quot;top&quot;,\n    //11 25  autoRenameTag BlulocoDarkTheme BlulocoLight Theme\n    //Live Server MarkdownPreviewEnhancesed MarkdownShortCutkp\n    // BrowseLite Eslint \n    &quot;[markdown]&quot;: {\n        &quot;editor.wordBasedSuggestions&quot;: false,\n        &quot;editor.parameterHints.enabled&quot;: true,\n        &quot;editor.quickSuggestionsDelay&quot;: 10,\n        &quot;editor.quickSuggestions&quot;: {\n            &quot;other&quot;: true,\n            &quot;comments&quot;: false,\n            &quot;strings&quot;: false\n        },\n    },\n    &quot;workbench.editor.empty.hint&quot;: &quot;hidden&quot;,\n    &quot;window.commandCenter&quot;: false,\n    &quot;git.confirmSync&quot;: true,\n    &quot;prettier.semi&quot;: false,\n    \n    \n}\n// @category:&quot;snippets&quot; 搜索预设\n//markdown.json user preset code snippets\n//关于 Visual Studio Code 中可以在用户代码片段中使用的变量，有一些内置的特殊变量。\n//这些变量以`${}`的形式嵌入到代码片段中，\n//用于在代码插入时自动替换为相应的值。以下是一些常见的内置变量：\n//`${1|one,two,three|}`\n// 1. `${CURRENT_YEAR}`: 当前年份（4 位数）。\n// 2. `${CURRENT_YEAR_SHORT}`: 当前年份的最后两位数。\n// 3. `${CURRENT_MONTH}`: 当前月份（两位数，01-12）。\n// 4. `${CURRENT_DATE}`: 当前日期（两位数，01-31）。\n// 5. `${CURRENT_HOUR}`: 当前小时（两位数，00-23）。\n// 6. `${CURRENT_MINUTE}`: 当前分钟（两位数，00-59）。\n// 7. `${CURRENT_SECOND}`: 当前秒数（两位数，00-59）。\n// 8. `${TM_FILENAME}`: 当前文件名。\n// 9. `${TM_FILENAME_BASE}`: 当前文件名（不包含扩展名）。\n// 关于这些变量的详细信息，你可以参考 Visual Studio Code 的官方文档。在文档中，\n// 搜索 &quot;snippets&quot; 或 &quot;user snippets&quot; 可能会导向相关的信息。请注意，\n// 除了上述内置变量外，你还可以在代码片段中使用 JavaScript 表达式\n// 你可以使用 `${1|one,two,three|}` 来提供一个选项列表供选择。\n// {\n//   &quot;For Loop&quot;: {\n//     &quot;prefix&quot;: [&quot;for&quot;, &quot;for-const&quot;],\n//     &quot;body&quot;: [&quot;for (const ${2:element} of ${1:array}) {&quot;, &quot;\\t$0&quot;, &quot;}&quot;],\n//     &quot;description&quot;: &quot;A for loop.&quot;\n//   }\n// }\n// ==》\n// for (const element of array) {\n// }\n// &quot;For Loop &quot;是代码段名称。如果没有提供说明，则通过 IntelliSense 显示。\n// 前缀定义一个或多个触发词，用于在 IntelliSense 中显示片段。\n// 子串匹配在前缀上执行，因此在本例中，&quot;fc &quot;可以匹配 &quot;for-const&quot;。\n// body 是一行或多行内容，插入时将作为多行连接。\n// 换行符和嵌入的制表符将根据插入片段的上下文进行格式化。\n// description 是 IntelliSense 显示的片段的可选描述。\n// 此外，上述示例的正文中有三个占位符（按遍历顺序排列）：\n// 您可以使用 Tab 键快速跳转到下一个占位符，此时您可以编辑占位符或跳转到下一个占位符。\n// 冒号 : 后面的字符串（如果有）是默认文本，\n// 例如 ${2:element} 中的 element。占位符的遍历顺序是按数字升序排列，\n// 从 1 开始；0 是一种可选的特殊情况，\n// 总是排在最后，并在光标位于指定位置时退出代码段模式。\n//更对内容的配置 https://code.visualstudio.com/docs/editor/userdefinedsnippets\n</code></pre>\n<p>vscode插件</p>\n<pre><code class=\"language-js\">BrowseLite\nBluloco Light Theme\nMarkdownPreview\nMarkdownShortCut\nPretter\nSimpleReactSnippets\n`Auto Import - ES6, TS, JSX, T`\n`Quokka.js 显示js开发时/省去consoleLog`\n`Simple React Snippets`\n`Bookmarks`书签\n`Github Repositories`远程 git 代码查看\n`https://www.drawio.com/`画图(uml)图很方便\n</code></pre>\n"},{"id":5,"title":"Re从零开始的Docker生活","date":"2024-04-24","content":"<p>快要疯掉了\n调试了6个小时 终于 发现docker没有开放443端口</p>\n<hr>\n<p>补充指示点 </p>\n<p><code>netstat -tunlp</code> 查看服务器所有的端口</p>\n<p>如果连接不上 直接使用<code>ip地址</code>查看</p>\n<p>80端口在<code>nginx</code>里 被自动重定向为443</p>\n<pre><code>server {\n    # 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块\n    listen       443 ssl;\n    # 域名，多个以空格分开\n    server_name  hack520.com www.hack520.com;\n    \n    # ssl证书地址\n    ssl_certificate     /usr/local/nginx/cert/ssl.pem;  # pem文件的路径\n    ssl_certificate_key  /usr/local/nginx/cert/ssl.key; # key文件的路径\n    \n    # ssl验证相关配置\n    ssl_session_timeout  5m;    #缓存有效期\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议\n    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法\n\n    location / {\n        root   html;\n        index  index.html index.htm;\n    }\n}\n</code></pre>\n<p>网站主要开销 服务器/域名</p>\n<p>域名需要证书做dns映射?好像把</p>\n<p>listen 监听 只有被监听才能够做出回应 </p>\n<hr>\n<p>新建Docker</p>\n<pre><code>docker run -p 20000:22 -p 443:443 -p 80:80 -p 3000:3000 -p 3001:3001 -p 3002:3002 -itd --name kob_server0 django_lesson:1.0\n\ndocker ps -a\ndocker start Name\n看好了 这都有\n0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp, 0.0.0.0:3000-3002-&gt;3000-3002/tcp, :::3000-3002-&gt;3000-3002/tcp, 8000/tcp, 0.0.0.0:20000-&gt;22/tcp, :::20000-&gt;22/tcp\n</code></pre>\n<p>新建用户</p>\n<pre><code>adduser acs   /-Y\nusermod -aG sudo acs\nctrl p+ctrl q// 不要ctrl d 就把容器关了\n</code></pre>\n<p>配置容器(AcTerminal)免密登录</p>\n<pre><code>vim .ssh/config\n配置别名\n//这里避免重复改一下名字\nssh-copy-id springboot_server\nyes 密码\n\nTerminal别名 springboot\n</code></pre>\n<p>发送祖传文件(这里本来就有tmux/Django的镜像)</p>\n<pre><code>AcTerminal \n\nscp .bashrc .vimrc .tmux.conf springboot_server:\n</code></pre>\n<p>在tmux里安装</p>\n<pre><code>mysql\n\nsudo apt-get update\nsudo apt-get install mysql-server\nsudo service mysql start\n输入 top  查看所有进程 \n如果看到mysqld-safe 和mysqld 就成功了\n直接输入q/ctrl+c就可以退出top指令\n登录mysql\nsudo mysql -u root\nALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH caching_sha2_password BY &#39;123456&#39;;\n链接\nsudo mysql -u root -p\n输入密码\n\n\njava8\n\nsudo apt-get update\nsudo apt-get install openjdk-8-jdk\nY\njava -version 查看版本 1.8*就安装成功了\n\n</code></pre>\n<p>配置本地免密登录</p>\n<pre><code>ssh-copy-id springboot//这里竟然直解成功了\n</code></pre>\n<p>上传jar文件</p>\n<pre><code>gitbashHere \nscp backend-0.0.1-SNAPSHOT.jar springboot:\n共三个\n</code></pre>\n<p>云端新建项目文件夹</p>\n<pre><code>$ mkdir kob     $cd kob\nmkdir backendcloud\nmkdir web\nmkdir acapp\ncd backendcloud\ncp ~/*.jar .\n启动三个分屏 ctrl+a &quot;\n第一个分屏 \njava -jar back (3000服务)\njava -jar mat  (3001)\njava -jar botr\n</code></pre>\n<p>配置nginx</p>\n<pre><code>acapp.key\nacapp.pem\nspringboot.conf\ncd /etc/nginx/\nsudo mkdir cert\n密码\ncd cert\nsudo vim /acapp.key/acapp.pem/\n:set paste    $   i\nshift+ins  esc   :wq\n\ncd ..\nsudo vim nginx.conf\nggdG\n复制去\n</code></pre>\n<p>启动nginx</p>\n<pre><code>sudo /etc/init.d/nginx start\n如果失败 cd /var/log/nginx/\n使用 sudo cat error.log 查看错误信息\n</code></pre>\n<hr>\n<p>内部文件运行\n映射端口不再尝试\n这里权当练手了\n亦或者惩罚 咯</p>\n<hr>\n<p>原话</p>\n<p><code>docker run -p 20000:22 -p 443:443 -p 80:80 -p 3000:3000 -p 3001:3001 -p 3002:3002 -itd --name kob_server django_lesson:1.0</code></p>\n<p><code>docker commit kob_server kob_images</code> 把这个容器改成镜像\n<code>docker run -p 20000:22 -p 443:443 -p 80:80 -p 3000:3000 -p 3001:3001 -p 3002:3002 -itd --name Rekobserver kob_images </code>重新指定端口</p>\n<p>这里实现之后 发现什么都没有了</p>\n<hr>\n<p>解决方案</p>\n<p>1 完全re</p>\n<p>2 试一试镜像再开放端口</p>\n<hr>\n<p><strong>事故经过</strong></p>\n<p>然后我去搜</p>\n<ul>\n<li><p><code>为什么轻量级服务器控制台防火墙放通了端口依旧无法访问？</code></p>\n</li>\n<li><p><code>dns通过但是拒绝连接</code></p>\n</li>\n</ul>\n<p>等等各种乱七八糟的东西 </p>\n<p>我试了试 不断重复 增加删除再粘贴的情况 再粘贴的无数次 然后再ping 改变防火墙规则 用其他设备连接网站</p>\n<p>就快要挣扎放弃的时候 直到  我想要自己买域名 然后注册 才开始发现  dns解析</p>\n<p>通过这个方法 发现始终443端口不通 80端口是可以开放关闭的(通过防火墙)</p>\n<p>我又去查看服务器上的docker 是否开放映射端口 看着眼花缭乱 却没发现443没有开放</p>\n<p>然后我去评论区复制了原话 新建了一个docker 发现真的少了一个映射端口 终于!  </p>\n<p>我常说好事多磨</p>\n<p>我再这里泡了六个小时 希望可以弥补自己的粗心 </p>\n<p>华为云:<a href=\"https://www.huaweicloud.com/whois/sitedetect.html?domain=app2676.acapp.acwing.com.cn\">调试网站端口与映射Dns</a></p>\n<hr>\n<p>表头</p>\n<p><a href=\"https://www.acwing.com/blog/content/30883/\">本讲义上一节:Linux-8(针对sp-9)</a></p>\n<p>Idea操 作 指 南:<a href=\"https://www.acwing.com/blog/content/25456/\">https://www.acwing.com/blog/content/25456/</a></p>\n<p>每次都要点击的网址:<a href=\"https://www.acwing.com/blog/content/28250/\">https://www.acwing.com/blog/content/28250/</a></p>\n<p>G i t B a s h : <a href=\"https://www.acwing.com/blog/content/22768/\">https://www.acwing.com/blog/content/22768/</a></p>\n<p>WindowsIdea :<a href=\"https://www.acwing.com/blog/content/23868/\">https://www.acwing.com/blog/content/23868/</a></p>\n<p>本节课讲义<a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/6481274/\">https://www.acwing.com/file_system/file/content/whole/index/content/6481274/</a></p>\n<p>Linux讲义:<a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/2855530/\">https://www.acwing.com/file_system/file/content/whole/index/content/2855530/</a></p>\n<p>Linux基础课面板<a href=\"https://www.acwing.com/activity/content/57/\">https://www.acwing.com/activity/content/57/</a></p>\n"},{"id":6,"title":"u3d_7_1游戏逻辑","date":"2024-04-24","content":"<p><em>好了,今天就到这里吧,咱们再见了 拜拜</em> </p>\n<p><strong>温馨提示</strong> : 本篇过长 请勿点击<code>展开</code></p>\n<hr>\n<p><a href=\"https://www.acwing.com/blog/content/34691/\">回退到导航分享页</a></p>\n<p><a href=\"https://www.acwing.com/blog/content/24867/\">发癫系列-&gt;个人主页说明</a>   </p>\n<p><a href=\"https://www.acwing.com/blog/content/36441/\">动态-&gt;发癫日记</a></p>\n<hr>\n<h3>整理文件</h3>\n<p><code>ThirdParty</code> 收集第三方包 <strong>!</strong> <code>Script</code>收集所有代码 <strong>!</strong> <code>Player</code>收集所有Player相关的代码\n<strong>按住Ctrl</strong>可以多选 <strong>拖动</strong>可以移动 <strong>右键</strong>进行创建 会自动更改相对位置</p>\n<p><strong>代码打卡</strong></p>\n<p><code>PlayerInput.cs</code></p>\n<p><code>\\``` 代码块 \\```</code></p>\n<h3>导出文件</h3>\n<p>Edit-&gt;BuildSetting-&gt;可以在很多平台上行发布  也可以发布成web段 <code>playerSettings</code>\n窗口化 不让切换全屏 buildAndRun 新建文件夹Build 来存放所有版本</p>\n<p>如果发布android需要安装一些东西 发布webGl需要切换平台 </p>\n<p>每次切换发布平台都需要点击一下<code>switchPlatForm</code></p>\n<p><strong>刚体</strong>也是移动transfrom 不过刚体是封装好的类 也是一段代码 和我们写的东西一样的 </p>\n<p><strong>碰撞</strong>是自带的 应为Player上边有个组件叫做 Collider 地板上也有个Collider</p>\n<h4>发现鼠标总是动</h4>\n<p>可以在这里锁住鼠标 (可以esc退出鼠标)</p>\n<p><code>Cursor.lockstateCursor.lockState = CursorLockMode.Locked;</code>写在input的start函数内部 当游戏开始的时候锁住\n这里两个代码脚本 应该是按照顺序就可以 先出现的脚本优先级最高吧 </p>\n<h4>发现上下相反</h4>\n<p>应该仅<strong>仅对x方向</strong>进行取反 xrotate就可以了</p>\n<h3>实现旋转</h3>\n<p>加的计算量越少越好 计算量越少 速度越好 现在游戏很少 加不加优化区别不大 实现旋转的函数 有一个四元数 这里太复杂不讲(MoveRotation)</p>\n<pre><code class=\"language-csharp\">if (yRotation != Vector3.zero)\n        {\n            rb.transform.Rotate(yRotation);\n        }\n</code></pre>\n<h3>旋转注意</h3>\n<p>角色移动可以使用characterController 这里使用刚体是用来更好的理解移动是如何来实现的 实现某个功能的时候 应该想他是再物理世界里如何操作的  </p>\n<pre><code>private Vector3 yRotation=Vector3.zero;//这里是旋转的角色\nprivate Vector3 xRotation=Vector3.zero;//这里旋转的是相机//所有Unity内部的变量都应该是三维的 向量 \n</code></pre>\n<p>还要引入相机 (注意引入 需要[SerializeField]以后不再赘述) 不要起名字为Camera 这个变量名已经被其他包用过了 所以要用cam的名称 这次拖动的不再是右侧的Inspector了 \n而是左侧的Hierarchy的了 直接拖过去就可以了 </p>\n<p>保存过之后立即赋值 <strong>ctrl+s</strong> 并跳转unity</p>\n<h2>旋转</h2>\n<p>相对于主观来讲 x轴移动的是Unity对应的y轴方向 鼠标输入也有一个速度的概念 叫做鼠标灵敏度 这个可以调 所以需要加上</p>\n<p><code>[SerializeField] private float lookSensitivity = 8f;</code></p>\n<p><strong>注意</strong> 水平方向上转的是Player 竖直方向上转的是Camera </p>\n<p><code>Vector3 yRotation = new Vector3(0f, xMouse, 0f)*lookSensitivity;</code></p>\n<p>这里<strong>0f</strong>表示浮点数的0 和int区分开 而且只需要对转一次 yRatation实际上是算出来unity内部需要旋转的y度数 这个是player </p>\n<p>然后需要再PlayerController里面去实现旋转 操作一下旋转 这里两个旋转是不能合并的 因为不是同一个物体 <strong>左右旋转角色</strong> <strong>上下旋转的是camera</strong> </p>\n<h3>调试</h3>\n<p>想要获取某个输入但是不知道名字 可以点击Edit-&gt;ProjectSettings-&gt;InputManager\n查看所有输入 </p>\n<p>可以看见<strong>MouseX</strong>和<strong>MouseY</strong>也是每一帧移动的距离</p>\n<p><code>Input.GetAxisRaw</code>一定是这个选项 如果没有Raw则是优化过的值 这个Raw是原始的值 没有Raw更平滑一些 </p>\n<pre><code>float xMouse = Input.GetAxisRaw(&quot;Mouse X&quot;);\nprint(xMouse.ToString()+&quot; &quot;+yMouse.ToString());\n</code></pre>\n<p>ctrl+s保存 如果不保存不会生效 Unity保存后会有加载框 点击运行之后 点击Console就可以显示输出的东西 </p>\n<h3>游戏运行</h3>\n<p>运行起来发现 speed无论怎么变都是不会改变的 原来是代码中没有乘以speed 现在的 velocity只是一个方向向量 </p>\n<p>每次运行起来 还不会保存 调试的时候 <strong>不会保存调试的数据</strong></p>\n<p>每次启动程序 Unity对上次启动的Rider编辑器<strong>不会保存偏好设置</strong> 需要再次更新</p>\n<pre><code>    public void Move(Vector3 _velocity)//这个是每秒钟移动多少距离的速度\n    {\n        velocity = _velocity;\n    }\n\n    private void PerformMovement()\n    {\n        if (velocity != Vector3.zero)\n        {\n            rb.MovePosition(rb.position+velocity*Time.fixedDeltaTime);\n        }\n    } \n\n    private void FixedUpdate()//用来操纵移动的次数\n    {\n        PerformMovement();//个人感觉是 在一个update时间里 fixedupdate执行此时更多 时间更少 \n    }\n</code></pre>\n<h3>导入</h3>\n<p>需要在代码中定义 然后再Unity中引入 把东西拖过来 需要做的前提是 加上注解\n<code>[SerializeField]</code> 无论是导入刚体还是其他代码块 都需要这样做</p>\n<pre><code>[SerializeField]\n// Start is called before the first frame update\nprivate float speed = 5f;\n[SerializeField]\nprivate PlayerController controller;//然后需要在Unity把PlayerController拖过来\nvoid Update()\n    {\n        float xMov = Input.GetAxisRaw(&quot;Horizontal&quot;);\n        float yMov = Input.GetAxisRaw(&quot;Vertical&quot;);\n        Vector3 velocity = (transform.right * xMov + transform.forward * yMov).normalized;\n        controller.Move(velocity*speed);//这里只需要传入速度就可以了 \n\n    }\n</code></pre>\n<h3>移动</h3>\n<p><strong>xt=xt-1+v*t</strong> t表示时间间隔 拥有一个库函数 <code>Time.fixedDeltaTime</code>\n所以下一帧的位置为 <code>rb.MovePosition(rb.position+velocity*Time.fixedDeltaTime);</code></p>\n<p><code>Time.DeltaTime</code>表示的是距离上次的Update的时间间隔 </p>\n<p>控制的逻辑非常重要 例如 <strong>PerformMovement()</strong> 这个函数一秒钟会被调用50次\n如果优化这个函数 整体看起来优化的效果十分明显 每秒钟会优化50次运算 </p>\n<h3>控制移动</h3>\n<p>例如判断游戏结束 和 获取用户输入都可以用<code>update</code> 感觉有点像掉帧 update的次数一般是30 60次数 <strong>Fixupdate</strong>固定的50次</p>\n<p>所以获取用户的输入 可以用<code>update</code> 在计算机方便的时候获取就可以了\n要模拟真实的物理轨迹 可以用<code>fixUpdate</code></p>\n<h3>U3d内部调试</h3>\n<p>在<code>Start</code>和<code>Update</code>前面有一片区域 添加注解<code>[SerializeField]</code>可以将这区域内部的变量和方便的<strong>作为一个面板来显示出来</strong> 这个面板的属性可以改变 并且同时赋值的话<strong>以面板为准 而不是代码为准</strong></p>\n<h3>将速度真实的运用在Player</h3>\n<p>在<code>PlayerController</code>内部实现</p>\n<p>这里处理逻辑 可以将<code>Start</code>和<code>Update</code><strong>删除</strong></p>\n<p><em>input</em> 仅仅只是用来处理输入 如果要真实的运用到物体的属性 可以定义变量 刚体 <code>private RigidBody rb</code> 如果要在Unity里边可以调试它的值可以加上注解 <code>SerialzeField </code></p>\n<p>如果想要rb获取本身的刚体 可以将Player的Rigidbody拖动到rb上边(这里内部处理 在Unity界面才可以看到它的属性值)</p>\n<p><strong>定义速度</strong> 是一个三维变量 <code>private Vector3 velocity=vector3.zero</code> 定义辅助函数接收外部传来的速度</p>\n<pre><code>public void Move(Vector3 _velocity)\n    {\n        velocity = _velocity;\n    }\n</code></pre>\n<p>如果要作用于刚体(rigidbody)的话 需要将update更换为FixUpdate 这个函数是模拟真实的物理过程的 </p>\n<p> <strong><em>fix和update区别</em></strong> </p>\n<p>update是不均匀执行的 如果上次计算量比较大 update第一次执行时间较长 后边可能缺失时间紧凑 但fixUpdate每次会严格的执行按照每次时间间隔来执行 后者可以更好的模拟物理轨迹 可以在 <code>edit-&gt;projectSetting-&gt;Time</code>来规定每次时间间隔 直线两者几乎无区别 </p>\n<hr>\n<h3>C#游戏</h3>\n<p>注意到所有的在Unity创建的C#脚本 都继承自一个重要的基类 <code>: MonoBehaviour</code>\n这个记过即可</p>\n<p>打开的代码包括两个函数</p>\n<p>start 和 update 是和之前的课完全一样的  每个物体在被加入世界的时候 初始化一次 \nupdate是 每画一帧的位置 可以放到update里边去计算 用户输入也可以在update里边</p>\n<p>获取前后左右 <code>float xMov=Input.GetAxisRaw(&quot;Horizontal&quot;)</code></p>\n<p>这个Horizontal 是和Unity里边的 edit-&gt;projectsetting-&gt;InputManager-&gt;Axes的Horizontal下的属性名称(Name)是一样的 每一帧都是需要获取到用户的输入\n看他有没有按着这个键 如果是d被按着获取到的是1 如果为a获取到的是-1 如果用户松开了 则表示不移动 </p>\n<h3>平面内的向量速度计算</h3>\n<p>因为是平面内的</p>\n<p>所以移动是一个向量 涉及到了向量的运算 </p>\n<p>定义变量<code>Vector3  velocity=(transform)</code>这个 <code>transform</code> 是和这个代码绑定的变量Player上面的 所以是Player的 transform 表示的是初始化的朝右的正方向 </p>\n<p><code>Vector3 velocity = (transform.right * xMov + transform.forward * yMov).normalized;</code>\n这里想要通过 wasd 键表示每个方向的速度都是均匀的为1 可以方便调试 需要将得到的变量标准化 </p>\n<p>transfrom.right 表示现在身体的右边 乘以速度xMov 按住为1 表示向右的速度 与 y方向上的速度相加可以得到最终速度</p>\n<hr>\n<p><strong>移动的逻辑</strong></p>\n<p>每秒钟快速展示六十张图 游戏移动其实是<code>计算一下每一帧它的位置是什么</code> 所以就要告诉unity每一帧的位置 然后每个物体的坐标是什么 </p>\n<ol>\n<li><p>为Player添加 <strong>rigidbody刚体</strong> 组件\n它拥有重力属性  <em>gravity</em>  现在脑袋不需要重力 可以先把它勾掉 </p>\n</li>\n<li><p>为Player添加 newScript组件\n为它添加逻辑代码 你可以输入 <code>new script</code> 然后起一个名称\n或者直接输入名称 自动选择<code>new script</code> 脚本</p>\n</li>\n</ol>\n<p><strong>打开代码之前</strong> \n查看<code>edit</code>-&gt;<code>perference</code> 打开偏好设置 选择 <code>extennalTools</code>\n选择成你自己的代码编辑器 选中之后才能够支持自动补全 </p>\n<p><strong>打开代码</strong></p>\n<p>双击右侧的Player 打开它的 Inspector 找到刚才的脚本 双击它的名字就可以打开了 </p>\n<hr>\n<h3>角色移动</h3>\n<p>是上下左右四个方向 向上看<strong>只是头部向上看</strong> 人体是不能移动的 所以这里移动视角实际上是移动摄像机的视角 \n<strong>左右</strong>移动的时候是<strong>整个人移动</strong>  旋转的 <em>Player</em> 上下旋转是 <em>Camera</em> </p>\n<h3>unity的摄影机</h3>\n<p>摄像机就是一个一般的物体  <strong>空物体</strong>只有 <em>transfrom</em> 属性 摄像机的话就是在基础上再加一个 <em>camera</em> 还有一个 <em>audiolister</em> 听声音的 摄像机是兼具了视觉和听觉两个功能 两个声道的</p>\n<hr>\n<h3>引入枪</h3>\n<p>点击 <code>保存到我的资源</code>-&gt;<code>在Unity中打开</code>-&gt;<code>点击Download</code>-&gt;<code>Import</code></p>\n<p>选择<code>Mesher</code>带阴影-&gt;点击一个模型之后,可以在右下角查看这把枪</p>\n<p>将枪移动到右侧的 Camera 上边 移动完之后可以 <strong>reset</strong> 一下</p>\n<p>把Camera作为Player的子元素的话 Camera的Position就是相对于父元素的位置了  直接往左拖就可以改变父元素位置 如果在外部没有父元素(或者说\n是Scene的最近子元素 这个元素的坐标就是绝对坐标 如果是有父元素 那么它的坐标就是相对于父元素的坐标)</p>\n<h3>调整枪的位置</h3>\n<p>选中camera可以发现视角是在camera后边的 选中枪 调整位置\n双击<strong>Game</strong>可以看</p>\n<hr>\n<p>总结一下上午的东西 </p>\n<p>引入新的材质包 </p>\n<p>Acwing好像需要达到一定金额才能 发分享 或者说实名认证</p>\n<p><a href=\"https://www.acwing.com/blog/content/34691/\">指针导航分享页</a></p>\n<hr>\n<p>合并整个物体</p>\n<p>调整完之后 创建一个新的 <code>EmptyObject</code> 可以 F2改名 或者 Inspector 改名 然后按住Ctrl 进行多选\n将几个物体 拖动到新的物体上面</p>\n<p>这几个子元素共同构成环境 当然 光也是属于这个环境的 你可以把它拖进来 </p>\n<p>创建新的视角 第三人称的可以先删除</p>\n<p>创建一个球体 改变位置 大约离地面两格子 </p>\n<p><code>注意</code></p>\n<p>reset应该是创建之初的位置 多物体合成一个物体的时候 这时候的初始坐标 应该保持地面的原点坐标是</p>\n<p>(000) 这样reset的时候是符合直觉的 </p>\n<p>摄影机 枪 所以使用使用内部的空对象来维护纹理 Player内部创建 Graphics (这个是实际的看见的纹理)\n外层Player更像是体积 \n删除外层纹理  MeshRender和Sphere用来控制纹理  右键MeshRender选中 <code>Remove Component</code> 同样的\n删除Sphere(MeshFilter)</p>\n<p>collider是用来检测碰撞的 不能进入墙体里边 \n选中Graphcs创建一个3dProject Player已经有一个球用来检测碰撞了 把里边的SphereCollider删除</p>\n<p>然后右键Player创建相机 如果不是0 0 0记得reset一遍 </p>\n<p>所有的面(Pane)都是有相的 只从一个方向看是有面的 但是从另一个方向看是透明的\n所以把相机塞到球里边是可以看见外边的  想看一下运行起来的画面 上方点击Game就可以了 </p>\n<p>可以把这个界面拖到右边进行分屏 双击 Player (注意此时 是Player-&gt;Graphcs(Sphere)+Camera)的结构 \n移动 Camera也会移动 移动之后进行reset一下</p>\n<p>Graphcs用来画角色纹理的 </p>\n<hr>\n<p>调整过地图拜访位置之后</p>\n<p>就可以为图形添加纹理了</p>\n<p>打开 Resources 在Materials里边 一个图形的纹理和皮肤都在Materials里边 </p>\n<p>直接把这个纹理拖动到物体上面就可以为其赋值  改变地板和物体之间的距离</p>\n<p>大概是0.05的高度 </p>\n<hr>\n<p><code>Unity资源商店</code></p>\n<p>可以导入很多已有的资源  别人做好的资源 打开-&gt;在Unity中打开-&gt;Import-&gt;全部导入(这里可以选)</p>\n<p>未来写的东西 都在 <code>assets</code> 里边 进入里边 <code>scenes</code>是场景 是自带的 </p>\n<p>DigitalKonstruct- <code>Prototyping_Pack_free</code>-&gt;Resources-&gt;</p>\n<p>meshes 自带阴影 拖动图形 左侧可以看全貌(双击该物体即可) 右侧可以改变属性\n右键reset可以清空</p>\n<p><code>关于旋转</code></p>\n<p>注意的一点是 如果直接按照图形上边的轴进行旋转 则是围绕着以物体中心为原点的坐标系的轴进行的旋转</p>\n<p>如果直接在右侧 <em>Transform</em> 面板进行旋转则是围绕着整个世界的轴进行旋转 </p>\n<p><code>关于复制物体</code> </p>\n<p>直接按住 <code>ctrl</code> 进行拖动不可以 只能通过cv进行复制  </p>\n<p>放在中间可以等比例缩放 在右侧导航栏可以有个 <code>连接</code>的小按钮 点击一下可以等比例缩放\n(这里导航栏通常是指<code>Inspector</code>)</p>\n<hr>\n<p>两天的结构思考</p>\n<p>可以发现Acwing的<code>动态</code>是有规律的推送的 应该是同样报课的同学 更有推送的权力\n倘若是完全没有报价格高的课 是完全不会推送的 仅自己可见</p>\n<hr>\n<p><strong>熟悉操作</strong> </p>\n<p><code>alt</code>+<code>鼠标左键</code> 旋转整个世界 \n<code>右键</code>是旋转自己的视图 在一个点旋转 \n而前者则是通过根据原点旋转世界</p>\n<p>鼠标滚轮按下 拖动则可以<code>平移世界</code> \n滚轮可以放大缩小(<code>alt</code>+<code>右键</code>同样可以) </p>\n<p><code>双击</code>物体可以把物体作为视角的正中心</p>\n<p>之后 关于物体的所有属性 都可以再右侧的inspector窗口显示出来</p>\n<pre><code>transform 可以用来显示物体的坐标(中心坐标)\n</code></pre>\n<p><em><strong>平移物体</strong></em>  右上角对应物体中心的轴颜色 某个轴对用的方向上平移 只需要在这个轴箭头上平移就可以了\n如果要在两个轴组成的平面上移动 只需要按住对应的轴组成的平面就可以了 也可以直接按住中心点来进行移动\n注意平面的颜色 是没有构成这个平面的轴的颜色 是对应的</p>\n<p>更改位置 对应的xyz上面按住 可以_平滑的移动_ 支持直接改物体的三个坐标 如果想要复位 就在<code>Transform</code>上面右键\n就可以了</p>\n<p><strong>Rotation</strong> 表示对物体进行旋转 对应的x,y,z表示围绕x,y,z旋转的程度 \n如果需要进行旋转操作 只需要左侧的小框内切换一下为<code>旋转箭头</code>就可以了 同样支持平滑移动\n需要在围绕哪个轴旋转 就选中对应轴的颜色就可以了</p>\n<p><strong>scale</strong> 表示在某个轴上的大小 点击左侧的小框中的伸缩按钮 同样的在对应的方向上 按住轴进行缩放\n放在中间可以等比例缩放 在右侧导航栏可以有个 <code>连接</code>的小按钮 点击一下可以等比例缩放\n(这里导航栏通常是指Inspector)</p>\n<p>物体使用<code>Delete</code>可以直接删除物体</p>\n<hr>\n<p><strong>2927-2300</strong> </p>\n<p>重新看</p>\n<p>这两天做了什么 </p>\n<p><strong>71</strong> 闹了文字 一天精神不太对 没状态\n<strong>72</strong> 上午看了一小会 然后发现Acwing把写好的笔记吞了 搞了一下午\n<strong>73</strong> 今天补牙去了  然后今天开始从昨天上午的开始看</p>\n<p>没想到对新手这么不友好?hh 玩笑话</p>\n<hr>\n<p><strong>23:33</strong></p>\n<p>引入第三方免费的模型 <a href=\"https://assetstore.unity.com/packages/3d/prototyping-pack-free-94277\">模型地址</a>\n点击<code>在unity中打开</code></p>\n<hr>\n<p><strong>补充</strong></p>\n<p><em>关于副屏</em></p>\n<p>宿舍一个14的 在家15的 害怕来回搬会压坏 直接买两个</p>\n<p>269Rmb 15英寸支持Hdr 1920*1080 够用 但是竟然很清晰 哈哈</p>\n<p>今天一直搞Hdr显示 <em>开了变暗不开模糊</em></p>\n<p>最后发现是电源插到电脑上的usb口了 最后还是嫌弃开了Hdr变暗把Hdr关了</p>\n<p>后来插上电源变得和清晰 犯病一样 此外处理文字变细</p>\n<h4>校准显示器颜色!</h4>\n<p>这是windows自带的程序 通过左下角的<strong>搜索</strong>来打开</p>\n<hr>\n<p><code>u3d_630_01</code></p>\n"},{"id":7,"title":"z-刷机","date":"2024-04-24","content":"<p><a href=\"https://www.acwing.com/blog/content/34691/\">回退到导航分享页</a></p>\n<p><strong>声明</strong>:对于我来说  写本文的目的还是<strong>为了自己以后能够直接按照流程的到自己喜欢的风格</strong> \n不要看见不满意的就指指点点 我没资格要求您来看 您也没有资格指导他人怎么做 更无论在这里大喊大叫\n您不想看见这类文字不如全部复制下来自己改一改 或者完全自己写一段 </p>\n<p>个人非常反感在一个公共的地方例如(视频/音乐)\n游戏 在那边说为什么不这样改 为什么不那样改 这个地方音高了不好听为什么不调低 笔者对这种自己不满意 不按照自己\n喜好 甚至妄图改变他人思想和行为的行为感到厌恶 如果你不满意大可<strong>拉黑</strong> <strong>点踩</strong> 不必声张你强迫他人的语言 </p>\n<p>感谢你看完这段声明嗷~</p>\n<hr>\n<h2>买了个二手电脑</h2>\n<p>刷机windows家庭版(以后就刷专业版了) 现在将整理所有过程 </p>\n<p><strong>注意</strong>只有<code>edge谷歌</code>这一类原生浏览器 以及<code>bing首页</code>   <code>Adgard预防</code> \n   !!! 才能够完全隔离 类似百度快照类的垃圾网站推荐 这样才能获得较好的使用体验</p>\n<h4>首先刷机的时候备注</h4>\n<pre><code>c-128\nd-195-document\ne-195-software\nf-540-game\n</code></pre>\n<p>更改名称是之后的事情了</p>\n<p><strong>系统配置</strong></p>\n<ol>\n<li><p>更新禁用 安装windows更新禁用(方便的处理windows更新) </p>\n</li>\n<li><p>系统触控板 关闭连接键盘时候的触控板</p>\n</li>\n<li><p>桌面优化 下载阿里网盘中的 <code>键盘关闭</code>   <code>快捷方式小箭头</code></p>\n</li>\n<li><p>连接wifi 登录wifi-设置导航栏(搜索仅显示图标-不显示cortana)</p>\n</li>\n<li><p>输入法语言 英语第二语言 shift+alt更换语言(处理游戏输入情况)</p>\n</li>\n<li><p>锁屏用户名 家庭版需要在控制面板中更改用户名</p>\n</li>\n<li><p>快捷方式大小 桌面右键查看更改图标大小 任务栏右键-&gt;设置-&gt;小任务按钮(任务栏以及图标小图标)</p>\n</li>\n</ol>\n<p><strong>下载阿里网盘</strong></p>\n<p>在D(Document)盘 新建<code>aliDownload</code>和<code>EdgeDownload</code>文件夹</p>\n<p>使用阿里网盘下载这些压缩包</p>\n<pre><code>搬家与急救与常用-&gt;二手电脑安装包\nbandzip(好像有注册码但默认免费)\n      解压后/bandzip点击 安装成功 立即应用 将ok内部替换到打开文件位置 即可激活\n关闭自动更新\n小箭头\n自带键盘\n</code></pre>\n<h4>开始使用</h4>\n<p>默认是有Edge的 然后首先下载<code>火绒个人版</code> 安装到c盘 </p>\n<p>首先登录micsoft账户 登录edge同步数据(会自动安装脚本和同步文件夹)</p>\n<h3>新windows账户</h3>\n<p>新建了一个账户(windows绑定我的小号qq) 首先登录office 之后会有一段时间缓冲 </p>\n<p>:右键收藏夹按钮 导出收藏夹 切换用户配置 导入数据 从html导入收藏夹 </p>\n<p>edge打开垂直标签页 关闭边栏 </p>\n<p>切换本地用户 停止自动登录所有windows应用 之后切换为本地用户登录 登录新的windows账号即可</p>\n<p>在电子邮件和账户这里可以保留原来的账号 这样就可以在原来的账户上注册这台电脑</p>\n<p>steam国区号 直接登录无法家庭共享 需要先登录母号 然后在此电脑上授权</p>\n<p><strong>卸载</strong></p>\n<pre><code>卸载不需要的功能(电脑)\nonenote\n</code></pre>\n<p><strong>安装</strong> </p>\n<pre><code>edge 通过官网下载\nqq 微信 网易云 steam  鲜牛加速器 \nwallpaperEng 设置焦点其他应用暂停 以及 高优先级(脱离steam)\n//这些东西能改到e盘都改到e盘(software) 内新建一个文件夹 容纳软件主体\n(往往体现为(Netease-&gt;NetEaseCloudMusic)) 前边是自己的 后边才是真正的安装主体\n\n小箭头/自带键盘 复制下来解压到具体文件夹\n\nmykeymap\n</code></pre>\n<p>Everything+Clash+油猴(csdn优化+m3u8下载器)</p>\n<h3>火绒禁用启动项</h3>\n<p>将例如<code>edgeupdate</code>以及类似<code>qq安全盾</code> 之类的不需要的 启动项关闭\n提升运行速度 预防卡顿</p>\n<p>此篇幅到此结束 </p>\n<hr>\n<h2>分割</h2>\n<hr>\n<h3>刷机环境配置</h3>\n<p><a href=\"https://www.acwing.com/blog/content/34837/\">vue</a></p>\n<pre><code>环境变量\njava,npm,Mysql,ssh,\n大部分应该是安装对应软件自动配置 会有选项\n</code></pre>\n<p><code>npm config set registry https://registry.npm.taobao.org/</code> 可以用来设置淘宝镜像源 \n用来安装<code>yarn</code>以及<code>vite</code>等等</p>\n<h3>一般刷机软件</h3>\n<pre><code>202326\nGitBash   IDEA  RiDER\nVSCODE  Everything  Quicker/指间工具箱 MyKeyMap\n火绒 阿里云盘 BandZip TuUninstall\nEdge账户  PotPlayer\n安装英语 Bios功能键映射 禁用Num键\n鼠标光标 笔记本键盘默认关闭\n</code></pre>\n<h3>工程所需环境</h3>\n<pre><code>Vue/Npm\n环境变量\nmysql\nredis\nrabbitmq\n</code></pre>\n<p><strong>软件</strong></p>\n<pre><code>网易云音乐\nIDEA\nGit\nNodeJs\nClIku\nVsCode\n谷歌\n</code></pre>\n<h3>娱乐/游戏</h3>\n<pre><code>\nQQ\n微信\n钉钉\n腾讯会议\nSteam\nHzd\nEpic\n鲜牛\n猎豹\n</code></pre>\n<ul>\n<li></li>\n</ul>\n<pre><code>端小9磁力\n堂木樱桃Eh\n图凌8\n歌词适配\nViewer\n丸子云\n游民星空\nbilibili\nBUff\nSteam+\nidm\nmykey map\n</code></pre>\n<ul>\n<li></li>\n</ul>\n<pre><code>Mysql\nJava\nnpm\n@文件加密\n\n</code></pre>\n<p>用了edge就像回家了一样</p>\n<p>First Edge 账户同步设置\n1,火绒,下载站下载器\n2,下载路径,卸载原生软件\n3,壁纸指针任务栏键盘充电快速启动\n4,\n5,\n6,\n7,</p>\n<hr>\n<p>2022/7/22</p>\n<p>买了新硬盘</p>\n<blockquote>\n<p>美光 1T 569 </p>\n</blockquote>\n<p>打算这几天刷机</p>\n<p>重新下软件\n<strong>老分区</strong></p>\n<pre><code>N S     B\nc 200g  54%\nd 50g   58%\ne 50g   79%\nf 200g  10%\n</code></pre>\n<p>预计新分区</p>\n<pre><code>N Size UseFor\nc 312\nd 100  WenJP\ne 100  RuanJP\nf 1T  YouXP\n</code></pre>\n"},{"id":8,"title":"基础算法","date":"2024-04-01","content":"<h2>基础算法</h2>\n<h3>常用代码模板 1——基础算法</h3>\n<ul>\n<li>排序</li>\n<li>二分</li>\n<li>高精度</li>\n<li>前缀和与差分</li>\n<li>双指针算法</li>\n<li>位运算</li>\n<li>离散化</li>\n<li>区间合并</li>\n</ul>\n<h2>数据结构</h2>\n<h3>常用代码模板 2——数据结构</h3>\n<ul>\n<li>链表与邻接表：树与图的存储</li>\n<li>栈与队列：单调队列、单调栈</li>\n<li>kmp</li>\n<li>Trie</li>\n<li>并查集</li>\n<li>堆</li>\n<li>Hash 表</li>\n</ul>\n<h2>搜索与图论</h2>\n<h3>常用代码模板 3——搜索与图论</h3>\n<ul>\n<li>DFS 与 BFS</li>\n<li>树与图的遍历：拓扑排序</li>\n<li>最短路</li>\n<li>最小生成树</li>\n<li>二分图：染色法、匈牙利算法</li>\n</ul>\n<h2>数学知识</h2>\n<h3>常用代码模板 4——数学知识</h3>\n<ul>\n<li>质数</li>\n<li>约数</li>\n<li>欧拉函数</li>\n<li>快速幂</li>\n<li>扩展欧几里得算法</li>\n<li>中国剩余定理</li>\n<li>高斯消元</li>\n<li>组合计数</li>\n<li>容斥原理</li>\n<li>简单博弈论</li>\n</ul>\n<h2>动态规划</h2>\n<ul>\n<li>背包问题</li>\n<li>线性 DP</li>\n<li>区间 DP</li>\n<li>计数类 DP</li>\n<li>数位统计 DP</li>\n<li>状态压缩 DP</li>\n<li>树形 DP</li>\n<li>记忆化搜索</li>\n</ul>\n<h2>贪心</h2>\n<h2>时空复杂度分析</h2>\n"},{"id":9,"title":"常用模板","date":"2024-04-14","content":"<h2>Head</h2>\n<h3>多个属性的输入输出</h3>\n<pre><code class=\"language-cpp\">/*\n*/\nint T;\nscanf(&quot;%d&quot;, &amp;T);\nwhile (T -- )\n{\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 0; i &lt; n; i ++ )\n    {\n        int t, d, l;\n        scanf(&quot;%d%d%d&quot;, &amp;t, &amp;d, &amp;l);\n        p[i] = {t, d, l};\n    }\n\n    memset(st, 0, sizeof st);\n    if (dfs(0, 0)) puts(&quot;YES&quot;);\n    else puts(&quot;NO&quot;);\n}\n</code></pre>\n<hr>\n<h3>拓展欧几里得方法</h3>\n<ol>\n<li>要证明 $a \\cdot x + b \\cdot y = d$，其中 $d = \\text{gcd}(a, b)$</li>\n<li>由辗转相除法，得到 $a = q \\cdot b + r$</li>\n<li>使用递归关系得到 $D = \\text{gcd}(b, r)$，$D = b \\cdot x_1 + r \\cdot y_1$</li>\n<li>展开$r = a - q \\cdot b$</li>\n<li>代入$D = \\text{gcd}(b, r)$得到$D = b \\cdot x_1 + (a - q \\cdot b) \\cdot y_1$</li>\n<li>整理得到 $D = a \\cdot y_1 + b \\cdot (x_1 - q \\cdot y_1)$</li>\n<li>因此 $x = y_1$，$y = x_1 - [a/b] \\cdot y_1$</li>\n</ol>\n<pre><code class=\"language-cpp\">/*\n1. 这题需要等价替换 (a,b)=(b,a mod b) 那么对应x y也要反转 系数之间是绑定的 \n2. 求 ai*xi + bi*yi =gcd(ai,bi)\n==&gt; ax+by=(a,b)=(b,a mod b)\n=bx+(a mod b)y\n//我们这里为什么反转 y x呢 b相当于a 那么y就相当于x\n让by+(a mod b)x=(b,a mod b)=(a,b)\n展开 a mod b =r= a- [a/b]*b      [下取整]\n    因为 a除以b=[a/b]....r余数\n所以 r=a-[a/b]*b=a mod b\nb*y+(a-[a/b]*b)x=d\n整理可以得到 a*x+b(y-[a/b]*x)=d\n那么y0=y-[a/b]*x\n\n3. 在这段代码和注释中，通过递归调用求解最大公约数时，有一个基本情形（base case）是处理 $b=0$ 的情况，这对应着递归的终止条件。当 $b=0$ 时，意味着辗转相除法已经将剩余的非零数调整到了余数为0的情况，此时 $a$ 是最大公约数，而 $x=1, y=0$ 则是这个式子 $a \\cdot x + b \\cdot y = \\text{gcd}(a, b)$ 的一组解，同时也满足欧几里德算法的退出条件。\n\n在这段代码中，当 $b=0$ 时，$x$ 被赋值为 $1$，$y$ 被赋值为 $0$，这是因为 $b=0$ 的情况下，最大公约数为 $a$，而这个时候 $x=1, y=0$ 满足这个情况。这样的赋值是为了让递归到最底部时，逐层向上传递正确的解。 \n\n对于递归中反转 $x$ 和 $y$ 的操作，这是因为在辗转相除法的步骤中，需要逐步更新 $x$ 和 $y$ 的值，以便最终得到满足最大公约数的 $x$ 和 $y$。所以，在递归的过程中，交换 $x$ 和 $y$ 的值是为了正确地得到整个连续的求解过程。\n*/\n\nint exgcb(int a,int b,int &amp;x,int &amp;y){\n    if(!b){\n        x=1,y=0;//此时SA成立 就等于 a*x+0*y=a; x=1,y=0就是一组解\n        return a;//a和0的最大公约数一定是a\n    }\n    int d=exgcb(b,a%b,y,x);\n    y-=a/b*x;\n    return d;//余数继续返回\n}\nint main(){\n    while(n--){\n        int a,b,x,y;\n        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n        exgcb(a,b,x,y);\n        printf(&quot;%d %d\\n&quot;,x,y);\n}\n}\n</code></pre>\n<h3>快速幂</h3>\n<pre><code class=\"language-cpp\">/*\n快速求解 \na^k mod p;\n*/\nint get_mi(int a,int k,int p){\n    LL res=1;\n    while(k){\n        if(k&amp;1) res=res*a%p;\n        k&gt;&gt;=1;\n        a=(LL)a*a%p;\n    }\n    return res;\n}\n</code></pre>\n<h3>gcd辗转相除法</h3>\n<pre><code class=\"language-cpp\">int gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\n//这不除完a 然后再处b 如果b=0 true:false\n</code></pre>\n<h3>分解质因数</h3>\n<pre><code class=\"language-cpp\">/*\n*/\nfor(int i=2;i&lt;=n/i;i++){\n    if(n%i==0){\n        int s=0;\n        while(n%i==0){\n            n/=i;\n            s++;\n        }\n        printf(&quot;%d %d\\n&quot;,i,s);\n        \n    }\n    \n}\nif(n&gt;1) printf(&quot;%d 1\\n&quot;,n,1);\nputs(&quot;&quot;);\n</code></pre>\n<hr>\n<h3>线性筛质数</h3>\n<pre><code class=\"language-cpp\">/*\n*/\nvoid get_primes(int n){\n    for(int i=2;i&lt;=n;i++){\n        if(!st[i]) primes[++cnt]=i;\n        for(int j=1;primes[j]&lt;=n/i;j++){\n            st[primes[j]*i]=true;//primes[j]*i是合数\n            if(i%primes[j]==0) break; //假如 primes[j]和i相同 primes[j]是最小质因数 遇到最小质因数就退出\n        }\n    }\n}\n</code></pre>\n<hr>\n<h3>并查集<a href=\"#Head\">^</a></h3>\n<pre><code class=\"language-cpp\">/*\n并查集 将集合合并 连通块的点的数量\n*/\nint find(int x){\n    if(p[x]!=x) p[x]=find(p[x]);\n    return p[x];\n}\nfor(int i=1;i&lt;=n;i++) {\n    p[i]=i;\n    cnt[i]=1;//几乎是相同的 因为cnt一开始每个集合单独的自身节点为1\n}\n</code></pre>\n<hr>\n<h3>位运算<a href=\"#Head\">^</a></h3>\n<pre><code class=\"language-cpp\">/*\n*/\n// 位运算 第k位数字\nn&gt;&gt;k&amp;1\n//n的最后一位1 1001001 -&gt;不是最后一个1\nlowbit(n)=n&amp;-n\n</code></pre>\n<hr>\n<h3>Hash开放寻址<a href=\"#Head\">^</a></h3>\n<pre><code class=\"language-cpp\">const int null=0x3f3f3f3f,N=20003;\nint find(x){\n    x=(x%N+N)%N;\n    while(h[x]!=null&amp;&amp;h[x]!=x){//// 如果k=N 说明我们这个表格找到头了 此时k=0 说明继续从头开始找 先执行k++\n        k++;\n        if(k==N) k=0;\n    }\n    return k;\n}\n</code></pre>\n<hr>\n<h3>T4<a href=\"#Head\">^</a></h3>\n<hr>\n<h3>T5<a href=\"#Head\">^</a></h3>\n<hr>\n<h3>T6<a href=\"#Head\">^</a></h3>\n<h1>This title</h1>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-04-02-21：14：27（星期二）</em></span></p>\n"},{"id":10,"title":"常用的工具","date":"2024-04-24","content":"<p>推荐使用这些网站时,你必须拥有一个<code>谷歌账号</code>.少部分网站能够使用大陆手机号</p>\n<p><a href=\"https://www.acwing.com/blog/content/34691/\">回退到导航分享页</a></p>\n<hr>\n<h3><strong>配字幕</strong></h3>\n<p>视频识别语音转Acc字幕文件</p>\n<p>Acc字幕翻译 <a href=\"https://github.com/speauty/anto\">GitHub项目推荐-Speaty</a></p>\n<h3>找图片</h3>\n<ol>\n<li><p>找例图,可以在 <em>tb</em> , <em>pdd</em> 上找到想要的类型 例如 <code>雷姆等身抱枕</code></p>\n</li>\n<li><p>以图搜图 推荐使用<a href=\"https://yandex.com/\">Yandex</a>\n强烈推荐 左边是这张的图的相似的图 右边包含下载按钮 以及类似的图片\n也就是不断地<strong>映射</strong> 这种方法可以很快就可以找到类似喜欢的图片</p>\n</li>\n<li><p>无损放大,接下来进行放大 因为原图放大之后就会失真 在等身的物品上更加突出\n推荐<a href=\"https://bigjpg.com/zh\">BigJpg</a> 每个月免费20张  <strong><em>3k限制 4x 中度降噪</em></strong></p>\n</li>\n</ol>\n<h3>资源的存储与分享</h3>\n<p>lz一直有习惯 将图片上传到网盘软件 手机里的图片太多了 就不考虑隐私泄露的问题了\n不过分享</p>\n<p>推荐<a href=\"https://up.woozooo.com/\">蓝奏云</a> 被分享的人 不需要登录就可以下载下来 并不限速\n不过并不支持 <em>直接上传图片</em>  需要先将图片压缩一下</p>\n<ol start=\"4\">\n<li>无损压缩  <a href=\"https://www.img2go.com/zh/compress-image\">IMG2Go</a></li>\n</ol>\n<hr>\n<h2>公众号</h2>\n<pre><code>3DM i呀我去(过dxx)\n飞雪科技园\n</code></pre>\n<hr>\n<h3>文案</h3>\n<p><a href=\"https://chat.openai.com/\">文案/简化文字写作速度</a></p>\n<h3>PPt/Presentation</h3>\n<p><a href=\"https://gamma.app/\">Gamma/协助Ai生成模板</a></p>\n<ul>\n<li>你可以通过截图并粘贴到PPt添加动画来快速生成一个自己的PPt</li>\n</ul>\n<h3>开发者工具箱</h3>\n<p><a href=\"https://he3.app/zh/\">He3</a></p>\n<p><a href=\"https://www.voidtools.com/zh-cn/\">Everything/优化搜索速度</a></p>\n<h3>前端</h3>\n<p><a href=\"https://play.teleporthq.io/\">网页生成/拖动释放</a></p>\n<h3>软件</h3>\n<p><a href=\"https://iui.su/\">不死鸟/软件以及网站分享</a></p>\n<ul>\n<li>你可以获取影视音乐工具等网站等资源</li>\n</ul>\n<p><a href=\"dalao.ru\">大佬点入</a></p>\n<ul>\n<li>不死鸟起始页</li>\n</ul>\n<h3>clash</h3>\n<p><a href=\"ikuuu.eu\">iku</a></p>\n<ul>\n<li>拥有Free的端点可以使用 不过网站站点经常更换</li>\n</ul>\n<h3>导航页</h3>\n<p><a href=\"https://webjike.com/\">小呆</a></p>\n<ul>\n<li>很久之前的导航页了</li>\n</ul>\n<h3>游戏</h3>\n<p><a href=\"https://www.duowan998.com/\">酷玩PddCharge</a></p>\n<ul>\n<li>Pdd5块钱买的号 哈哈 还活着</li>\n</ul>\n<h3>视频书</h3>\n<p><a href=\"https://topbook.cc/content\">TopBook</a></p>\n<ul>\n<li>高效生活指南视频书(简介是这样的)</li>\n</ul>\n<h3>图片</h3>\n<p><a href=\"https://pixabay.com/zh/\">图片库</a></p>\n<ul>\n<li>Ps指定图片源</li>\n</ul>\n<p><a href=\"https://wallhaven.cc/\">宅男/二次元/壁纸</a></p>\n<ul>\n<li>这个可以用来暂时作为图库存储几张背景图</li>\n</ul>\n<p><a href=\"https://sm.ms/\">图床/暂时一个月/魔法</a></p>\n<h3>与非门</h3>\n<p><a href=\"https://www.nandgame.com/\">NandGame</a></p>\n<ul>\n<li>yq推荐的与非门游戏</li>\n</ul>\n<h3>国外浏览器</h3>\n<p><a href=\"https://hyperbeam.com/app/login\">Hyper</a></p>\n<hr>\n<h3>不要忘了回家</h3>\n<p><a href=\"https://www.xfltd.cc/\">养鸡场</a></p>\n<p><a href=\"https://ikuuu.eu/\">ikuu</a></p>\n<hr>\n<p>工具站/快捷站</p>\n"},{"id":11,"title":"操作符和类型","date":"2024-04-08","content":"<h2>总览</h2>\n<blockquote>\n<p><a href=\"#long_long\">long_long</a>&gt;<a href=\"#Int_%E5%8F%98%E9%87%8F\">Int_变量</a>&gt; <a href=\"#%E6%95%B0%E7%BB%84\">数组</a>&gt;<a href=\"#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6\">算术运算符</a>&gt;<a href=\"#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6\">关系运算符</a>&gt;<a href=\"#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6\">逻辑运算符</a>&gt;<a href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6\">位运算符</a>&gt;<a href=\"#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6\">赋值运算符</a>&gt;<a href=\"#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6\">条件运算符</a>&gt;<a href=\"#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6\">逗号运算符</a>&gt;<a href=\"#%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97%E7%AC%A6\">类型相关运算符</a>&gt;<a href=\"#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97%E7%AC%A6\">其他运算符</a>&gt;<a href=\"#%E6%95%B0%E7%BB%84\">数组</a></p>\n</blockquote>\n<h3>StringAndChar</h3>\n<p>String必须通过cin来读</p>\n<pre><code class=\"language-cpp\">char s[N];\ncin&gt;&gt;(s+1);//下标从1开始 Kmp\n</code></pre>\n<h3>long_long</h3>\n<pre><code class=\"language-cpp\">/*\n1. **long long类型**：通常是64位，可以表示的范围是 -9223372036854775808 到 9223372036854775807\n(如果是无符号的话，则是 0 到 18446744073709551615)\n\n无符号情况说的是 unsigned long long\n\n一万八千亿\n*/\n</code></pre>\n<h3>Int_变量</h3>\n<pre><code class=\"language-cpp\">/*\n\n一个int  占4个字节 32位\nint类型的最大值：2147483647 ($2^{31} - 1$)\nint类型的最小值：-2147483648 (-$2^{31}$)\n\nint类型的最大长度 32位\n\n21亿\n*/\n</code></pre>\n<h3>数组<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<p>64MB 空间为例 数组范围为 最多开 1600 万 超过范围就报 MLE</p>\n<h3>算术运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>+</code> 加法</li>\n<li><code>-</code> 减法</li>\n<li><code>*</code> 乘法</li>\n<li><code>/</code> 除法</li>\n<li><code>%</code> 模（余数）</li>\n</ul>\n<h3>关系运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>==</code> 等于</li>\n<li><code>!=</code> 不等于</li>\n<li><code>&lt;</code> 小于</li>\n<li><code>&gt;</code> 大于</li>\n<li><code>&lt;=</code> 小于等于</li>\n<li><code>&gt;=</code> 大于等于</li>\n</ul>\n<h3>逻辑运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>&amp;&amp;</code> 逻辑与</li>\n</ul>\n<pre><code class=\"language-cpp\">if(a==1&amp;&amp;b==2)\n</code></pre>\n<ul>\n<li><code>||</code> 逻辑或</li>\n</ul>\n<pre><code class=\"language-cpp\">if(a==1||b==2)\n</code></pre>\n<ul>\n<li><code>!</code> 逻辑非</li>\n</ul>\n<pre><code class=\"language-cpp\">if(!k)\n</code></pre>\n<h3>位运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>&amp;</code> 位与(全 1 才 1)</li>\n</ul>\n<pre><code class=\"language-cpp\">//作用：对两个数进行位与操作，两个相应的位都为1时，结果位才为1，否则为0\nint a = 5; // 二进制表达：0101\nint b = 3; // 二进制表达：0011\nint result = a &amp; b; // 结果是 1 ，二进制表达：0001\n</code></pre>\n<ul>\n<li><code>|</code> 位或(全 0 才 0)</li>\n</ul>\n<pre><code class=\"language-cpp\">//作用：对两个数进行位或操作，两个相应的位中只要有一个为1时，结果位就为1\nint a = 5; // 二进制表达：0101\nint b = 3; // 二进制表达：0011\nint result = a | b; // 结果是 7，二进制表达：0111\n</code></pre>\n<ul>\n<li><code>^</code> 位异或(不同为 1)</li>\n</ul>\n<pre><code class=\"language-cpp\">//对两个数进行位异或操作，两个相应的位相异时，结果位为1。\nint a = 5; // 二进制表达：0101\nint b = 3; // 二进制表达：0011\nint result = a ^ b; // 结果是 6，二进制表达：0110\n</code></pre>\n<ul>\n<li><code>~</code> 位取反</li>\n</ul>\n<pre><code class=\"language-cpp\">//对数的二进制表示进行取反操作，即将所有的0变为1，所有的1变为0\nint a = 5; // 二进制表达：0000 0101\nint result = ~a;\n// 假设 int 为 32位，结果大概是 -6，二进制表达为 1111 1010 （取决于具体的机器，因为整数通常使用补码表示负数）\n</code></pre>\n<p>注意：位取反操作通常会将正数变为负数，这是因为大多数计算机系统用补码表示负数</p>\n<ul>\n<li><code>&lt;&lt;</code> 左移</li>\n</ul>\n<pre><code class=\"language-cpp\">/*\n将一个数的各二进制位全部左移若干位，对于左移n位，低位空出的位用0填补\n*/\nint a = 5; // 二进制表达：0101\nint result = a &lt;&lt; 2; // 结果是 20，二进制表达：10100\n</code></pre>\n<ul>\n<li><code>&gt;&gt;</code> 右移</li>\n</ul>\n<pre><code class=\"language-cpp\">/*\n将一个数的各二进制位全部右移若干位，对于右移n位，高位空出的位由符号位填补（对于无符号数，用0填补）\n*/\nint a = 20; // 二进制表达：10100\nint result = a &gt;&gt; 2; // 结果是 5，二进制表达：0101\n</code></pre>\n<h3>赋值运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>=</code> 简单赋值</li>\n<li><code>+=</code> 加后赋值</li>\n<li><code>-=</code> 减后赋值</li>\n<li><code>*=</code> 乘后赋值</li>\n<li><code>/=</code> 除后赋值</li>\n<li><code>%=</code> 模后赋值</li>\n<li><code>&lt;&lt;=</code> 左移后赋值</li>\n</ul>\n<pre><code class=\"language-cpp\">1&lt;&lt;=2;//1-&gt; 100 =4\n</code></pre>\n<ul>\n<li><code>&gt;&gt;=</code> 右移后赋值</li>\n<li><code>&amp;=</code> 按位与后赋值</li>\n<li><code>^=</code> 按位异或后赋值</li>\n<li><code>|=</code> 按位或后赋值</li>\n</ul>\n<h3>条件运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>?:</code> 三元运算符，形如 <code>condition ? expr1 : expr2</code></li>\n</ul>\n<h3>逗号运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>,</code> 用来分隔表达式，并返回<strong>最后一个表达式</strong>的值</li>\n</ul>\n<h3>类型相关运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>sizeof</code> 返回数据类型或变量的大小</li>\n<li><code>typeid</code> 用于获取对象的类型信息</li>\n<li><code>dynamic_cast</code> 安全地将指针或引用从一种类型转换为另一种类型</li>\n<li><code>static_cast</code> 强制类型转换，但没有运行时类型检查</li>\n<li><code>const_cast</code> 添加或去除变量的 <code>const</code> 属性</li>\n<li><code>reinterpret_cast</code> 用于进行各种不安全的指针类型转换</li>\n</ul>\n<h3>其他运算符<a href=\"#%E6%80%BB%E8%A7%88\">^</a></h3>\n<ul>\n<li><code>&amp;</code> 地址运算符，取变量地址</li>\n<li><code>*</code> 指针运算符，指向一个变量</li>\n<li><code>-&gt;</code> 用于指针访问类、结构体、联合的成员</li>\n<li><code>::</code> 作用域解析运算符，用于指定命名空间或类范围内的成员</li>\n<li><code>++</code> 自增运算符</li>\n<li><code>--</code> 自减运算符</li>\n</ul>\n<p>C++ 运算符的使用广泛且复杂，了解和熟悉这些运算符对编程非常重要。</p>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-04-03-08：4333（星期三）</em></span></p>\n"},{"id":12,"title":"时间复杂度","date":"2024-04-03","content":"<h3>背诵</h3>\n<pre><code class=\"language-cpp\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt; //vector.push_back .top\npriority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;\n</code></pre>\n<hr>\n<h3>数据</h3>\n<pre><code class=\"language-cpp\">/*\n*/\n在C++中，不同的数据类型在各个系统上可能有所不同，但通常情况下，它们的表示范围如下：\n\n1. **int类型**：通常是32位，可以表示的范围是 -2147483648 到 2147483647（如果是无符号的话，则是 0 到 4294967295）。\n\n2. **unsigned long long (ULL)类型**：通常是64位，可以表示的范围是 0 到 18446744073709551615。\n\n这就是它们在一般情况下的表示范围，当然具体的范围也可以通过 `limits.h` 头文件中的常量来查看，比如 `INT_MAX`，`INT_MIN`，`ULLONG_MAX` 等。\n在C++中，通常情况下：\n\n1. **long long类型**：通常是64位，可以表示的范围是 -9223372036854775808 到 9223372036854775807（如果是无符号的话，则是 0 到 18446744073709551615）。\n\n这表示 long long 类型的符号和无符号版本的范围均在上述数值范围内。\n1万8千亿\n</code></pre>\n<hr>\n<h3>时间复杂度的判断</h3>\n<p>cpp 一秒 <code>10^7-10^8</code> 一千万到一亿次\n定义全局变量(数组 结构体)是不需要考虑到时间复杂度的 需要被考虑到空间复杂度\n程序时间复杂度 更多就是讨论关于 <code>int main()</code><strong>函数内部运行所需的时间</strong> 定义则近乎不需要时间\n在 C++中，对于静态数组（例如 int arr[10000]），它们的内存分配是在编译时进行的，\n因此在程序运行时不需要额外的时间来执行这个操作。编译器在编译阶段会为这样的静态数组分配内存，\n并将其放置在<strong>程序的静态存储区域</strong>中。因此，你在程序运行时访问这样的数组时，并不会有额外的时间开销用于进行内存分配。</p>\n<p>综上所述，在声明静态数组时，内存分配是在编译时完成的，因此在<strong>程序运行时不需要额外的时间来执行这个操作</strong>。</p>\n<hr>\n<h3>大 O 符号表示法</h3>\n<p>大 O 符号表示法（Big O notation）是用来描述算法时间复杂度或空间复杂度的一种数学符号。\n它给出了执行算法所需要的资源（通常是时间或空间）与输入大小之间的关系的上界。\n简而言之，大 O 符号用于表示算法性能和增长率，特别是在最坏情况或平均情况下的性能。</p>\n<p>核心概念</p>\n<ul>\n<li><p><strong>描述复杂度：</strong> 大 O 符号表示法描述的是<strong>算法复杂度的增长率</strong>，而不是具体的执行时间。这意味着它关注的是<strong>输入量增大</strong>时，算法的时间或空间需求增加的速度。</p>\n</li>\n<li><p><strong>屏蔽常数：</strong> 使用大 O 符号表示法时，<strong>忽略常数因子和低阶项</strong>。比如，$O(2n)$ 和 $O(n)$ 表达的意思是相同的，都表示算法的时间复杂度是线性增长的。同样，$O(n^2 + n)$ 简化为 $O(n^2)$。</p>\n</li>\n<li><p><strong>最坏情况分析：</strong> 虽然大 O 符号可以用于描述算法在不同情况下的时间复杂度（最坏情况、平均情况、最佳情况），但它最常用于描述最坏情况复杂度，因为这提供了一个性能保证。</p>\n</li>\n</ul>\n<p>示例</p>\n<ul>\n<li><strong>O(1)</strong>：常数时间复杂度，无论输入数据的大小，算法执行所需时间都是固定的。</li>\n<li><strong>O(log n)</strong>：对数时间复杂度，每次操作都将数据集减少一定比例，例如二分查找。</li>\n<li><strong>O(n)</strong>：线性时间复杂度，算法执行时间与输入数据的大小成正比，例如遍历一个数组。</li>\n<li><strong>O(n log n)</strong>：线性对数时间复杂度，许多高效的排序算法（如归并排序和快速排序）都处在这个级别。</li>\n<li><strong>O(n^2)</strong>：二次时间复杂度，算法执行时间与输入数据大小的平方成正比，例如简单的两层嵌套循环。</li>\n<li><strong>O(2^n)</strong>：指数时间复杂度，算法执行时间随输入数据大小指数级增长，例如解决旅行商问题的简单递归。</li>\n<li><strong>O(n!)</strong>：阶乘时间复杂度，算法执行时间随输入数据的大小的阶乘增长，这在实际应用中通常是不可行的。</li>\n</ul>\n<p>重要性</p>\n<h2>大 O 符号表示法是衡量和比较算法效率的重要工具，它允许<strong>开发者在不实际执行程序的情况下对算法的性能做出理论上的估计</strong>。这对于设计高效算法、优化现有算法和选择最适合特定问题的算法方案来说至关重要。通过理解算法的复杂度，开发者可以预测随着数据量的增加算法可能面临的性能挑战，并据此作出明智的决策。</h2>\n<h3>时间复杂度相加还是相乘</h3>\n<pre><code class=\"language-cpp\">/*\n当一个算法或者程序由多个步骤组成时，总的时间复杂度取决于这些步骤的组合方式。我们如何确定多步骤算法的总体时间复杂度，取决于这些步骤是如何相互关联的——它们是顺序执行的、还是嵌套执行的（比如循环内再嵌套循环）。\n\n### 顺序执行的步骤\n\n如果算法由多个步骤顺序执行，每个步骤有自己的时间复杂度，那么总的时间复杂度是这些步骤时间复杂度的和。然而，在大O表示法中，我们只关心影响最大的项，因为当输入规模足够大时，较小的项对总体性能的影响可以忽略不计。因此，**总的时间复杂度是各个步骤中最大那个时间复杂度**。\n\n例如，一个算法包含三个步骤，其时间复杂度分别是O(1)、O(n)和O(n^2)。虽然总的时间复杂度可以写作O(1) + O(n) + O(n^2)，但是在大O表示法中我们只关心随着n的增长哪个项增长最快，这里显然是O(n^2)。所以，总的时间复杂度取O(n^2)。\n\n### 嵌套执行的步骤\n\n如果算法中的步骤是嵌套执行的，比如在一个循环内部再执行一个循环，我们需要将嵌套步骤的时间复杂度相乘来得到总体的时间复杂度。\n\n例如，如果外部循环的时间复杂度是O(n)，并且它包含一个内部循环，内部循环的时间复杂度也是O(n)，那么整个算法的总时间复杂度是O(n) * O(n) = O(n^2)。\n\n### 时间复杂度的级别\n\n时间复杂度有不同的级别，这通常反映了算法处理数据的效率。以下是一些常见的时间复杂度，从最理想到最差排序：\n\n- O(1)：常数时间复杂度，执行时间不随输入大小变化。\n- O(log n)：对数时间复杂度，如二分查找。\n- O(n)：线性时间复杂度，如简单查找。\n- O(n log n)：线性对数时间复杂度，常见于高效的排序算法，如归并排序和快速排序。\n- O(n^2)：二次时间复杂度，如简单的排序算法（冒泡排序、选择排序、插入排序）。\n- O(n^3)：立方时间复杂度，某些简单的数学算法或暴力解法可能达到这个级别。\n- O(2^n)、O(n!)：指数时间和阶乘时间复杂度，对于可行性和可用性极为有限，在实际应用中通常是不可接受的。\n\n在评估一个算法或程序的效率时，理解和估算时间复杂度是至关重要的。对于实际应用，通常希望算法的时间复杂度尽可能低，以处理大量数据或复杂的问题。\n*/\n</code></pre>\n<hr>\n<h4>Yxc 原文摘录</h4>\n<p>一般 ACM 或者笔试题的时间限制是 1 秒或 2 秒。\n在这种情况下，C++代码中的操作次数控制在 $10^7 \\sim 10^8$ 为最佳。</p>\n<p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择：</p>\n<p>$n \\le 30$, 指数级别, dfs+剪枝，状态压缩 dp\n$n \\le 100$ =&gt; $O(n^3)$，floyd，dp，高斯消元\n$n \\le 1000$ =&gt; $O(n^2)$，$O(n^2logn)$，dp，二分，朴素版 Dijkstra、朴素版 Prim、Bellman-Ford\n$n \\le 10000$ =&gt; $O(n * \\sqrt n)$，块状链表、分块、莫队\n$n \\le 100000$ =&gt; $O(nlogn)$ =&gt; 各种 sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ 分治、整体二分、后缀数组、树链剖分、动态树\n$n \\le 1000000$ =&gt; $O(n)$, 以及常数较小的 $O(nlogn)$ 算法 =&gt; 单调队列、 hash、双指针扫描、BFS、并查集，kmp、AC 自动机，常数比较小的 $O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa\n$n \\le 10000000$ =&gt; $O(n)$，双指针扫描、kmp、AC 自动机、线性筛素数\n$n \\le 10^9$ =&gt; $O(\\sqrt n)$，判断质数\n$n \\le 10^{18}$ =&gt; $O(logn)$，最大公约数，快速幂，数位 DP\n$n \\le 10^{1000}$ =&gt; $O((logn)^2)$，高精度加减乘除\n$n \\le 10^{100000}$ =&gt; $O(logk \\times loglogk)，k表示位数$，高精度加减、FFT/NTT</p>\n<hr>\n<h4>判断时间复杂度的方法</h4>\n<p>1.判断循环次数 $O(n+m)$ 两维 $O(n^2)￥ [DP] 2.递归 主定理 [快排 归并排序]</p>\n<hr>\n<h4>典型例题分析</h4>\n<h4>基础算法</h4>\n<ol>\n<li><strong>快排</strong>[可能$(log n)$层 ] 归并排序 [一定$(logN)层]</li>\n<li><strong>二分</strong> 对半分 会迭代$O(logn)$次</li>\n<li><strong>双指针算法</strong> 两种循环 $O(n)$ 里边 j 只加不减</li>\n</ol>\n<h5>数据结构</h5>\n<ol>\n<li><strong>单链表</strong> O(1)删掉某个数 栈和队列 也都是 O1 的</li>\n<li><strong>单调栈</strong>/<strong>单调队列</strong> 看着是两层循环 但是每个元素最多进出栈一次 那么<code>--</code> 只会执行 O(n)次 所以是线性的</li>\n<li><strong>Kmp</strong> i 每增加 1 j 最多增加 1 j=ne[j]起码会减去 1 因此 Kmp 也是线性的</li>\n<li><strong>Trie</strong> 线性的</li>\n<li><strong>并查集</strong> 这个记住就可以了 我们有 <strong><em>路径压缩</em></strong> [ <strong><em>按秩合并</em></strong> ]的存在 并查集的时间效率就会变成 $(nlogn)$ [ $nloglogn$ ] 的效率 实际上最坏是$O(logn)$的</li>\n<li><strong>堆</strong> 返回最小值 $O(1)$ 插入 需要进行 <code>DOWN</code> 或者 <code>UP</code> 操作 [堆是一颗完全二叉树] 走到顶部 时间复杂度和堆的高度$O(logn)$成正比的 删除添加就是$O(logn)$</li>\n<li><strong>哈希表</strong> 最坏的是很坏 但是基本上几乎不会遇见(和小行星撞击地球的概率是一样的) 增删改查 平均效率是$O(1)$的</li>\n</ol>\n<h5>搜索与图论</h5>\n<p><strong><em>搜索的计算量</em></strong><br>算一下这个函数执行多少次就可以了</p>\n<ol>\n<li><strong>DFS</strong> -树根拓展 n 个点 拓展到最后一个点 最后一层的点共 $n!$个点 倒数第一层是 $(n-1)!$个点\n每层的计算量 最后一层输出答案需要$O(n)$ 最后一层是$n!n$ 倒数第一层 是 $(n-1)!n$ 总共 $(n!+(n-1)!+...)n$ 因为不是最后一层还是需要循环 n 都是乘以一个 n\n那么 由于相对于$n!$其他项都是无穷小量 总共效率就是 $n!n$</li>\n<li><strong>BFS</strong> 这两个都是画一棵树来看</li>\n<li><strong>树与图的深度优先遍历</strong> 图的方法 我们保证每个点只会遍历一次 那么效率 是 n 个点 每个点的边就是 遍历所有边 m 那么深度宽度优先遍历就是 $O(n+m)$</li>\n<li><strong>树与图的广度优先遍历</strong></li>\n<li><strong>拓扑排序</strong> 基于宽搜和深搜 所以都是 $O(n+m)$</li>\n<li><strong>Dijkstra</strong> -朴素 两种循环 $O(n^2)$ -堆优化版的 每个点只会被遍历一次 就是对每个点的所有边就是所有边 m 循环体内最多执行 m 次 插了 m 次总个数是 m 级别的 内层是 $mlogm$ 由于 $m \\le n^2$\n因此 $mlogm \\le 2mlogn$ 可以看成 $mlogn$的效率</li>\n<li><strong>bellman-ford</strong> 两重循环 总共$O(nm)$</li>\n<li><strong>spfa</strong> -最坏 $O(nm)$ 并且可以被卡 理论非常高 但是运行效率非常好 [ 二分图匈牙利 最大流算法] -判负环 mn 的 但是比求最短路要长很多 (两者看起来时间复杂度一样)</li>\n<li><strong>Floyd</strong> 三重循环 $O(n^3)$</li>\n<li><strong>Prim</strong> 两重循环 $O(n^2)$</li>\n<li><strong>Kruskal</strong> 有一个排序 $mlogm$ 还有个循环 $O(m)$ 所以整个时间复杂度是 $mlogm$</li>\n<li><strong>染色法判定二分图</strong> 图的深搜或者宽搜 效率是 $O(n+m)$</li>\n<li><strong>匈牙利算法</strong> 理论时间复杂度 每个点循环一次 需要$O(n)$ 判断的时候 需要判断所有点的所有边 这个时间效率就是$O(nm)$ 而 m 最坏是$n^2$ 所以匈牙利算法最坏是$O(n^3)$\n但是 实际上运行效率非常快</li>\n</ol>\n<p><code>long long</code> 范围的数是 $10^18$ 那么$log10^18$就是 64 有个小技巧就是 $(log_210^x\\approx3x)$\n那么 $(log_210^{18} \\approx54 \\approx60)$</p>\n<h5>数学知识</h5>\n<ol>\n<li><p><strong>质数</strong> -试除法 $2-\\sqrt(x)$ 那么时间复杂度就是$O(\\sqrt(x))$ -分解质因数 $O(\\sqrt(x))$ -筛质数 艾什筛法 $\\frac{n}{1}+\\frac{n}{2}+...+\\frac{n}{n}$ 后边是调和级数 =$lnn+c$ [c 是欧拉常数 0.577] 但是是$O(logn)$级别 那么总的时间复杂度就是 $O(nlogn)$ -补充一点 如果是 $\\frac{n}{2}+\\frac{n}{3}++\\frac{n}{5}+\\frac{n}{7}...+\\frac{n}{n}$ 近似等于 $O(loglogn)$</p>\n</li>\n<li><p><strong>约数</strong> 最大公约数 辗转相除法 背过 $O(logn)$级别的</p>\n</li>\n<li><p><strong>欧拉函数</strong></p>\n</li>\n<li><p><strong>快速幂</strong> $O(logK)$ 很好算</p>\n</li>\n<li><p><strong>扩展欧几里得算法</strong></p>\n</li>\n<li><p><strong>中国剩余定理</strong></p>\n</li>\n<li><p><strong>高斯消元</strong></p>\n</li>\n<li><p><strong>求组合数</strong></p>\n</li>\n<li><p><strong>容斥原理</strong></p>\n</li>\n<li><p><strong>博弈论</strong></p>\n</li>\n</ol>\n<h5>动态规划</h5>\n<p>动态规划除了看循环几层 还有一个常用的技巧</p>\n<h5>动态规划问题的计算量 = 状态数量 * 状态转移的计算量</h5>\n<ol>\n<li><strong>背包问题</strong> 循环几层 就是几次方</li>\n<li><strong>线性 DP</strong> 最长上升子序列 2 两重循环 外层 n 次 内层 $logn$次 所以整个效率是$O(nlogn)$次</li>\n<li><strong>区间 DP</strong></li>\n<li><strong>计数类 DP</strong></li>\n<li><strong>数位统计 DP</strong></li>\n<li><strong>状态压缩 DP</strong> 蒙德里安的梦想 外层循环 $2n^2$ 内层 $O(n)$ 所以总共就是 $O((2^n)^2n)$</li>\n<li><strong>树形 DP</strong> 没有上司的舞会 看着$O(n)$个状态 每个状态循环 1 次 看似$n^2$(dfs)的效率 但是每个点只会被遍历一次 就是把每个点的所有边遍历一次 就是所有边的数量 所以总共效率是$O(n)$ 线性的</li>\n<li><strong>记忆化搜索等内容</strong> 滑雪 两维 每个状态需要多少时间 4 次 O1 的时间 所以就是 $O(n^2)$</li>\n</ol>\n<p>动态规划这部分的解释都比较详细 可以看笔记</p>\n<h5>贪心</h5>\n<p>都是一个排序加一个循环 排序 logn 循环几层就是多少</p>\n<ol>\n<li><strong>区间问题</strong></li>\n<li><strong>Huffman 树</strong></li>\n<li><strong>排序不等式</strong></li>\n<li><strong>绝对值不等式</strong></li>\n<li><strong>推公式</strong></li>\n</ol>\n<h4>空间复杂度</h4>\n<p>64M</p>\n<pre><code>1 Byte=8 bit\n1 KB=1024 Byte\n1 MB=1024*1024 Byte\n1 MB=1024*1024*1024 Byte\n\nint = 4 Byte ==&gt; 64MB = 2^24 =&gt; 1千600万 程序的其他地方也要用空间 函数调用和库 不要恰好开满64MB空间 最多用到50M差不多了\nchar = 1 Byte\ndouble,long long =8 Byte\n指针 32是4 Byte 64是8 Byte\nbool 1 Byte 不是1位\n</code></pre>\n<p>流量是兆位 8M=&gt;1MB/s</p>\n<h3>统计方法</h3>\n<pre><code>int v[N],w[N];\nint f[N];\n\ncout&lt;&lt;(sizeof v+sizeof w+sizeof f)&lt;&lt;endl; ==&gt;12120Byte 字节\ncout&lt;&lt;(sizeof v+sizeof w+sizeof f)/1024&lt;&lt;endl; ==&gt;12120/1024  KByte 千字节\ncout&lt;&lt;(sizeof v+sizeof w+sizeof f)/1024/1024&lt;&lt;endl; ==&gt;12120/1024/1024  MByte 兆字节\n\n开了114M 但是没有爆内存呢 因为操作系统的优化 开了这么多 用的时候不会一下子都给你\n当你用到的的时候没有分配会马上给你分配一块 只开没有用的话 一般也没事\n</code></pre>\n<p>我们刷一遍一般就有事了 <code>memset(v/w/f,0,sizeof v/w/f)</code></p>\n<h3>栈空间</h3>\n<p>递归也是需要空间的\n快排没有多余数组 默认认为快排额外空间复杂度 $(O1)$的 归并是$O(n)$的 这样是不对的\n快排会递归$logn$层 所以快排额外空间是 $O(logn)$</p>\n<h3>无穷大的表示</h3>\n<p>在 C 和 C++中，<code>0x3f3f3f3f</code> 是一个十六进制数，它表示一个 32 位的整数，其中每个十六进制数字（<code>0x3f</code>）对应 8 位（一个字节）。因此，<code>0x3f3f3f3f</code> 在二进制中实际上是由四个连续的 <code>00111111</code>（即 <code>0x3f</code> 的二进制表示）组成，总共 32 位。</p>\n<p>这里的 <code>null</code> 变量被初始化为 <code>0x3f3f3f3f</code>，通常用作一个“无穷大”或“极大值”来表示数组 <code>h</code> 中的元素尚未被赋值或表示某种“不可用”状态。这个值通常用于初始化数组，以便在算法中通过比较操作来更新这些值。</p>\n<p>关于为什么使用 <code>0x3f3f3f3f</code> 而不是填充 32 个 1（即 <code>0xffffffff</code>），这通常是因为在某些算法中，<strong>我们想要使用一个大于任何可能的有效值的数作为初始值</strong>。<code>0xffffffff</code> 通常是 <code>int</code> 类型能表示的最大值（在大多数系统和编译器中，假设 <code>int</code> 是 32 位并且使用补码表示法）。但是，使用 <code>0x3f3f3f3f</code> 可以确保在更新过程中，如果通过加法或其他操作可能导致溢出，这个值仍然保持“极大”状态，从而避免意外的下溢到有效值范围。此外，它也允许在算法中使用负数值，因为 <code>0x3f3f3f3f</code> 是一个正数。</p>\n<p>至于“为什么不是填充 32 个 1”，这是因为填充 32 个 1 实际上会得到 <code>0xffffffff</code>，这是 <code>int</code> 类型能表示的最大值。在某些情况下，这可能不是一个好的初始值，因为它可能导致整数溢出问题，特别是在进行加法操作时。使用 <code>0x3f3f3f3f</code> 可以提供一个相对较大的初始值，同时保留一定的空间用于加法操作而不会立即溢出。</p>\n<p>最后，需要注意的是，选择这样的初始值通常取决于具体的算法和数据范围。在某些情况下，使用 <code>0xffffffff</code> 或其他值可能是合适的，但在其他情况下，使用 <code>0x3f3f3f3f</code> 或其他特定的“极大”值可能更为合适。</p>\n<h4>关于 0x3f3f3f3f 的数值</h4>\n<p>执行上述代码会输出 <code>null</code> 的十进制值。计算结果为 <code>1061109567</code>。因此，<code>null</code> 转化为 <code>int</code> 的十进制数值是 <code>1061109567</code>。\n刚好是 10^9 次方 也就是 10 亿</p>\n<h3>Sizeof 的单位</h3>\n<p><code>sizeof</code> 是 C 和 C++ 语言中的一个运算符，用于获取类型或对象在内存中的大小（以字节为单位）。对于数组，<code>sizeof</code> 会返回整个数组的大小，而不是数组中元素的数量。</p>\n<p>例如，如果你有一个数组 <code>int a[100];</code>，<code>sizeof(a)</code> 会返回整个数组的大小，即 <code>100 * sizeof(int)</code> 字节（具体大小取决于你的平台和编译器，因为 <code>int</code> 的大小可能不同）。</p>\n<p>如果你想获取数组的元素数量（在这个例子中是 100），你需要手动进行除法操作。但是要注意，当你对数组名进行 <code>sizeof</code> 操作时，你得到的是整个数组的大小，所以你需要除以单个元素的大小。这里是一个例子：</p>\n<pre><code class=\"language-c\">#include &lt;stdio.h&gt;\n\nint main() {\n    int a[100];\n    size_t num_elements = sizeof(a) / sizeof(a[0]);\n    printf(&quot;%zu\\n&quot;, num_elements);  // 输出 100\n    return 0;\n}\n</code></pre>\n<p>在这个例子中，<code>sizeof(a)</code> 返回整个数组的大小（以字节为单位），<code>sizeof(a[0])</code> 返回数组中单个元素的大小（以字节为单位）。将两者相除，就得到了数组的元素数量。注意这里使用了 <code>%zu</code> 格式说明符来打印 <code>size_t</code> 类型的值，这是 <code>sizeof</code> 运算符返回的类型。</p>\n<h3>时间复杂度 LogN 底数问题</h3>\n<p>不是任意算法问题的时间复杂度都是以 2 为底来衡量的。选择哪个数作为对数的底取决于具体的问题和算法。然而，在计算机科学中，当我们说某个算法的时间复杂度是 O(log n)时，我们通常不特指对数的底数。这是因为对于任何以常数 a 为底的对数函数 log_a(n)，它都可以转换为以任意其他常数 b 为底的对数函数，只是多了一个常数系数。由于我们在分析算法时间复杂度时通常关注渐近行为，即随着输入规模 n 的增大，时间复杂度如何变化，因此这个常数系数是可以忽略的。</p>\n<p>例如，如果我们有一个算法的时间复杂度是 O(log_10(n))，**这实际上与 O(log_2(n))是等价的，因为两者都表示算法的运行时间随着输入规模的对数级增长。**因此，在描述算法时间复杂度时，我们通常省略底数，只写 O(log n)，以强调算法的时间复杂度与输入规模的对数成正比。</p>\n<p>需要注意的是，有些算法的时间复杂度可能涉及其他类型的对数或数学函数，例如 O(n log n)、O(n^2)、O(2^n)等。这些复杂度表达式反映了算法在不同情况下的性能特点，而底数的选择则取决于具体问题和算法的实现方式。</p>\n<p>总结来说，虽然计算机科学中经常使用 O(log n)来表示某些算法的时间复杂度，并且不特指对数的底数，但底数的选择并不是任意的，它取决于具体算法和问题的性质。在实际应用中，我们需要根据具体情况来选择合适的数学工具和表达方式来描述算法的性能。</p>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-03-21-10:45:56(星期四)</em></span></p>\n"},{"id":13,"title":"每次点击的地址","date":"2024-04-24","content":"<p><a href=\"https://www.acwing.com/blog/content/34691/\">回退到导航分享页</a></p>\n<ul>\n<li><a href=\"https://v5.bootcss.com/\">Bootstrap地址</a></li>\n<li><a href=\"https://baomidou.com/\">MyBatis-Plus</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/\">Mdn</a></li>\n<li><a href=\"https://mvnrepository.com/\">Maven仓库</a></li>\n<li><a href=\"https://www.axios-http.cn/\">Axios</a></li>\n<li><a href=\"https://www.runoob.com/\">菜鸟</a></li>\n<li><a href=\"https://semantic-ui.com/\">semantic-ui</a></li>\n<li><a href=\"https://stackoverflow.com/\">Stackoverflow</a></li>\n<li><a href=\"https://www.iconfont.cn/\">阿里iconfont</a></li>\n</ul>\n<hr>\n<h3>markdown</h3>\n<pre><code>[网址名](实际网址)\n</code></pre>\n<pre><code>填充内容区域\n\n其他语法使用acwing编辑区完成\n</code></pre>\n<hr>\n<p><strong>敲代码</strong></p>\n<ul>\n<li><p>UserAccountLoginView -&gt;打Userl(关键字+特有字母)  快速补全</p>\n</li>\n<li><p>如果鼠标左边是括号的一部分 这时候括号就会变黄\n 直接点击分号<code>;</code>就可以结束语句 而不用再一次点击括号\n 直接输入大括号也会自动分开</p>\n</li>\n<li><p>使用<code>ctrl</code>+<code>方向键</code>用来跳至间隔符 </p>\n</li>\n<li><p>使用<code>ctrl</code>+<code>backspace</code>用来删除到下一个间隔符</p>\n</li>\n</ul>\n<hr>\n<p><strong>敲键盘</strong></p>\n<ul>\n<li><p><code>alt按住</code>+<code>左键</code> 复制并放置光标</p>\n</li>\n<li><p><code>选中</code>-&gt;<code>ctrl</code>+<code>左键拖动</code>  拖动选中并复制/这里并不占用剪切板</p>\n</li>\n<li><p><code>shift</code>+<code>tab</code> 反向制表</p>\n</li>\n<li><p><code>左键双击</code> 选中至分割符 或者全句</p>\n</li>\n</ul>\n<hr>\n<h3>敲中文</h3>\n<p>打字总是打不到想要的那个字</p>\n<p>多用+号选出来 只打词语每次都会遇见这种情况</p>\n<hr>\n<h3>笔记查询</h3>\n<p>关键字</p>\n<pre><code>注意 一定\n</code></pre>\n<hr>\n<p><strong>自动补全</strong></p>\n<p><code>div.row&gt;div.col-3*3</code> + <code>Tab</code>/<code>Enter</code> 补全为</p>\n<pre><code>&lt;div class=&quot;row&quot;&gt;\n    &lt;div class=&quot;col-3&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;col-3&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;col-3&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<hr>\n<h3>vue3</h3>\n<pre><code>import { ref, reactive } from &#39;vue&#39;;\nimport $ from &#39;jquery&#39;\nimport { useStore } from &#39;vuex&#39;;\nimport router from &#39;@/router&#39;;\n</code></pre>\n<p>绑定</p>\n<pre><code>input v-model=&quot;username&quot;\n</code></pre>\n"},{"id":14,"title":"经验总结","date":"2024-04-18","content":"<h3>常用STL</h3>\n<p>[pair&lt;int,int&gt;]优先左端点排序 单元  - <strong>常见于坐标存储</strong>\n[string]\n[vector] vector基本容器 动态数组 倍增思想 连续存储 随机访问比较高效  - <strong>不定长数组</strong>\n[queue] 队列先进先出 前边出 pop/top 后边进 push - <strong>常见bfs</strong>\n[priority_queue]优先队列 (大根堆默认 小根堆 <code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;</code> ) - <strong>常用于一个序列里边最大最小值(贪心)</strong>\n[stack]栈\n[deque]双端队列 两边 push_front push_back进入 pop_back pop_front退出\n[set/map/multiset/multimap]集合映射 值,键值对,默认有序不可重复 后边\n[unordered_set/unordered_map]哈希表 一个是集合(值) 一个是map键值对 查询时间平均O(1) - <strong>常用于统计是否出现过count</strong>\n<a href=\"#bitset\">bitset</a> 长度自定义的01串 </p>\n<h3>常用函数</h3>\n<pre><code class=\"language-cpp\">/*\n\n*/\n\n#include &lt;cstring&gt;\nmemset(h,0x3f,sizeof h);\n\n\nbool cmp(PII a,PII b){//用除法的话可能有精度问题 可以乘上去 \n    return a.y*b.x&lt;a.x*b.y;\n}\nsort(q,q+cnt,cmp);\n</code></pre>\n<h3>数值范围</h3>\n<p>当涉及到复杂的算法描述时，使用 LaTeX 可以更好地展示数学公式和文字排版。这是一个包含多种算法复杂度描述的示例：</p>\n<ol>\n<li>当 ( n \\leq 30 ) 时<blockquote>\n<p>指数级别，DFS+剪枝，状态压缩DP</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 100 ) 时，( O(n^3) )<blockquote>\n<p>（Floyd，DP，高斯消元）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 1000 ) 时，( O(n^2) ) $O(n^2log{n})$<blockquote>\n<p>（DP，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10000 ) 时，( O(n \\cdot \\sqrt{n}) )<blockquote>\n<p>（块状链表、分块、莫队）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 100000 ) 时，( O(n \\log n) )<blockquote>\n<p>（各种sort，线段树、树状数组、set/map、heap、拓扑排序、Dijkstra+heap、Prim+heap、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 1000000 ) 时，( O(n) ) 以及常数较小的 ( O(n \\log n) ) 算法<blockquote>\n<p>（单调队列、hash、双指针扫描、BFS、并查集，KMP、AC自动机）\n常数较小的$O(nlogn)$的做法:Sort 树状数组  heap dijkstra spfa</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10000000 ) 时，( O(n) )<blockquote>\n<p>（双指针扫描、KMP、AC自动机、线性筛素数）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10^9 ) 时，( O(n\\sqrt{}) )<blockquote>\n<p>（判断质数）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10^{18} ) 时，( O(\\log n) )<blockquote>\n<p>（最大公约数，快速幂，数位DP）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10^{1000} ) 时，( O((\\log n)^2) )<blockquote>\n<p>（高精度加减乘除）</p>\n</blockquote>\n</li>\n<li>当 ( n \\leq 10^{100000} ) 时，( O(\\log k \\times \\log \\log k) )，( k )表示位数<blockquote>\n<p>（高精度加减、FFT/NTT）</p>\n</blockquote>\n</li>\n</ol>\n<p>以上内容来自 <a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/3074/\">AcWing</a>。</p>\n<hr>\n<h3>经验</h3>\n<pre><code class=\"language-cpp\">/*\n1. 1&lt;n&lt;100 1&lt;ai&lt;2*10^9 //20亿 结果直接 LL \n2. 有ST[N]数组(爆搜 要用st标记这个状态有没有被用过) 多组测试数据 要清空st(飞机降落) st必须是全局数组 才能递归处理共用一个数据 那么多组数据一定要清空\n3. 常用max和min函数 这个可以省略很多if判断(优化也是的)\n4. 常用结构体 飞机多个属性 但是是有一个总体叫做飞机 没必要开多个数组 \n5. return (left + right) / 2.0; //这里必须除以 2.0 否则会取证 中位数\n6. 整除的性质 [a/b]=c 那么 a/b的值 在 [c,c+1) 的范围内\n7. 下标问题 if (nums1.size() == i) return nums2[j + k - 1];//那么第k个数就是 j+k-1 k从1开始 当k=1的时候应该返回numsj\n*/\n</code></pre>\n<hr>\n<h3>常用的特殊数字</h3>\n<pre><code class=\"language-cpp\">/*\n*/\nint st=-2e9,ed=-2e9;//-20亿 这个是几乎不可能出现的值 用来做无效值 区间合并 初始值设置为这个\ntypedef offset 1e-7;//近似为0 处理浮点数问题\nconst int N=200003,null=0x3f3f3f3f;//近乎无穷大 0x3f3f3f3f 就是109次方量级的 比109略 模拟Hash三链表\nconst int N=100010,P=131;//13331 字符串匹配的Hash质数\n</code></pre>\n<h3>常用数据结构</h3>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\nvector&lt;int&gt; a;// a.push_back(),a.pop(),a.top(),a.size();\n#include &lt;algorithm&gt; //sort(arrayName,arrayName+array.lengt)\ntypedef pair&lt;int,int&gt; PII;//PII mypair;mypair.push_back({l,r});mypair.size();\n//mypair.first,mypair.second,sort函数对pair 对first进行排序\n#include &lt;unordered_map&gt;\nunordered_map&lt;char,int&gt; pr{{&#39;+&#39;,1},{&#39;-&#39;,1},{&#39;*&#39;,2},{&#39;/&#39;,2}};//表达式求值\n\n\npriority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; heap.push({0,1});heap.top();heap.pop();\n\n</code></pre>\n<h3>常用技巧</h3>\n<pre><code class=\"language-cpp\">/*\n1. vector&lt;int&gt; add(vector&lt;int&gt;&amp;A,vector&lt;int&gt;&amp;B){ // 数组整数 &amp; 表示只是拿来地址 不需要额外的copy一遍 更快\n2. auto c=sub(b,a); printf(&quot;-&quot;); //尽量减少负数的出现 特别输出就可以\n3.输入的数据是1000000 推荐使用scanf 前缀和下标都要从1开始\n4. puts(&quot;&quot;);//输出一个空行\n5. cout&lt;&lt;a.size()/a[0]&lt;&lt;endl;//输出数组的长度\n6. PII segs;sort(segs.begin(),segs.end());\n7. //优化 ios::sync_with_stdio(false)//关闭scanf 和 cout的同步 只能用一种 优化事件 程序开始时调用\n8. O2优化 启用进一步的优化，不仅包括 -O1 中的优化，还有诸如删除未使用的代码和变量、循环优化等。在不牺牲太多编译时间的情况下，尽可能提高程序运行效率。\n9. 一次申请足够空间 并且预处理和准备好数据 可以显著提高程序运行速度 处理大量数据的\n10. 字符串Hash的哈希基 P=131和13331可以显著减少哈希碰撞\n11. memset 和 copy 等初始化操作 时间很快\n12.浮点数 要求保留6位 就取10^-8 如果保留4位 就取10^-6\n13. printf()默认保留六位小数 输出l和r都是可以的 因为这两个数足够接近 790 数的范围\n14. 一定注意层数 q[i]=q[i-1]+q[i];//q[i-1]是最新的 q[i]是旧的\n15. int k=(x%N+N)%N;映射到Nn//模拟散链表\n16. memset(h,0x3f,sizeof h);//这里h 是填充的内存块 一般是用来填充string的 但是数组也可以\n17. char s[N];cin&gt;&gt;(s+1);\n18. 约数个数 分解质因数 我们不能用数组了 因为我们只知道某个质数存在 不知道范围 用unordered_map&lt;int,int&gt; primes;priems[i]++; i(质因数)就是第一个 primes[i].value=second就是次幂 遍历通过for(auto prime:primes) res=res*(prime.second+1)%mod;\n19. 需要取模的答案 直接使用 unsigned long long 答案可能用int就压根不对\n20. 三目运算符 condition?true:false;gcd\n21. 遇见分数 一定要先除法 再乘法 要不然容易溢出 Erlua\n22. 输出有负数 溢出了\n23. 中间过程有可能溢出(2*10^9) int a=(LL)b*b%p;\n24. 递归过程中函数使用同一个变量 取地址(exgcd)\n25. 只定义没有赋值操作 的特例 exgcd\nwhile(n--){\n        int a,b,x,y;\n        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);\n        exgcb(a,b,x,y);//内部取地址 传参正常传\n        printf(&quot;%d %d\\n&quot;,x,y);\n}\n26. 有返回值但是并没有接受的算法||底层得到数据 顶层不传递的算法 exgcd\n27. 数字三角形 DP 从1开始 0也要用初始化INF=1e9 三角形转XY轴 注意看输入 那个竖着是n 横向是i 不要看原图 容易混淆 所以初始化 要多一个\n28. typedef 是用来声明别名的 不是用来声明变量的 变量类型和结构体\n29. 输出 20 25=&gt;区间 冶炼金属\n30. sort(p+1,p+n+1,[&amp;](int x,int y){//我们将p当作下标 并且根据他在a当中的值来排序\n        return a[x]&lt;a[y];//任意两个元素 p[1]=x p[2]=y  a[p[1]]&lt;a[[p2]] p有序 是p作为下标 在a中有序\n});\n31. 孤独的牛 \n32. mod N 数据范围为 0~N-1\n</code></pre>\n<h3>数组空间</h3>\n<p>64MB 空间为例 数组范围为 最多开 1600 万 超过范围就报 MLE</p>\n<h3>时间约束</h3>\n<p>1S 为例 c++1s 钟最多运算 1 亿次</p>\n<h3>一次运算的含义</h3>\n<pre><code class=\"language-js\">/*\n对于时间复杂度来说 \n需要额外主义的就是 对于c++所有的运算 只要是可以记录类型的变量 例如 int 10^9次方 logn long 10^18 或者double  的计算 包括加减乘除\n时间复杂度通常都认为是 O(1)的 这意味着无论变量长度如何 这些基本运算的时间消耗都是固定的\n而高精度类型是需要额外计算的 通常高精度的长度为 1≤整数长度≤100000 显然这是需要额外进行操作才能处理好的\n\n时间都咋读主要取决于算法的逻辑 热不是使用数据的类型 时间复杂度评估算法执行时间如果随着输入规模增长的一个度量 基于执行的基本操作数量\n决定\n*/\n</code></pre>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-04-01-11：16：14（星期一）</em></span></p>\n"},{"id":15,"title":"题目总结1","date":"2024-04-12","content":"<h2>总结</h2>\n<hr>\n<h3>next_permutation<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p><code>next_permutation()</code> 是一个 C++ STL 中的函数，可以用于生成下一个排列。在组合优化或者排列组合的问题中，<code>next_permutation()</code> 经常被用来逐个生成所有可能的排列。这个函数会将给定序列重新排列为字典序中的下一个排列，如果存在下一个更大的排列，则返回 <code>true</code>；如果当前排列已经是最大的排列，则会将序列按递增排序，并返回 <code>false</code>。</p>\n<p>当联合使用DFS（深度优先搜索）和 <code>next_permutation()</code> 时，可以在组合优化问题中生成所有排列并进行相应的搜索，以找到满足条件的解。通过 <code>next_permutation()</code> 可以方便地遍历所有排列，而 DFS 则可以在每个排列上进行进一步的搜索或判断。这样结合使用可以有效地解决很多排列组合问题。</p>\n<hr>\n<h3>cin.tie(0)<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p>取消cin和cout的绑定 </p>\n<p>在 C 语言中，scanf()函数用于从标准输入（比如键盘）读取用户输入数据，而printf()函数则用于在标准输出（比如屏幕）上显示输出。在使用 scanf() 和 printf() 进行输入和输出时，并没有像cin 和 cout 相关的缓冲区刷新机制来确保输入和输出的同步。</p>\n<p>有时候使用printf并不能保证屏幕上显示输出 需要手动刷新</p>\n<p>flush()：刷新输出缓冲区，确保数据被输出。\ntie(0)：取消输入和输出流之间的关联。\nrdbuf() 和 wbuf()：访问输入和输出流的底层缓冲区</p>\n<p>C++标准库设计时考虑了程序的同步操作。当用户从控制台输入数据时，可能需要看到相应的提示信息或输出结果。因此，为了确保用户能及时看到输出信息，cin 会刷新 cout，以确保输出缓冲区中的内容被输出。</p>\n<hr>\n<h3>Trie 字符串和 Hash 字符串<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p>Trie 树可以共享<strong>公共前缀</strong>，\n这使得它们在处理有大量公共前缀的字符串集合时非常高效。\nHash 字符串\n<strong>快速访问</strong>: 在理想情况下（即没有或很少发生哈希冲突时），\n哈希表的插入和查询操作的平均时间复杂度接近 O(1)。\n但最坏情况下，如果所有元素都发生冲突，时间复杂度会退化到 O(n)。\n<strong>用途</strong>: Trie 树特别适用于实现字典和自动补全等功能，因为它们可以高效地处理前缀搜索和排序问题。\n哈希表则适用于那些需要快速访问、插入和删除操作，且不涉及前缀搜索的场景。\n<strong>性能</strong>: Trie 树的性能主要依赖于字符串的平均长度，而哈希表的性能则依赖于哈希函数的质量和处理冲突的策略。\n<strong>空间效率</strong>: Trie 树在处理有大量共享前缀的字符串集合时可能更加空间高效，而哈希表则可能因为要处理冲突而需要额外的空间。</p>\n<hr>\n<h3>脱离循环大量插入数据<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p>如果您希望在不使用循环的情况下一次性插入大量数据，可以根据使用的编程语言或数据结构采用不同的方法。对于 C++来说，有几种方法可以实现这一点，特别是当涉及到如<code>std::vector</code>这类容器时。以下是一些常见的方法：</p>\n<ol>\n<li>初始化时直接赋值</li>\n</ol>\n<p>当创建一个容器时，可以直接在初始化时赋予其大量的数据：</p>\n<pre><code class=\"language-cpp\">std::vector&lt;int&gt; myVector = {1, 2, 3, 4, 5, /* 这里可以是成千上万的数据 */};\n</code></pre>\n<ol start=\"2\">\n<li>使用<code>std::copy</code></li>\n</ol>\n<p>如果数据来源于另一个容器或数组，可以使用<code>std::copy</code>函数配合插入迭代器来复制数据：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n#include &lt;algorithm&gt; // for std::copy\n\nint sourceArray[] = {1, 2, 3, 4, 5};\nstd::vector&lt;int&gt; myVector;\n\n// 复制数组到vector中，不使用循环\nmyVector.reserve(sizeof(sourceArray)/sizeof(sourceArray[0])); // 优化分配空间\nstd::copy(std::begin(sourceArray), std::end(sourceArray), std::back_inserter(myVector));\n</code></pre>\n<ol start=\"3\">\n<li>使用<code>std::vector::insert</code></li>\n</ol>\n<p>对于<code>std::vector</code>和其他容器，可以使用<code>insert</code>方法同时插入多个元素：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\nstd::vector&lt;int&gt; anotherVector = {6, 7, 8, 9, 10};\nstd::vector&lt;int&gt; myVector;\n\n// 一次性插入另一个vector的所有元素，不使用循环\nmyVector.insert(myVector.end(), anotherVector.begin(), anotherVector.end());\n</code></pre>\n<ol start=\"4\">\n<li>列表初始化后使用<code>assign</code></li>\n</ol>\n<p>你还可以在容器创建后，用<code>assign</code>方法给它分配一个新的元素列表：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n\nstd::vector&lt;int&gt; myVector;\nmyVector.assign({1, 2, 3, 4, 5, 6, 7, 8, 9, 10});\n</code></pre>\n<ol start=\"5\">\n<li>使用<code>std::initializer_list</code></li>\n</ol>\n<p>对于自定义的类或数据结构，可以通过接收一个<code>std::initializer_list</code>作为构造函数的参数来实现一次性插入大量数据的功能：</p>\n<pre><code class=\"language-cpp\">#include &lt;vector&gt;\n#include &lt;initializer_list&gt;\n\nclass MyContainer {\npublic:\n    std::vector&lt;int&gt; data;\n    MyContainer(std::initializer_list&lt;int&gt; list) : data(list) {}\n};\n\nMyContainer myContainer = {1, 2, 3, 4, 5};\n</code></pre>\n<p>利用以上方法，即便没有使用循环语句，也可以高效地一次性向数据结构中插入大量数据，这对于<strong>初始化或批量更新操作</strong>非常有用。</p>\n<hr>\n<h3>处理大量数据的优化选择<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p>这句话指的是在进行大量数据处理时，批量处理相比于单次处理每一个元素可以显著提高效率。特别是在涉及到数据结构如数组、向量（vector）、列表（list）等的<strong>初始化或更新</strong>时，一次性完成大批量的操作，而不是逐个元素进行操作，可以大幅度减少执行时间。这里的语境似乎是在讨论性能优化的策略，我们可以从两个方面来理解这段话：</p>\n<p>执行时间与性能优化</p>\n<p>当你对一个数据结构（如 vector）进行多次单独的插入操作时（例如，在循环中插入 1000 次），每次插入都可能涉及到内存分配、数据移动等成本。如果容量不足，还可能触发重新分配内存和数据复制的过程。这些过程都会导致时间开销。因此，当你一次性插入大量数据时（比如一次性插入 1000 个元素），这些开销可以显著减少，因为容器（如 vector）可以优化内存分配和数据移动的策略，从而减少总体的时间成本。</p>\n<p>初始化与查询效率</p>\n<p>这段话还提到，“尽量直接初始化执行计算，之后 O(1)就可以得到查询的数”，这意味着通过预先计算和准备好数据，使得后续的查询操作可以非常高效地执行。O(1)表示常数时间复杂度，是指无论数据规模如何，操作所需的时间都是固定的。这样的效率通常是<strong>通过空间换时间的策略实现的</strong>，<strong>即通过预先计算和存储结果</strong>，以便查询时直接访问，无需再进行任何计算。</p>\n<p>综合理解</p>\n<p>综上所述，这句话的核心建议是在处理大量数据时寻找批量处理的机会，以及事先进行计算和初始化，从而在后续操作中实现高效的数据处理和查询。这种方式特别适合于那些预处理之后能大大简化查询操作的场景，可以大幅提高程序的总体性能和效率。</p>\n<hr>\n<h3>离散化和 Hash 的主要区别<a href=\"#%E6%80%BB%E7%BB%93\">^</a></h3>\n<p>离散化和哈希（Hashing）是解决算法问题时常见的两种技术，它们虽然都可以用于处理数据的映射问题，但用途和目的有所不同。下面是离散化和哈希的主要区别：</p>\n<p>离散化是指将一组具有某种顺序关系或可比性的原始数据映射到一个较小的、去除了间隙的、连续的整数区间上。这种技术主要用于处理数据规模过大或数据间隙过大的问题，使得原始数据可以在较小的范围内进行有效的表示和处理。离散化常用于算法中对数据进行压缩，以适应特定算法或数据结构的需求，如树状数组、线段树等。</p>\n<p>例如，如果有一组数据 <code>[100, 10000, 1000000]</code>，直接处理这组数据可能非常低效。通过离散化，可以将这组数据映射为 <code>[1, 2, 3]</code>，从而简化问题。</p>\n<p>哈希是一个通过哈希函数将输入（可能是任何大小的数据）转换为固定大小的值（哈希值）的过程。这个哈希值作为数据在哈希表中的索引，用于快速查找、插入和删除操作。哈希的主要目的是实现数据的高效映射和访问，尤其是在不关心数据顺序时。哈希能够提供接近常数时间复杂度的数据访问速度，但可能会遇到哈希冲突的问题，即不同的输入数据经过哈希函数处理后得到相同的哈希值。</p>\n<ul>\n<li><strong>目的和应用</strong>：<strong>离散化主要用于数据规模压缩和映射</strong>，以适应特定数据结构或算法，<strong>侧重于保持数据的相对顺序或比较性</strong>；而哈希用于高效的<strong>数据查找、插入和删除</strong>，侧重于快速访问。</li>\n<li><strong>处理数据的方式</strong>：离散化通过压缩数据的规模并保持其原有的顺序关系；哈希则通过哈希函数将任意大小的数据映射到固定大小的值（哈希值）上，不保证数据之间的顺序关系。</li>\n<li><strong>可能遇到的问题</strong>：离散化可能需要额外的空间和时间来进行排序和映射；哈希则可能会遇到哈希冲突，需要通过合适的解决冲突策略来处理。</li>\n</ul>\n<p>总结来说，离散化和哈希都是处理数据映射的有用技术，但它们适用于不同的问题和场景。选择哪一种技术取决于具体问题的需求和限制。</p>\n<h1>问题</h1>\n<p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\">Edit by</span><em style=\"color: rgba(91, 255, 247, 0.65);\">@02sDarling</em></p><p style=\"text-align:right\"> <span style=\"font-size: small; color: rgba(128, 128, 128, 0.5);\"><em>2024-04-02-21：20：59（星期二）</em></span></p>\n"}];