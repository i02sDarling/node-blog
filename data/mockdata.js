module.exports = [{'id': 1, 'title': 'Webpack_key', 'date': '2024-03-29', 'content': '### TravisCl\n\n---\n\n### ScopeHoisting\n\n---\n\n### treeshaking\n\n---\n\n### chunkHash\n\n---\n\n### SourceMap\n\n---\n\n### IIFE\n\n在 ES6 之前，ECMAScript 并没有提供代码组织的方式，那时候通常是基于 IIFE 来实现“模块化”，随着 JavaScript 在前端大规模的应用，以及服务端 Javascript 的推动，原先浏览器端的模块规范不利于大规模应用。于是早期便有了 CommonJS 规范，其目标是为了定义模块，提供通用的模块组织方式。\n\n---\n\n### 冷启动\n\n---\n\n### HMR 热更新\n\n### SPA 与 MPA\n\n### SEO\n\n### FCP\n\n**首屏加载时间对应的专属名词是首屏时间（First Contentful Paint，简称 FCP）**。它指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间。此时，整个网页不一定需要全部渲染完成，但需要展示当前视窗需要的内容。首屏加载时间对于用户体验至关重要，因为它直接关系到用户首次看到网页内容所需的时间。因此，优化首屏加载时间是提升网站性能和用户体验的重要一环。\n考虑首屏加载因素的原因主要有以下几点：\n\n1. **用户体验**：用户期望在打开网页时能够快速看到内容。如果首屏加载速度过慢，用户可能会感到不耐烦并选择离开网页。因此，优化首屏加载可以提高用户满意度，增加网站的访问量。\n2. **降低跳出率**：首屏加载时间过长可能会导致用户在等待期间离开网页，这种现象被称为“跳出”。通过减少首屏加载时间，可以降低跳出率，使更多用户留在网站上浏览内容。\n3. **搜索引擎排名**：搜索引擎会根据网页加载速度来评估网站的质量。较快的首屏加载速度有助于提升网页在搜索结果中的排名，从而增加网页的可见性和流量。\n4. **减少服务器负载和带宽消耗**：如果首屏加载速度过慢，用户可能会多次刷新页面，导致服务器负载过高，带宽消耗过大。优化首屏加载可以有效减少这种情况，提高网站的稳定性和可靠性。\n\n综上所述，考虑首屏加载因素对于提升用户体验、增加网站访问量、提高搜索引擎排名以及减少服务器负载和带宽消耗都具有重要意义。因此，在网页设计和开发中，优化首屏加载是一个不可忽视的方面。\n\n# This title\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-23-22：41：42（星期六）</em></span></p>\n'}, {'id': 2, 'title': 'Webpack_question', 'date': '2024-03-29', 'content': '### commonjs 和 es6 的本质\n\n保存为单个页面\n[CommonJs 不是前端却革命了前端](https://zhuanlan.zhihu.com/p/113009496)\n当我们说“ES6 模块系统的底层实现也是基于 JavaScript 的”，我们是指 ES6 模块系统是 JavaScript 语言规范的一部分，它并没有引入一个全新的编程语言来作为它的底层。相反，它是通过扩展 JavaScript 的语法和功能来实现的。ES6 模块系统使用 JavaScript 的语法来定义模块的导入和导出，而这些语法在 JavaScript 引擎（如 V8、SpiderMonkey 等）中得到了实现。\n\nES6（ECMAScript 2015）确实是 JavaScript 的一个新版本，它带来了许多新的特性和改进。这包括新的语法、新的内置对象和方法，以及模块系统。但是，ES6 仍然是 JavaScript，它并不是一种全新的语言。它只是在原有的 JavaScript 基础上进行了扩展和增强。\n\nCommonJS 模块系统是基于较早期的 JavaScript 版本实现的，特别是那些在 Node.js 环境中广泛使用的版本。Node.js 最初使用 CommonJS 作为模块规范，因为当 Node.js 刚出现时，ES6 模块系统还未被标准化和广泛支持。因此，CommonJS 是基于 Node.js 诞生时或之前可用的 JavaScript 版本实现的。\n\n总结来说：\n\n- ES6 模块系统是 JavaScript 语言规范的一部分，它基于 JavaScript 的语法和功能来实现，没有引入新的底层语言。\n- ES6 是 JavaScript 的一个新版本，它扩展了 JavaScript 的功能和语法，但仍然是 JavaScript。\n- CommonJS 是基于较早期的 JavaScript 版本实现的模块系统，特别是在 Node.js 环境中。\n\n### js 是什么东西\n\n在现代 Web 开发中，当我们提及 JavaScript（JS）时，确实，JS 本身并不会在本地运行，而是需要由浏览器进行解释或编译执行。浏览器提供了一个 JavaScript 引擎（例如 Chrome 的 V8 引擎），这个引擎负责读取和执行 JS 代码。\n\n与 C++等编译型语言不同，JavaScript 是一种解释型语言。这意味着 JS 代码在执行前不需要先被转换为机器码。相反，浏览器会一边读取 JS 代码，一边解释并执行它。当然，为了优化性能，现代 JavaScript 引擎也会使用即时编译（JIT）技术将经常执行的代码段转换为机器码。\n\n另外，你提到的“JS 只是一种规范”是准确的。JavaScript 是基于 ECMAScript 规范的，这个规范定义了 JS 语言的核心语法和功能。不同的浏览器和 JavaScript 引擎可能会有些许差异，但它们都致力于遵循这个规范，以确保 JS 代码的一致性和可移植性。\n\n因此，可以说 JS 本身并没有像 C++那样的底层语言。它的执行完全依赖于浏览器提供的 JavaScript 引擎，而这个引擎则是基于浏览器内核的一部分。不同的浏览器可能会有不同的 JavaScript 引擎实现，但它们都遵循相同的 ECMAScript 规范来执行 JS 代码。\n\n### commonjs 和 es6\n\nCommonJS 和 ES6 模块系统之间存在一些关键差异，这些差异主要体现在语法、加载方式、值的处理以及使用场景等方面。\n\n1. **语法差异**：\n\n   - CommonJS 使用`require`来导入模块，并使用`module.exports`或`exports`来导出模块。\n   - ES6 模块则使用`import`来导入模块，使用`export`或`export default`来导出模块。\n\n2. **加载时机**：\n\n   - CommonJS 模块是在代码运行时加载的，这意味着当`require`一个模块时，模块会立即执行，所有的依赖也会被同步加载。\n   - ES6 模块是在编译时静态解析的，模块的输出在代码解析阶段就已经生成。这意味着`import`语句必须置于顶层，且其参数只能是字符串，不支持动态生成模块路径。同时，ES6 模块支持异步加载，有一个独立的模块依赖的解析阶段。\n\n3. **值的处理**：\n\n   - CommonJS 模块输出的是值的拷贝，这意味着如果模块导出的值被修改，导入模块中的值不会受到影响。\n   - ES6 模块输出的是值的引用，模块内部状态的改变会影响到所有导入该模块的地方。然而，`import`的接口是只读的，不能修改其变量值，即不能修改其变量的指针指向，但可以改变变量内部指针指向的内容。\n\n4. **循环依赖处理**：\n\n   - 当出现循环依赖时，CommonJS 会返回一个未完成的对象，这可能导致某些模块的部分功能无法正常工作。\n   - ES6 模块在处理循环依赖时会创建一个未定义的引用，只输出已经执行的部分，还未执行的部分不会输出。\n\n5. **使用场景**：\n   - ES6 模块在浏览器端和服务器端都可用，而 CommonJS 主要适用于服务器端。\n\n总的来说，CommonJS 和 ES6 模块系统各有其特点和适用场景。随着 JavaScript 的发展，ES6 模块系统由于其静态解析、异步加载以及更好的循环依赖处理等特点，正逐渐成为主流。然而，在特定的环境和需求下，CommonJS 仍然是一个有效的选择。\n\n### 箭头函数和匿名函数的关系和区别\n\n箭头函数和匿名函数在 JavaScript 中都是重要的函数类型，它们之间存在一定的关系，同时也有明显的区别。\n\n**关系**：\n\n箭头函数可以看作是匿名函数的一种简化形式。箭头函数在语法上更简洁，特别是当函数体只包含一个表达式时，箭头函数甚至可以省略掉花括号 `{}` 和 `return` 关键字。这使得箭头函数在书写上更为简洁，同时也更容易阅读和理解。\n\n**区别**：\n\n1. **函数命名**：匿名函数顾名思义是没有函数名的函数，通常需要将函数赋值给一个变量，然后通过这个变量来调用函数。而箭头函数也没有显式的函数名，但它与匿名函数在命名上的主要区别在于，箭头函数通常不需要赋值给变量，可以直接作为参数传递或者在其他函数内部使用。\n2. **this 绑定**：这是箭头函数和匿名函数（以及普通函数）之间最重要的区别。箭头函数不绑定自己的 `this`，它会捕获其所在上下文的 `this` 值作为自己的 `this` 值。这意味着，在箭头函数内部，`this` 的值始终与定义该箭头函数时的上下文一致。而匿名函数（以及普通函数）的 `this` 值则取决于函数的调用方式，这可能导致在回调函数、事件处理器等场景中 `this` 的指向变得难以预测。\n3. **arguments 对象**：匿名函数（以及普通函数）可以访问 `arguments` 对象，这是一个类数组对象，代表传给函数的参数。而箭头函数没有 `arguments` 对象，如果需要访问参数，可以使用剩余参数（rest parameters）语法。\n\n总的来说，箭头函数和匿名函数都是 JavaScript 中灵活且强大的工具，它们各自有适用的场景。箭头函数主要用于那些不需要自己 `this` 绑定或不需要单独命名的简短函数，而匿名函数则可以在需要函数但不关心其具体名称的场景中使用。\n\n### 简易版 webpack\n\n在简易版的 webpack 或其他模块打包工具中，getAST、getDependencies 和 transform 这三个函数各自扮演着重要的角色\n以下是针对这三个函数在类似 webpack 这样的构建工具中的可能作用的描述：\n\n- getAST：\n  功能：这个函数负责解析源代码文件，生成抽象语法树（AST）。\n  AST 是源代码的树状表现形式，它允许程序以结构化的方式理解和操作代码。\n  在 webpack 中的作用：webpack 在打包过程中需要理解源代码的结构，以便进行后续的依赖分析、代码转换和打包优化等操作。\n  getAST 函数为 webpack 提供了这样的能力，使其能够准确地分析源代码。\n- getDependencies：\n  功能：此函数用于分析 AST，识别源代码中的依赖关系，即找出当前文件所依赖的其他模块或文件。\n  在 webpack 中的作用：webpack 需要知道每个模块都依赖了哪些其他模块，以便正确地构建依赖图，并按照正确的顺序打包这些模块。\n  getDependencies 函数负责识别这些依赖关系，为 webpack 的依赖解析和打包过程提供关键信息。\n- transform：\n  功能：这个函数用于转换 AST，即根据一定的规则修改源代码的结构或内容。这可以包括代码优化、添加新的功能、代码转换（如将 ES6+代码转换为 ES5 代码）等。\n  在 webpack 中的作用：webpack 允许用户通过插件或加载器（loader）来转换源代码。transform 函数是这些插件或加载器实现代码转换的关键部分。\n  它可以根据用户的配置和需求，对源代码进行各种转换操作，以满足特定的构建需求。\n\n### path\n\n```js\nconst path = require("path");\nconsole.log(getAST(path.join(__dirname, "../src/index.js")));\n```\n\n- dirname:\n  dirname 是一个 Node.js 的全局变量，它表示当前执行脚本所在的目录的绝对路径。例如，如果你的脚本在 /home/user/myproject/script.js 中，那么 dirname 的值就是 /home/user/myproject。\n- path.join(\\*\\*dirname,\'../src/index.js\'):\n  path.join 方法用于连接多个路径片段。它会自动处理路径中的斜杠，确保在不同操作系统（如 Windows 和 Unix-like 系统）上都能正确工作。\n\n### Console 方法大全\n\n除了 console.time() 和 console.timeEnd() 之外，JavaScript 的 console 对象还提供了其他一些用于调试和性能分析的方法。以下是一些常用的 console 方法：\n\n- **_console.log()_**\n  用于在控制台输出信息。这是最常用的 console 方法。\n\n```js\nconsole.log("Hello, world!");\n```\n\n- **_console.error()_**\n  用于在控制台输出错误信息。通常用于标记错误或异常。\n\n```js\n\n```\n\nconsole.error("An error occurred:", error);\n\n- **_console.warn()_**\n  用于在控制台输出警告信息。这通常用于标记可能的问题或潜在问题。\n\n```js\nconsole.warn("This might be a problem:", potentialIssue);\n```\n\n- **_console.info()_**\n  用于在控制台输出信息性消息。这与 console.log() 类似，但语义上更侧重于输出有用的信息。\n\n```js\nconsole.info("This is some useful information");\n```\n\n- **_console.assert()_**\n  用于测试一个表达式是否为真。如果表达式为假，则会在控制台输出一条消息，并抛出一个 AssertionError。\n\n```js\nconsole.assert(true, "This will not be printed");\nconsole.assert(false, "This will be printed");\n\n// 假设我们有一个变量，它应该始终大于0\nlet value = 5;\n\n// 使用 console.assert() 来确保 value 大于 0\nconsole.assert(value > 0, "Value must be greater than 0");\n\n// 上面的代码不会输出任何内容，因为 value 确实大于 0\n\n// 现在我们改变 value 的值，使其小于 0\nvalue = -2;\n\n// 再次使用 console.assert()\nconsole.assert(value > 0, "Value must be greater than 0");\n\n// 这次，因为 value 不大于 0，console.assert() 会在控制台输出消息 "Value must be greater than 0"，\n// 并且在某些环境中（如Node.js），它还会抛出一个 AssertionError 异常。\n```\n\n- **_console.dir()_**\n  用于输出一个对象的所有属性和方法。这对于查看复杂对象的结构非常有用。\n\n```js\nconst obj = { a: 1, b: 2 };\nconsole.dir(obj);\n```\n\n- **_console.group()_** 和 console.groupEnd()\n  用于将相关的日志消息分组。console.group() 开始一个新的日志分组，而 console.groupEnd() 结束当前分组。这有助于在控制台中组织日志输出。\n\n```js\nconsole.group("Group 1");\nconsole.log("This is inside Group 1");\nconsole.groupEnd();\n```\n\n- **_console.count()_**\n  用于输出被调用的次数。这对于跟踪函数或代码块被调用的次数非常有用。\n\n```js\nfor (let i = 0; i < 5; i++) {\n  console.count("Loop iteration");\n}\n```\n\n- **_console.table()_**\n  用于以表格形式输出数据。这对于显示数组或对象列表很有用。\n\n```\n const data = [{ a: 1, b: 2 }, { a: 3, b: 4 }];\n console.table(data);\n```\n\n这些方法提供了丰富的日志记录功能，有助于开发者在开发和调试过程中更好地理解代码的行为。不同的浏览器和 Node.js 环境可能还支持一些额外的 console 方法，因此建议查阅具体环境的文档以获取完整的列表和用法说明。\n\n### Promise\n\n在 JavaScript 中，Promise 对象代表了一个可能现在还不可用，但将来某个时间点会确定的值或结果。这个对象让你可以编写异步代码时更容易地处理值或错误。Promise 有三种状态：\n\n- Pending（待定）：初始状态，既不是成功，也不是失败状态。\n- Fulfilled（已实现）：意味着操作成功完成。\n- Rejected（已拒绝）：意味着操作失败。\n\n**_resolve_** 和 **_reject_** 是创建 Promise 对象时提供的两个函数参数，它们用于改变 `Promise` 的状态：\n\n**_resolve(value)_** ：当异步操作成功完成时，调用 resolve 函数，并将操作的结果作为参数传递。这将使 Promise 对象的状态变为 Fulfilled，并将结果值传递给任何附加的 then 方法。\n\n**_reject(reason)_** ：当异步操作失败时，调用 reject 函数，并将错误的原因作为参数传递。这将使 Promise 对象的状态变为 Rejected，并将错误原因传递给任何附加的 catch 方法。\n\n下面是一个简单的例子，展示了如何使用 resolve 和 reject：\n\n```js\nfunction asyncOperation() {\n  //异步声明\n  return new Promise((resolve, reject) => {\n    // 模拟异步操作\n    const success = Math.random() > 0.5; // 随机决定操作是否成功\n    if (success) {\n      // 异步操作成功，调用 resolve\n      resolve("Operation succeeded!");\n    } else {\n      // 异步操作失败，调用 reject\n      reject("Operation failed!");\n    }\n  });\n}\n\nasyncOperation()\n  .then((result) => {\n    console.log(result); // 如果成功，将输出 \'Operation succeeded!\'\n  })\n  .catch((error) => {\n    console.error(error); // 如果失败，将输出 \'Operation failed!\'\n  });\n```\n\n在上面的例子中，asyncOperation 函数返回一个新的 Promise。在这个 Promise 中，我们模拟了一个异步操作，它根据随机数来决定是调用 resolve 还是 reject。然后，我们使用 then 方法来处理成功的情况，使用 catch 方法来处理错误的情况。\n\n在实际应用中，Promise 通常与异步操作（如网络请求、文件读取、定时器等）一起使用，以更好地管理异步流程。使用 Promise 可以避免回调地狱（Callback Hell），使代码更加清晰和可维护。\n\n在 JavaScript 中，Promise 是一个用于处理异步操作的对象。它代表了一个可能在未来某个时间点完成（或失败）的异步操作，并允许你指定操作成功或失败时要执行的回调函数。\n\nPromise 构造函数接受一个函数作为参数，这个函数通常被称为执行器函数（executor function）。执行器函数接受两个参数：resolve 和 reject。这两个参数都是函数，用于改变 Promise 的状态和传递结果或错误。\n\nresolve 函数用于将 Promise 的状态从“未完成”变为“成功”，并传递一个值作为异步操作的结果。当调用 resolve 函数时，**任何附加到 Promise 的 then 方法中的成功回调函数都会被调用，并接收到 resolve 传递的值作为参数。**\nreject 函数用于将 Promise 的状态从“未完成”变为“失败”，并传递一个值或错误对象作为异步操作失败的原因。当调用 reject 函数时，任何附加到 Promise 的 catch 方法中的失败回调函数都会被调用，并接收到 reject 传递的值或错误对象作为参数。\n**如果没有 resolve 和 reject 参数，那么 Promise 就失去了表示异步操作结果或错误的能力，也无法正确地触发相关的回调函数。因此，它们是 Promise 构造函数中不可或缺的部分，确保了 Promise 能够按照预期的方式工作。**\n\n简而言之，resolve 和 reject 参数是 Promise 的核心组成部分，它们使得 Promise 能够有意义地表示和处理异步操作的结果和错误。\n\n### -S 和-D 参数\n\nnpm install <package-name> --save 或 -S\n\n将包添加到项目的 dependencies 中，这通常用于生产环境的依赖。\nnpm install <package-name> --save-dev 或 -D\n\n将包添加到项目的 devDependencies 中，这通常用于开发环境的依赖。\n\n### Eslint\n\nenv 用于指定脚本的运行环境。这样 ESLint 可以知道哪些全局变量或功能是可用的，从而避免对这些全局变量或功能发出警告。\nbrowser: true 告诉 ESLint 代码运行在浏览器环境中，因此可以访问如 window 和 document 这样的全局变量。es2021: true 允许你使用 ES2021 的新特性，而不会被 ESLint 警告。\nrules 是 ESLint 配置的核心部分，用于定义具体的代码规则。你可以为每一个规则设置其严重性级别（0 到 2），其中 0 表示关闭规则，1 表示发出警告，2 表示抛出错误。\n\n例如，要禁止在代码中使用 console 语句，你可以这样配置：\n\n```js\nrules: {\n  \'no-console\': \'error\',\n},\n```\n\n这里，\'no-console\': \'error\' 表示如果代码中使用 console，ESLint 会抛出一个错误\n这只是 eslintrc.js 配置文件中的一部分选项。实际上，ESLint 提供了大量的配置选项和规则，可以根据项目的需要进行详细的定制。\n\n### babellrc 中 preset 和 plugin\n\npreset 就是多个 plugin 的集合 都是一个数组\n\n### 生产环境和开发环境\n\n- **开发环境**：dev 这是程序开发人员专门用于开发和调试项目的环境。在这个环境中，项目的配置通常可以比较随意，为了方便开发人员调试和排查问题，一般会打开全部错误报告。简单来说，开发环境是项目处于编码阶段时的主要运行环境。\n- **生产环境**：proj 这是项目正式对外提供服务的环境，也就是我们通常所说的“线上”环境。在这个环境中，项目的配置会更加严格和稳定，一般会关掉错误报告，打开错误日志，以确保服务的稳定性和用户体验。\n\n- **配置与目的**：开发环境的配置较为灵活，主要目的是为了方便开发人员进行代码编写、测试和调试。而生产环境的配置更为严格和稳定，目的是确保项目能够稳定、高效地对外提供服务。\n  **错误处理**：开发环境为了方便开发人员查找和解决问题，通常会打开全部错误报告。而生产环境为了避免给用户带来不好的体验，通常会关闭错误报告，仅开启错误日志进行问题追踪。\n  **性能优化**：在生产环境中，会对代码和资源进行更严格的优化，比如压缩 JS 和 CSS 文件、使用 CDN 加速等，以提高服务的性能和加载速度。而在开发环境中，这些优化可能并不是必需的。\n  **安全性**：生产环境对安全性有更高的要求，比如防止 SQL 注入、跨站脚本攻击等。而开发环境可能更侧重于功能的实现和调试，对安全性的考虑相对较少\n\n### npm 和 webpack 关系\n\nnpm 和 webpack 在前端开发过程中是相互依赖、相辅相成的。npm 提供了丰富的包管理功能，使得开发者可以方便地获取和使用各种依赖包；而 webpack 则提供了强大的模块打包功能，使得开发者可以更方便地进行模块化开发并优化项目的性能。\n\n### dev 开发包和 pro 开发包\n\n--save-dev(缩写为-D) 只在开发过程中用的包 代码压缩/测试框架/代码风格检测工具\nnpm install 会自动安装这些包\ndevDependencies 中的模块主要是为开发过程提供便利和支持的，它们不会被 webpack 直接打包进生产环境的代码包中，除非在源代码中直接引用了它们。\n\n# 学习过程遇到的问题\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-09-10：31：06（星期六）</em></span></p>\n'}, {'id': 3, 'title': 'Webpack_quetions2', 'date': '2024-03-29', 'content': '### 异步编程的概念\n\n异步编程的核心概念主要包括以下几点：\n\n1. **回调函数（Callback）**：这是异步编程中的核心概念之一。回调函数是在异步操作完成时由系统自动调用的函数。通过使用回调函数，程序可以在异步操作完成后处理结果，从而避免阻塞程序的执行。\n2. **任务分解与并行执行**：异步编程通过将程序中的计算任务分成独立的阶段，并在每个阶段完成后立即返回结果。这样，程序可以在等待一个任务完成时开始执行其他任务，实现了任务的并行执行，从而提高了程序的响应性能和效率。\n3. **提交与处理的分离**：异步编程中，任务的提交和处理是分离的。任务提交后立即返回，由其他部分负责处理该任务的执行和结果。这种方式可以充分利用系统资源，提高程序的效率和吞吐量。\n4. **响应速度与并发性能的提升**：异步编程通过避免任务阻塞带来的延迟，能够大幅度提高程序的响应速度，提升用户体验。同时，它允许程序同时处理多个任务，充分利用计算资源，提升了系统的并发能力。\n\n需要注意的是，尽管异步编程具有许多优势，但它也有一些挑战，如代码复杂度的增加和调试困难等。因此，在使用异步编程时，需要权衡其利弊，并根据具体的应用场景和需求做出选择。\n\n### Js 语言的特点\n\n除了非阻塞外，JavaScript 及其在浏览器中的运行还具有以下特点：\n\n1. **解释型脚本语言**：JavaScript 是一种解释型语言，代码不需要预先编译，而是在运行时逐行解释执行。这种特性使得 JavaScript 的开发过程非常方便，能够快速地看到代码效果，提高开发效率。\n2. **基于对象**：JavaScript 是一种基于对象的脚本语言，它不仅可以创建新的对象，也能操作使用已有的对象。这使得 JavaScript 具有很强的灵活性和可重用性。\n3. **弱类型**：JavaScript 是一种弱类型的编程语言，对使用的数据类型没有严格的要求。例如，一个变量可以被初始化为任意类型，也可以随时改变其类型。这种弱类型特性使得 JavaScript 的编写更加灵活和方便。\n4. **动态性**：JavaScript 是一种采用事件驱动的脚本语言，它可以直接对用户或客户输入做出响应，无需经过 Web 服务程序。这种动态性使得 JavaScript 能够实时地处理用户的交互操作，提供丰富的用户体验。\n5. **跨平台性**：JavaScript 是依赖于浏览器本身，与操作环境无关。只要计算机能运行支持 JavaScript 的浏览器，就可以正确执行 JavaScript 代码。这使得 JavaScript 具有广泛的适用性和可移植性。\n6. **安全性**：JavaScript 是一种安全性语言，它不允许访问本地的硬盘，也不能将数据存入到服务器上，不允许对网络文档进行修改和删除。这种安全性特性有效地防止了数据的丢失和滥用。\n7. **非阻塞**: 这是异步编程的核心概念之一：非阻塞。它允许 JavaScript 在等待某个操作（如文件读取、网络请求或计算密集型任务）完成时继续执行其他任务，从而提高程序的响应性和效率。\n\n这些特点使得 JavaScript 成为 Web 开发中不可或缺的一部分，无论是前端开发还是后端开发，JavaScript 都发挥着重要的作用。同时，随着 Web 技术的不断发展，JavaScript 的应用领域也在不断扩展，未来还将有更多的可能性等待我们去探索。\n\n### Promise 的异步回调\n\n使用 `.then` 方法实际上是在等待 Promise 的完成。当你调用 `.then` 时，你提供了一个回调函数，这个函数会在 Promise 解析（即成功完成）时被调用。这并不意味着 JavaScript 会“暂停”整个程序的执行来等待这个 Promise 完成，而是使用了异步编程模型。\n\n在 Promise 生成之后，`.then` 方法本身会立即返回一个新的 Promise（除非发生错误）。这个新的 Promise 将在原始 Promise 解析时解析，或者在原始 Promise 拒绝时拒绝。`.then` 方法中的回调函数并不会“自行执行”，而是会在适当的时机（即原始 Promise 解析时）被 JavaScript 引擎调用。\n\n这是一个简单的例子来说明这个过程：\n\n```javascript\nzip\n  .generateAsync({ type: "nodebuffer" })\n  .then((content) => {\n    // 这个回调函数会在 ZIP 文件生成完成后执行\n    console.log("ZIP 文件生成完成", content);\n    // 这里可以处理 ZIP 文件的二进制内容\n  })\n  .catch((error) => {\n    // 如果生成 ZIP 文件时发生错误，这个回调函数会被执行\n    console.error("生成 ZIP 文件时出错", error);\n  });\n\n// 这里的代码会在 ZIP 文件生成的同时执行\nconsole.log("ZIP 文件生成中...");\n// 当这个 console.log 执行时，ZIP 文件可能还在生成中\n// 但是一旦生成完成，.then 中的回调函数会被调用\n```\n\n在上面的代码中：\n\n1. `zip.generateAsync({ type: "nodebuffer" })` 开始异步生成 ZIP 文件，并返回一个 Promise。\n2. `.then((content) => { ... })` 定义了一个回调函数，它将在 Promise 解析时被调用。此时，JavaScript 不会“等待”ZIP 文件生成完成，而是继续执行后续的代码（即 `console.log(\'ZIP 文件生成中...\');`）。\n3. 当 ZIP 文件生成完成时，Promise 会解析，并调用 `.then` 中的回调函数。此时，控制台会输出 `\'ZIP 文件生成完成\'` 和 ZIP 文件的二进制内容。\n4. 如果在生成 ZIP 文件的过程中发生错误，`.catch` 中的回调函数会被调用，并输出错误信息。\n\n所以，使用 `.then` 实际上是在“等待” Promise 的完成，但不是通过阻塞整个程序的方式，而是通过异步回调的方式。这使得 JavaScript 可以继续执行其他任务，而不必等待某个长时间运行的操作完成。\n\n### buffer 到底是什么\n\nBuffer(缓冲区)和管道在数据处理和通信机制方面确实有一些共同之处，但它们在具体的应用场景和角色上有所不同。\n\n首先，我们来看 Buffer。Buffer 主要用于存储一定量的数据，在数据处理、网络通信、文件 I/O 等场景中发挥着重要作用。它允许程序在数据完全处理或传输之前临时存储数据。无论是 Java 中的 NIO Buffer 类，还是 Node.js 中的 Buffer 对象，它们的核心目的都是为了优化数据的处理效率。\n\n然后，我们来看管道（Pipe）。管道是一种在操作系统中常用的通信机制，用于在不同进程之间传递数据。它可以看作是一种特殊的文件，具有读写两个端口，数据从一个端口流入，从另一个端口流出。管道的主要作用是实现进程间通信，使得不同进程之间可以共享数据和资源。通过管道，一个进程可以将数据传递给另一个进程，从而实现进程之间的协作和协同工作。\n\n因此，Buffer 和管道的共同之处在于它们都涉及数据的存储和传输。然而，它们的应用场景和角色有所不同。Buffer 更侧重于在单个程序或进程内部对数据进行临时存储和处理，而管道则更侧重于在多个进程之间实现数据的传递和共享。\n\n总的来说，Buffer 和管道都是计算机系统中重要的数据处理和通信机制，它们各自在特定的场景下发挥着关键的作用。\n\n#### “先输入读到缓冲区(buffer)吗？\n\n答案是肯定的。在 C++中，当你使用 IO 流（如 std::cin 或文件流）进行输入操作时，数据首先会被读取到一个内部缓冲区中。然后，你可以从这个缓冲区中读取数据，而不需要直接从原始输入源（如文件或控制台）读取。这种缓冲机制提高了程序的效率，因为它减少了直接访问输入源的次数。\n\n### module 和 module.exports\n\n在 JavaScript 模块化系统中，传入`module`对象是为了在模块内部提供有关该模块的信息和功能，比如定义模块的导出内容、管理模块的状态等。而`module.exports`则是这个对象的一个属性，用于指定模块对外暴露的接口或内容。\n\n当其他模块需要引入当前模块时，它们实际上是引入了`module.exports`所指向的对象。因此，`module.exports`是模块与外部交互的桥梁，它决定了哪些内容可以被其他模块访问和使用。\n\n如果只传入`module`而不传入`module.exports`，那么外部模块将无法直接访问模块内部定义的内容，因为`module`对象本身并不直接暴露任何内容给外部。而`module.exports`则提供了一种机制，使得模块可以有选择地暴露其内部的功能和数据。\n\n因此，在模块化编程中，通常会将`module`和`module.exports`一起使用，以提供完整的模块化功能。`module`提供了模块的内部管理和组织机制，而`module.exports`则提供了模块与外部交互的接口。这种设计使得模块化编程更加灵活和可维护。\n\n请注意，不同的模块化规范或框架可能会有不同的实现方式和语法，但基本的原理是相似的。在实际开发中，需要根据所使用的具体技术栈和规范来正确使用`module`和`module.exports`。\n\n### 自执行函数 SimplePack IIFE\n\n```js\n(function (modules) {\n  function require(filename) {\n    var fn = modules[filename];\n    var module = { exports: {} };\n    fn(require, module, module.exports);\n    return module.exports;\n  }\n  require("D:Acwing_mdWebpacksimple-packsrcindex.js");\n})({\n  "D:Acwing_mdWebpacksimple-packsrcindex.js": function (\n    require,\n    module,\n    exports\n  ) {\n    "use strict";\n\n    var _greeting = require("./greeting.js");\n\n    document.write((0, _greeting.greeting)("join"));\n  },\n  "./greeting.js": function (require, module, exports) {\n    "use strict";\n\n    Object.defineProperty(exports, "__esModule", {\n      value: true,\n    });\n    exports.greeting = greeting;\n    function greeting(name) {\n      return "hello" + name;\n    }\n  },\n});\n```\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-21-17：04：52星期四）</em></span></p>\n'}, {'id': 4, 'title': 'Webpack_Resume', 'date': '2024-03-29', 'content': '能够通过对构建工具选项优化来加速 FCP,\n熟悉 SPA 与 MPA 的构建流程,\n'}, {'id': 5, 'title': '000Summary_0012', 'date': '2024-03-29', 'content': '## 第一章\n\n`webpack.config.js`保留关键字\n\n```js\nconst glob = require("glob");\n//const entryFiles = glob.sync(path.join(__dirname, \'./src/*/index.js\')); 用来查找匹配\nconst path = require("path");\n//path保留关键字 __dirname当前文件夹路径\nconst webpack = require("webpack");\n\nmodule.exports = {\n  entry: "./src/index.js",\n  output: {\n    path: path.join(__dirname, "dist"),\n    filename: "main.js",\n  },\n  mode: "production",\n  plugins: [\n    new ZipPlugin({\n      //插件是一个数组 里边需要new 插件 并且传入参数 传入配置\n      filename: "offline",\n    }),\n  ],\n};\n```\n\n## 第二章\n\n### webpack 核心概念之 entry\n\n```js\nentry: "./src/index.js",\nentry: {\n    app:"./src/index.js",\n    adminApp:\'.src/adminApp.js\';\n}\n```\n\n### webpack 核心概念之 output\n\n多 Entry 使用`[name].js` 来确保文件名称的唯一\n\n```js\noutput: {\n    path: path.join(__dirname, "dist"),\n    filename: "[name].js",\n},\n```\n\n### webpack 核心概念之 loaders\n\n只支持 js 和 json 所以需要 Loaders 去支持其他文件类型 并且添加在依赖图中\n注意 Loader 本身是个**函数** 接受源文件作为参数 返回转换的结果\n在匹配到对应的文件的时候 会启动 Loader 进行转换\n\n### webpack 核心概念之 plugins\n\n插件 返回的是一个**类** 所以使用的时候需要 new 实例\n作用域 bundle 文件的优化 资源管理和环境变量注入\n\n### webpack 核心概念之 mode\n\n模式\n\n- **开发环境**：dev 这是程序开发人员专门用于开发和调试项目的环境。在这个环境中，项目的配置通常可以比较随意，\n  为了方便开发人员调试和排查问题，一般会打开全部错误报告。简单来说，开发环境是项目处于编码阶段时的主要运行环境。\n  热更新可以很方便的开发\n- **生产环境**：proj 这是项目正式对外提供服务的环境，也就是我们通常所说的“线上”环境。\n  在这个环境中，项目的配置会更加严格和稳定，一般会关掉错误报告，打开错误日志，以确保服务的稳定性和用户体验。\n  对代码进行压缩\n\n```js\n### -S 和-D 参数\n\nnpm install <package-name> --save 或 -S\n\n将包添加到项目的 dependencies 中，这通常用于生产环境的依赖。\nnpm install <package-name> --save-dev 或 -D\n\n将包添加到项目的 devDependencies 中，这通常用于开发环境的依赖。\n```\n\n### 解析 ECMASCript 6 和 React JSX\n\nEs6(2015)需要使用 babelLoader (需要使用.babelrc) 这一步需要改两个地方 一个是 babelrc 内部的 preset\n还有 config 需要调用 babel-loader 详情看 2-es6\njsx 也是需要使用 babel 的\n\n### 解析 CSS、Less 和 Sass\n\n注意调用顺序\n\n```js\n{\n    test: /.css$/,\n    use: [\n        \'style-loader\',\n        \'css-loader\'\n    ]\n},\n{\n    test: /.less$/,\n    use: [\n        \'style-loader\',\n        \'css-loader\',\n        \'less-loader\'\n    ]\n},\n```\n\n### 解析图片和字体\n\n使用 file-loador 处理文件和字体\n\n```js\n{\n    test: /.(png|jpg|gif|jpeg)$/,\n    use: \'file-loader\'\n},\n{\n    test: /.(woff|woff2|eot|ttf|otf)$/,\n    use: \'file-loader\'\n}\n```\n\n### webpack 中的文件监听\n\n开启两种方式\n\n1. webpack 命令 使用--watch\n2. config.js 中设置 watch true\n\n缺点 手动刷新浏览器\n\n轮询判断最后编辑时间 缓存起来 等待 aggreateTimeout 聚合超时\n![Alt text](image.png)\n\n### webpack 中的热更新及原理分析\n\n只在 Development 中启动\nweebpack-dev-server 不刷新浏览器 不输出文件(放在内存里)\n使用 HotModuleRepalcementPlugin\n![Alt text](image-1.png)\n\n### 文件指纹策略：chunkhash、contenthash 和 hash\n\n打包后输出文件名的后缀\n\n```js\noutput: {\n        path: path.join(__dirname, \'dist\'),\n        filename: \'[name]_[chunkhash:8].js\'\n    },\nmodule:{\n  rules:[\n    {\n        test: /.(png|jpg|gif|jpeg)$/,\n        use: [\n            {\n                loader: \'file-loader\',\n                options: {\n                    name: \'[name]_[hash:8].[ext]\'\n                }\n            }\n        ]\n    },\n  ]\n}\nplugins: [\n  new MiniCssExtractPlugin({\n    filename: "[name]_[contenthash:8].css",\n  }),\n];\n```\n\n### HTML 、CSS 和 JavaScript 代码压缩\n\njs 默认使用 `uglifyjs-webpack-plugin`\ncss 使用 optimize-css-assets-webpack-plugin 同时使用 cssnano\n\n```js\nplugins: [\n        new OptimizeCSSAssetsPlugin({\n            assetNameRegExp: /\\.css$/g,\n            cssProcessor: require(\'cssnano\')\n        }),\n//多页面应用 每个都要对应的htmlWebpackPlugin\nhtmlWebpackPlugins.push(\n      new HtmlWebpackPlugin({\n          template: path.join(__dirname, `src/${pageName}/index.html`),\n          filename: `${pageName}.html`,\n          chunks: [pageName],\n          inject: true,\n          minify: {\n              html5: true,\n              collapseWhitespace: true,\n              preserveLineBreaks: false,\n              minifyCSS: true,\n              minifyJS: true,\n              removeComments: false\n          }\n      })\n  );\n```\n\n### Summary 总结\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-24-20：40：12（星期日）</em></span></p>\n'}, {'id': 6, 'title': '000Summary_0030', 'date': '2024-03-29', 'content': '### 自动清理构建目录产物\n\n![Alt text](image-2.png)\n\n### PostCSS 插件 autoprefixer 自动补齐 CSS3 前缀\n\n![Alt text](image-3.png)\n![Alt text](image-4.png)\n\n### 移动端 CSS px 自动转换成 rem\n\n![Alt text](image-5.png)\n![Alt text](image-6.png)\n![Alt text](image-7.png)\n![Alt text](image-8.png)\n\n### 静态资源内联\n\n![Alt text](image-9.png)\n![Alt text](image-10.png)\n![Alt text](image-11.png)\n\n### 多页面应用打包通用方案\n\n![Alt text](image-12.png)\n![Alt text](image-13.png)\n![Alt text](image-14.png)\n\n### 使用 sourcemap\n\n![Alt text](image-15.png)\n![Alt text](image-16.png)\n![Alt text](image-17.png)\n\n### 提取页面公共资源\n\n![Alt text](image-18.png)\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n![Alt text](image-21.png)\n\n### Tree Shaking 的使用和原理分析\n\n![Alt text](image-22.png)\n![Alt text](image-23.png)\n![Alt text](image-24.png)\n![Alt text](image-25.png)\n![Alt text](image-26.png)\n![Alt text](image-27.png)\n![Alt text](image-28.png)\n\n### Scope Hoisting 使用和原理分析\n\n![Alt text](image-29.png)\n![Alt text](image-30.png)\n\n### 代码分割和动态 import\n\n![Alt text](image-31.png)\n![Alt text](image-32.png)\n![Alt text](image-33.png)\n![Alt text](image-34.png)\n\n### 在 webpack 中使用 ESLint\n\n![Alt text](image-35.png)\n![Alt text](image-36.png)\n![Alt text](image-37.png)\n![Alt text](image-38.png)\n![Alt text](image-39.png)\n![Alt text](image-40.png)\n![Alt text](image-41.png)\n\n### webpack 打包组件和基础库\n\n![Alt text](image-42.png)\n![Alt text](image-43.png)\n![Alt text](image-44.png)\n![Alt text](image-45.png)\n![Alt text](image-46.png)\n![Alt text](image-47.png)\n![Alt text](image-48.png)\n\n### webpack 实现 SSR 打包（上）\n\n![Alt text](image-49.png)\n![Alt text](image-50.png)\n![Alt text](image-51.png)\n![Alt text](image-52.png)\n![Alt text](image-53.png)\n![Alt text](image-54.png)\n\n### webpack 实现 SSR 打包（下）\n\n![Alt text](image-55.png)\n![Alt text](image-56.png)\n![Alt text](image-57.png)\n\n### 优化构建时命令行的显示日志\n\n![Alt text](image-58.png)\n![Alt text](image-59.png)\n![Alt text](image-60.png)\n![Alt text](image-61.png)\n![Alt text](image-62.png)\n\n### 构建异常和中断处理\n\n![Alt text](image-63.png)\n![Alt text](image-64.png)\n\n# This title\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-25-21：26：00（星期一）</em></span></p>\n'}, {'id': 7, 'title': '000Summary_0040', 'date': '2024-03-29', 'content': '![Alt text](image-65.png)\n\n### 构建配置包设计\n\n![Alt text](image-66.png)\n![Alt text](image-67.png)\n![Alt text](image-68.png)\n![Alt text](image-69.png)\n\n### 功能模块设计和目录结构\n\n![Alt text](image-70.png)\n![Alt text](image-71.png)\n\n### 使用 ESLint 规范构建脚本\n\n![Alt text](image-72.png)\n\n### 冒烟测试介绍和实际运用\n\n![Alt text](image-73.png)\n![Alt text](image-74.png)\n![Alt text](image-75.png)\n![Alt text](image-76.png)\n\n### 单元测试和测试覆盖率\n\n![Alt text](image-77.png)\n![Alt text](image-78.png)\n![Alt text](image-79.png)\n\n### 持续集成和 Travis CI\n\n![Alt text](image-80.png)\n![Alt text](image-81.png)\n![Alt text](image-82.png)\n![Alt text](image-83.png)\n\n### 发布构建包到 npm 社区\n\n![Alt text](image-84.png)\n\n### Git Commit 规范和 changelog 生成\n\n![Alt text](image-85.png)\n![Alt text](image-86.png)\n![Alt text](image-87.png)\n![Alt text](image-88.png)\n![Alt text](image-89.png)\n\n### 语义化版本（Semantic Versioning）规范格式\n\n![Alt text](image-90.png)\n![Alt text](image-91.png)\n\n# This title\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-25-21：39：37（星期一）</em></span></p>\n'}, {'id': 8, 'title': '000Summary_0050', 'date': '2024-03-29', 'content': '### 初级分析：使用 webpack 内置的 stats\n\n### 速度分析：使用 speed-measure-webpack-plugin\n\n### 体积分析：使用 webpack-bundle-analyzer\n\n### 使用高版本的 webpack 和 Node.js\n\n### 多进程/多实例构建\n\n### 多进程并行压缩代码\n\n### 进一步分包：预编译资源模块\n\n### 充分利用缓存提升二次构建速度\n\n### 缩小构建目标\n\n### 使用 Tree Shaking 擦除无用的 JavaScript 和 CSS\n\n### 使用 webpack 进行图片压缩\n\n### 使用动态 Polyfill 服务\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-25-21:40:39(星期一)</em></span></p>\n'}, {'id': 9, 'title': '000Summary_0060', 'date': '2024-03-29', 'content': '### webpack 启动过程分析\n\n### ebpack-cli 源码阅读\n\n### Tapable 插件架构与 Hooks 设计\n\n### Tapable 是如何和 webpack 进行关联起来的？\n\n### webpack 流程篇：准备阶段\n\n### webpack 流程篇：模块构建和 chunk 生成阶段\n\n### webpack 流程篇：文件生成\n\n### 动手编写一个简易的 webpack(上)\n\n### 动手编写一个简易的 webpack(下)\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-25-21：41：48（星期一）</em></span></p>\n'}, {'id': 10, 'title': '000Summary_0070', 'date': '2024-03-29', 'content': '### loader 的链式调用与执行顺序\n\n### 使用 loader-runner 高效进行 loader 的调试\n\n### 更复杂的 loader 的开发场\n\n### 实战开发一个自动合成雪碧图的 loader\n\n### 插件基本结构介绍\n\n### 更复杂的插件开发场景\n\n### 实战开发一个压缩构建资源为 zip 包的插件\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-25-21:42:48(星期一)</em></span></p>\n'}, {'id': 11, 'title': '000Summary_NodeJs入门介绍', 'date': '2024-03-29', 'content': '### NodeJs 介绍\n\n**Node.js 既不是一个应用程序，也不是一种语法规范**。它是一个开源的跨平台 JavaScript 运行环境，让 JavaScript 可以在服务器端运行。Node.js 基于 Chrome 的 V8 引擎，使用**事件驱动、非阻塞 I/O 模型**，使其轻量且高效，非常适合数据密集型的实时应用。\n\n具体来说，Node.js 是一个执行 JavaScript 代码的运行时环境，它不是一个应用程序，因为你可以使用 Node.js 来运行你自己编写的 JavaScript 代码，创建各种类型的应用程序。同时，Node.js 也不是一种语法规范，它并不定义或改变 JavaScript 的语法。相反，它使用 JavaScript 作为开发语言，**提供了一组 API 来访问和操作操作系统层面的功能，如文件系统、网络请求等**。\n\n总的来说，Node.js 提供了一个强大的运行环境，使得开发者能够使用 JavaScript 这种灵活且强大的语言来编写服务器端的应用程序。\n\n在 Node.js 中，虽然其内部采用了单线程模型来处理请求，但实际上，它使用了**异步 I/O** 和**事件循环机制**，使得它能够在单线程下处理高并发请求。这种设计使得 Node.js 在处理大量并发连接时非常高效，而不会像传统的多线程服务器那样受到线程切换和锁的竞争等问题的困扰。\n\n需要注意的是，虽然 Node.js 本身采用了单线程模型，但在某些情况下，Node.js 也会使用到多线程。例如，当 Node.js 执行某些 CPU 密集型任务时，它可能会使用子进程或者工作线程来分担主线程的负担，以提高性能。此外，Node.js 的某些内部操作，如垃圾回收等，也可能涉及到多线程。\n\n总的来说，虽然 Node.js 在内部采用了单线程模型，但在运行时，它仍然是一个独立的进程，并且会被操作系统分配相应的资源。同时，Node.js 也提供了丰富的 API 和机制，使得开发者能够根据需要灵活地使用多线程来提高程序的性能。\n\n**Node 终端本身并不直接代表一个进程**，而是提供了一个命令行界面，让你可以与 Node.js 环境进行交互。当你打开终端或命令提示符并输入`node`命令时，你实际上是在**请求启动一个新的 Node.js 进程**。\n\n当你输入`node index.js`时，你告诉终端启动一个新的 Node.js 进程，并在这个进程中执行`index.js`文件。换句话说，`node`命令是用来启动 Node.js 运行时的，而`index.js`是你想要 Node.js 运行时执行的 JavaScript 文件。\n\n因此，这个过程涉及几个步骤：\n\n1. 你打开终端或命令提示符。\n2. 你输入`node`命令，这告诉操作系统启动一个新的 Node.js 进程。\n3. 你附加`index.js`作为参数，这告诉 Node.js 进程要执行哪个文件。\n4. Node.js 进程启动，读取并执行`index.js`文件中的代码。\n\n在这个过程中，**Node.js 并不直接“编译”JavaScript 代码**。相反，**它使用 V8 引擎来直接执行 JavaScript 代码**。V8 引擎将 JavaScript 代码转换为机器码以加快执行速度，但这通常不被认为是传统意义上的“编译”，因为它是在运行时进行的，并且不产生独立的、可在没有 V8 引擎的情况下执行的二进制文件。\n\n所以，总结来说，当你运行`node index.js`时，你是在启动一个新的 Node.js 进程来执行`index.js`文件中的 JavaScript 代码。这个过程不涉及传统意义上的“编译”，而是直接执行 JavaScript 代码。\n\n### Nodejs 于 Webpack 的关系\n\n**是的，webpack 依赖于 Node.js**。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具，它基于 Node.js 开发，并且在执行打包压缩时需要依赖 Node.js 的环境。没有 Node.js，webpack 就不能正常工作。然而，需要注意的是，webpack 打包后的项目本身只是前端静态资源，与后台是否使用 Node.js 无关。因此，虽然 webpack 的运行依赖于 Node.js 的环境，但它打包生成的文件可以在任何具有后台能力的环境中部署。\n\n在安装 webpack 时，通常也需要 Node.js 和 npm（Node.js 的包管理器）的支持。可以通过 npm 或 cnpm（淘宝镜像的 npm）来全局安装 webpack，以便在项目中使用它进行打包操作。\n\n### Npm 于 Nodejs 的关系\n\nnpm 与 Node.js 的关系非常密切。npm 的中文意思是“node 包管理器”，它是 Node.js 平台的默认包管理工具，会随着 Node.js 一起安装。在 Node.js 中，npm 扮演着至关重要的角色，类似于 pip 在 Python、gem 在 Ruby 以及 pear 在 PHP 中的地位。\n\n具体来说，npm 的主要功能包括：\n\n作为 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。它提供了命令行工具，使开发者可以方便地下载、安装、升级、删除包。\n允许用户从 npm 服务器下载并安装他人编写的命令行程序到本地使用，同时也允许用户将自己编写的包或命令行程序上传到 npm 服务器供他人使用。\nnpm 的背后是一个基于 couchdb 的数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。这使得开发者能够从繁琐的包管理工作中解放出来，更加专注于功能的开发。\n\n总的来说，npm 与 Node.js 的关系就像是一把钥匙和锁的关系，npm 为 Node.js 提供了强大的包管理功能，使得 Node.js 的应用开发变得更加高效和便捷。\n\n### Webpack 中 module.exports 的含义\n\n在 Webpack 中，配置文件中写`module.exports`是为了导出配置对象，使得 Webpack 能够读取并应用这些配置。Webpack 的配置文件通常是一个 Node.js 模块，它使用 CommonJS 规范来导出配置对象。\n\n`module.exports`是 Node.js 中用于导出模块内容的语法。在 Webpack 的配置文件中，你需要使用`module.exports`来定义一个对象，该对象包含了 Webpack 的各种配置选项。这些配置选项告诉 Webpack 如何处理项目中的文件、模块、插件等。\n\n例如，你可以使用`module.exports`来配置入口文件、输出目录、加载器（loader）和插件等。通过正确配置这些选项，你可以控制 Webpack 的打包过程，实现代码的模块化、压缩、优化等功能。\n\n下面是一个简单的 Webpack 配置文件示例，展示了如何使用`module.exports`来导出配置对象：\n\n```javascript\nconst path = require("path");\n\nmodule.exports = {\n  entry: "./src/index.js", // 入口文件\n  output: {\n    filename: "main.js", // 输出文件名\n    path: path.resolve(__dirname, "dist"), // 输出目录\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/, // 使用正则表达式匹配文件类型\n        exclude: /node_modules/, // 排除node_modules目录\n        use: {\n          loader: "babel-loader", // 使用的加载器\n          options: {\n            // 加载器的选项配置\n          },\n        },\n      },\n    ],\n  },\n  plugins: [\n    // 配置插件\n  ],\n  mode: "development", // 设置模式为开发模式\n};\n```\n\n在上面的示例中，`module.exports`导出了一个包含多个属性的对象。这些属性对应了 Webpack 的不同配置选项，如`entry`表示入口文件的位置，`output`定义了输出文件的名称和目录，`module`用于配置加载器，`plugins`用于配置插件，`mode`用于设置 Webpack 的运行模式（开发模式或生产模式）。\n\n通过将配置对象导出，Webpack 能够读取这些配置，并根据这些配置来执行相应的打包任务。这样，你就可以通过修改配置文件来定制 Webpack 的行为，以满足你的项目需求。\n'}, {'id': 12, 'title': '001基础篇Webpack发展_001', 'date': '2024-03-29', 'content': '---\n\n本项目代码\n[https://github.com/cpselvis/geektime-webpack-course](https://github.com/cpselvis/geektime-webpack-course)\n\n### npm script 运行 webpack\n\n![Alt text](image-8.png)\npackge.json 默认读取到.bin 下边的软连接的\n\n---\n\n### Webpack 初体验\n\n![Alt text](image-9.png)\n需要进入某文件夹 npm init -y 打开 vscode 新建 webpack.config.js\n![Alt text](image-10.png)\n\n创建 scr/index.js 以及 helloworld.js\n![D](image-11.png)\n\n![Alt text](image-12.png)\n![Alt text](image-13.png)\n在 dist 下新建 index.html 引入 bundle.js\n![Alt text](image-14.png)\n\n---\n\n### 安装 Nodejs\n\n![Alt text](image-7.png)\n![Alt text](image-6.png)\n`--save-dev` 选项 注意一下\n\n会存放在 `.node_modules/.bin/webpack -v`下边\n\n### webPack 配置文件\n\n![Alt text](image-4.png)\n![Alt text](image-5.png)\n\n### 为什么选择 Webpack\n\n![Alt text](image-2.png)\n![Alt text](image-3.png)\n\n### 为什么需要构建工具\n\n![Alt text](image.png)\n\n### 课程大纲\n\n![Alt text](image-1.png)\n\n### 玩转 WebPack\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-07-10:55:20(星期四)</em></span></p>\n'}, {'id': 13, 'title': '002基础篇Webpack基础用法_001', 'date': '2024-03-29', 'content': '### css 文件指纹\n\n`npm i mini-css-extract-plugin -D`\nconst MiniCssExtractPlugin=require(\'mini-css-extract-plugin\')\n![Alt text](image-59.png)\nstyle-loader 式插入进去 这个 loader 是提取出来 这两个功能是互斥的\n\n所以需要将 style-loader 删掉\n![Alt text](image-60.png)\n![Alt text](image-61.png)\n\n---\n\n。\n\n### 文件指纹的生产配置\n\n新建一个 webpack.dev.js 用来说明 webpack 开发阶段的配置 因为文件指纹和 HMR 并不能同时使用 因为生产环境并不需要热更新\n![  001](image-31.png)\n![Alt text](image-32.png)\n不同的命令 用不同的 config 脚本\nprod\n![Alt text](image-33.png)\n添加下划线来区分 name 和 hash 值\n![Alt text](image-34.png)\n\n- 这里的 limit: 10240 是 url-loader 的一个配置项。url-loader 是一个 Webpack loader，用于处理文件，如图片、字体等，它可以根据文件的大小来决定如何处理这些文件。\n  具体来说，limit 选项定义了文件大小（以字节为单位）的阈值。如果文件的大小小于或等于这个阈值，url-loader 会将文件内容转为 Base64 编码，并将其作为 URL 嵌入到生成的 JS 文件中。这样做的好处是，对于小文件，你不需要进行额外的 HTTP 请求来获取它们，这可以加快页面加载速度。\n  limit: 10240 意味着如果图片的大小小于或等于 10KB（因为 10240 字节等于 10KB），则这个图片会被转化为 Base64 编码的字符串，并直接嵌入到生成的 JS 文件中。如果图片大小超过 10KB，url-loader 就会像 file-loader 那样处理文件，将文件输出到指定的目录，并在 JS 文件中引用它\n\n![Alt text](image-35.png)\n\n### 文件指纹\n\n![Alt text](image-26.png)\n51727DB 用来版本管理 浏览器可以缓存这些文件 一旦有新的文件 就可以更新\n![Alt text](image-27.png)\nHash 只要修改就会改变 chunk 对于每个 entry 都有不同的 chunkhash\nContentHash js 和 css 共用一个 chunk 那么 js 改变但是 css 没有改变 所以用 contenthash\n\n![Alt text](image-28.png)\n![Alt text](image-29.png)\ncss 通过 Loader 之后会被插入到页面头部 这时候并没有单独 css 文件 因此 css 文件指纹在这个插件里边设置\n![Alt text](image-30.png)\nmd5 默认是 32 位 我们取前 8 位 webpack js 和 css 文件指纹的 Hash he 图片字体是指文件内容的 Hash 的区别\n\n### 热更新 HMR\n\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n--open 每次自动开启浏览器\n\n![Alt text](image-22.png)\n只在开发过程使用 所以要为 development\n![Alt text](image-21.png)\n是在 webpack 中内置的 devServer 服务基本目录\n![Alt text](image-23.png)\n\n![Alt text](image-24.png)\n\n![Alt text](image-25.png)\nHMr runtime 用来将文件注入浏览器 和浏览器进行连接 通常使用 websocket 进行连接\n12AB 本地编译完成 发给 bundleSErver 然后让浏览器可以访问的到\n1234 发给 HMRServer Json 通知 runtime 5 是更新代码 不需要改变\n\n### 文件监听 Watch\n\n![Alt text](image-16.png)\n![Alt text](image-17.png)\nnpm run watch\n\n![Alt text](image-18.png)\n忽略 node_modules 时间会提升\n\n### 图片和字体\n\n![Alt text](image-50.png)\n`npm i file-loader -D`\n创建 `src/images/Logo.png`\n![Alt text](image-51.png)\n`npm run build`\n![Alt text](image-52.png)\n很长的一串 就是内容的 Hash\n![Alt text](image-53.png)\n![Alt text](image-55.png)\nfjssrc ormat(\'truetype\')\n![Alt text](image-54.png)\n![Alt text](image-56.png)\n![Alt text](image-57.png)\n![Alt text](image-58.png)\n\n### 解析 css 和 less\n\n![Alt text](image-45.png)\n`npm i style-loader css-loader -D`\n![Alt text](image-46.png)\n增加 css 解析\n![Alt text](image-47.png)\nloader 调用时链式调用 执行顺序也是从右到左的 因此需要先写 style-loader\n然后再写 css-loader 之后实际调用的时候 会先执行 css-loader 执行 css 然后传递给 style-loader 再执行 style-loader\n`npm run build`\n\n![Alt text](image-48.png)\n`npm i less less-loader -D`\n**less-loader** 需要 **less**\n![Alt text](image-49.png)\n\n### ReactJSX\n\n![Alt text](image-41.png)\n`npm i react-dom @babel/preset-react -D`\n为 babelrc 增加预设\n![Alt text](image-42.png)\n![Alt text](image-43.png)\nnpm run build\n! + tab 引用 search.js\n![Alt text](image-44.png)\n\n### ES6\n\n![Alt text](image-36.png)\n![Alt text](image-37.png)\npreset 是一列 bable/plugins 的集合\n解析 es6 只需要这一个 preset 就够了\n\n`npm i @babel/core @babel/preset-env babel-loader -D`\ni 是 install 缩写 -D 是 --save-dev 的缩写\n打开项目 创建 `.babelrc`文件\n![Alt text](image-38.png)\n修改 config\n![Alt text](image-39.png)\n然后清理一下 dist 目录 然后 run build\n![Alt text](image-40.png)\n\n### MOde\n\n![Alt text](image-14.png)\n![Alt text](image-15.png)\ndevelop 热更新很方便\nproduction 默认的生产环境的压缩\n\n### plugins\n\n![Alt text](image-11.png)\nloader 没办法用的可以用 plugins 完成 手动删除目录等等\n![Alt text](image-12.png)\n![Alt text](image-13.png)\n\n### loaders\n\n![Alt text](image-8.png)\n![Alt text](image-9.png)\n![Alt text](image-10.png)\n\n### outPut\n\n![Alt text](image-3.png)\n打包的输出 转换后的代码\n![Alt text](image-4.png)\n![Alt text](image-5.png)\n![alt text](image-6.png)\n必须用占位符号 [name]\n![Alt text](image-7.png)\n生成的是对应的文件\n\n### Entry\n\n![Alt text](image-2.png)\n单页面应用和多页面应用 的情况\n字符串和对象的写法{}\n\n模块打包器\n![Alt text](image.png)\n![Alt text](image-1.png)\n\n### WebPack 基础用法\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-07-11：14：12（星期四）</em></span></p>\n'}, {'id': 14, 'title': '002基础篇Webpack基础用法02_001', 'date': '2024-03-18', 'content': '## This title\n\n### html 插件\n\n`npm i html-webpack-plugin -D`\n![Alt text](image-3.png)\n![Alt text](image-4.png)\n一个页面对应一个插件\n\n### css 文件压缩\n\n![Alt text](image-2.png)\n现在只能通过插件压缩 以前可以用参数 此外还需要一个额外的 css 预处理器\n`npm i optimize-css-assets-webpack-plugin -D`\n`npm i cssnano -D`\n\n### js 文件压缩\n\n![Alt text](image-1.png)\n并行压缩\n内置的不用额外使用 如果希望额外配置 重新下载一下 传递参数就可以了\n自动压缩\n\n### 代码压缩\n\n![Alt text](image.png)\n\n# 002 基础篇 Webpack 基础用法\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-07-19：07：25（星期四</em></span></p>\n'}, {'id': 15, 'title': '003基础篇Webpack进阶用法_001', 'date': '2024-03-18', 'content': '### TreeShaking\n\n![Alt text](image-45.png)\nnodejs 中 commonjs 不支持\n![Alt text](image-46.png)\n![Alt text](image-47.png)\nimport 不能动态的改变引入的内容 因为不知道这些东西是否要用到\nmod prod 默认开启 treeshaking\n\n```js\nexport function a() {\n  return "this is a";\n}\nexport function B() {\n  return "this is b";\n}\nimport { a } from "./treeshaking";\n```\n\n搜索打包的 js 没有 a\n\n### 提取公共资源\n\n**_应该在生产环境中可用_**\n\n每个页面都有公共资源 如果基础包的分离 公共模块如何进行分离\n![Alt text](image-34.png)\n![Alt text](image-35.png)\n![Alt text](image-36.png)\n判断一个方法被引用次数 如果为 1 不满足 不会分离\n`npm i html-webpack-externals-plugin -D`\nconst HtmlWebpackExternalsPlugin=requeir(\'html-webpack-externals-plugins\');\n\n[可以通过 npm.js 查看一个库如何使用 ]\n\n![Alt text](image-37.png)\n我们使用的是 react\n![Alt text](image-38.png)\n入口 一般使用的是 cdn 文件\n**_效果_**\n![Alt text](image-39.png)\n业务文件的代码明显减少 分离之后 需要在 index.html 中引入 cdn 我们分离目的是为了优化打包速度\n**_分离的目的_**\n它允许你将某些库或模块标记为“外部依赖”，这意味着 Webpack 不会将它们打包进最终的 bundle 中。相反，它期望这些库在运行时已经在环境中可用。\n\n优化时间 并行加载 缓存\n这些库很可能已经被其他网站或应用缓存。这意味着用户可能已经在浏览器中缓存了这些库，从而进一步减少了加载时间\n但是有可能出现版本问题和跨域问题 需要准备好备用方案\n\n#### 使用 htmlWebpackPlugin\n\n![Alt text](image-40.png)\n![Alt text](image-41.png)\nreact 和 react-dom 被打包出来了\n然后将 vendeor 添加到 htmlWebpackPlugin 里边\n![Alt text](image-42.png)ahk_class PotPlayer64\nahk_exe PotPlayerMini64.exe\nhtmlWebpackPlugin 是用来压缩 css 保证引用关系 添加 hash 值等作用的\n![Alt text](image-43.png)\n插件里边的 chunks 就是这两行 script 的内容\n\n#### 使用 splitChunksPlugin\n\n![Alt text](image-44.png)\nminisize 为零 只要有引用就会设置为公共模块 1000 文件大小至少 1000B\nminChunks 要求至少引用两次\n创建文件夹 common/index.js 返回公共函数 在 search 和 index 页面下的 index.js 中引用 common.js 就会被 common.js\n这个 minsize 的单位是 B\n\n### 使用 SourceMap\n\n**_应该在开发环境中可用,生产环境关闭_**\n\n![Alt text](image-24.png)\n![Alt text](image-25.png)\n![Alt text](image-26.png)\nmode none 这样 js 就不会压缩了\n\n`devtool:eval`\n![Alt text](image-27.png)\n![Alt text](image-28.png)\n`devtool:sourcemap`\n![Alt text](image-29.png)\n![Alt text](image-30.png)\n`devtool:inlinesourcemap`\n很大 source map 被融入到 js 中\n本地开发 加速代码开发调试\n打开 webpack.dev.js 把多页面的东西拷贝过来\n\n打断点 `debugger; ` 打开检查 就可以看到打断点的地方\n\n![Alt text](image-31.png)\n`npm run dev`\n![Alt text](image-32.png)\n`cheap-sourcemap`\n![Alt text](image-33.png)\n只有行信息\n\n### 多页面应用打包通用方案\n\n![Alt text](image-21.png)\n多页面上线之后 有多个入口 单页面应用所有业务都只有一个入口 可能不同的页面用的是不同的 Hash 多页面应用相当于页面是解耦的\n多页面对 SEO 更加友好\n![Alt text](image-22.png)\n![Alt text](image-23.png)\n同步的方式查询出来\n改一下项目结构 每个页面为每个文件夹 对应文件都用 index.js 和 index.html\n`npm i glob -D`\nwebpack.prod.js 写一个函数 打包\n\n```js\nconst glob = require("glob");\nconst setMPA = () => {\n  const entry = {};\n  const htmlWebpackPlugins = [];\n\n  const entryFiles = glob.sync(path.join(__dirname, "./src/*/index.js"));\n  Object.keys(entryFiles).map((index)=>{\n   const entryFile=entryFiles[index];\n   const pageName=entryFile.match(/src\\(.*)\\/index\\.js);\n   const pageName=match&&match[1];\n   entry[pageName]=entryFile;\n   htmlWebpackPlugin.push({\n      new htmlWebpackPlugin({\n         template:path.join(__dirname,`src/${pageName}/index.html`),\n         filename:`${pageName}.html`,\n         chunks:[pageName],\n         inject:true;\n         minify:{\n            html5:true,\n            collapseWhitespace:true,\n            preserveLineBreaks:false,\n            minifyCSS:true,\n            minifyJS:true,\n            removeComments:false,\n         }\n\n      })\n   })\n  });\n  return {\n    entry,\n    htmlWebpackPlugins,\n  };\n};\n\n\n\nconst {entry,htmlWebpackPlugins}=setMPA();\nplugin:[].concat(htmlWebpackPlugins)\n```\n\n### 库没有办法内联\n\n打包的样式 内联图片字体等等\n![Alt text](image-14.png)\n![Alt text](image-15.png)\n\njs 有可能存在 es6 语法 0.5 版本\n![Alt text](image-16.png)\nmeta 都有一些信息\n![Alt text](image-17.png)\nhtmlinline 当中去就可以\n`npm i raw-loader@0.5.1 -D`\n![Alt text](image-18.png)\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n我们使用的 htmlWebpackPlugin 所以对一些插值是可以识别出来的 1js 的模板引擎 花括号语法\n`npm run build`\n\n### 移动转换为 rem\n\n![Alt text](image-8.png)\n![Alt text](image-9.png)\n![Alt text](image-10.png)\n![Alt text](image-11.png)\n\nrem 单位\n\n1. px to rem loader\n2. 一个 rem 等于多少 Px 页面打开(渲染)的时候动态计算\n   lib-flexible 计算根元素的 flex 值\n\n`npm i px2rem-loader -D`\n`npm i lib-flexible -S`\n直接引用它 -S 安装到项目依赖中\n\nremUnit 1rem=75px\npx->rem 小数点的位数 这是在生产环境中\n\n![Alt text](image-12.png)\n![Alt text](image-13.png)\n现在还没有办法内敛 并且位置需要相对靠前 应该立刻算出来\n\n### css3 前缀\n\n![Alt text](image-5.png)\n![Alt text](image-6.png)\n![Alt text](image-7.png)\nless 预处理 打包前处理\n这个是后置处理 生成完成之后 Postcss 也和厉害\n`npm i postcss-loader autoprefixer -D`\n-D 通常 dev npm run build\n最近两个版本 版本使用人数大于 1 ios7 以上的\n\n表现都是一致的 rem 自动适配 机型常见的设计\n稿是\n375 宽度 750 设计稿\n\n### 当前文件的问题\n\n![Alt text](image.png)\n![Alt text](image-1.png)\n![Alt text](image-2.png)\n`npm i clean-webpack-plugin -D`\n![Alt text](image-3.png)\n![Alt text](image-4.png)\ndev 和 product 都要创建\n\n# WebPack 进阶\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-07-19：19：12（星期四）</em></span></p>\n'}, {'id': 16, 'title': '003基础篇Webpack进阶用法_002', 'date': '2024-03-18', 'content': '### 数据的处理\n\n数据格式化\n![Alt text](image-127.png)\n![Alt text](image-128.png)\nsrc 下的 index\n![Alt text](image-130.png)\n\n```js\ndata = require("./data.json");\n```\n\n![Alt text](image-131.png)\n![Alt text](image-132.png)\n![Alt text](image-133.png)\n挂载到 window 对象上去\n\n### css 不显示\n\n![Alt text](image-120.png)\n![Alt text](image-121.png)\n![Alt text](image-122.png)\n![Alt text](image-123.png)\n二进制的 buffer 数据 需要转换为 utf8\n这里的关键点是 需要用到打包后的模板\n![Alt text](image-124.png)\n![Alt text](image-125.png)\n\n服务端渲染包括两个部分 一个是模板 一个是数据\n![Alt text](image-126.png)\nsrc 的 index.html\n![Alt text](image-129.png)\n\n### 总结\n\n![Alt text](image-116.png)\n这两个是对服务端和请求段做一个适配\n第二种需要写成 cssInJs 的写法\n![Alt text](image-117.png)\n![Alt text](image-118.png)\nclssName 不能写成字符串的写法\n![Alt text](image-119.png)\n会改变编程习惯 不推荐 样式显示不出来\n\n### 服务端渲染 SSR\n\n![Alt text](image-96.png)\n有一些 loader 或者进度条/placeholder 等等\n\n请求 css/js 然后解析 css/js 执行 js 会有加载的逻辑 SSR 优化加载时间\n![Alt text](image-97.png)\n服务端拉取数据更快\n![Alt text](image-98.png)\n![Alt text](image-99.png)\n服务端是并行加载 js 加载时串行加载\n![Alt text](image-100.png)\nSEO 搜索引擎优化\n![Alt text](image-101.png)\n有很多对象 window 等等 是没有办法获取的 reactdom 是对于这种东西的优化\n可以看到选中的 search-server 是不用 hash 的 因为它的意义并不是很大\n\n`webpack.ssr.js`\n![Alt text](image-102.png)\n\n`npm i express -D`\n\n以下这些内容 是创建一个 server/index.js 用来监听本地 3000\n构建的项目通过 build:ssr 的新项目 入口文件\n\n```js\nmkdir server/index.js\nconst express=require(\'express\');\nconst {renderToString} =require(\'react-dom/server\')\nconst SSR=require(\'../dist/search-server\');//加载组件\n\n\nfunction server=(port)=> {\n    const app=express();//实例化一下\n    app.use(express.static(\'dist\'));//比较方便 设置静态目录\n    app.get(\'/search\',(req,res)=>{//设置路由 request和responece\n        console.log(\'Server is running on port\');\n        const html=renderMarkup(renderToString(SSr));\n        res.status(200).send(html);//将加载的组件渲染为String\n\n    })\n    app.listen(port,()=>{//监听一下端口\n        console.log(\'Server is running on port:\'+port);\n    });\n}\nserver(prosess.env.PORT||3000);//监听的端口 nodeEnv设置的话 默认3000\nconst renderMarkup(str)=>{\n    return `<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n<div id=\'root\'>${str}</div>//放在容器里边\n</body>\n</html>\n    `;\n}\n\n```\n\n新建文件 search/index-server.js\n如果是服务端的话 原来的 index.js 应该封装一下 然后通过引用渲染 这里先不变 复制一份\n![Alt text](image-103.png)\nreact.dom 无法使用 必须通过 cjs\n![Alt text](image-104.png)\n编辑 webpack.ssr.js\n![Alt text](image-105.png)\nlibrary 写错了\nnpm run build-ssr\n开一个 node 的窗口 `node server/index.js` 报错了\n![Alt text](image-106.png)\n同构 window 我们需要做一个 hack\n![Alt text](image-107.png)\ndocument 报错发现错误 webpack.ssr.js 入口文件错误\n![Alt text](image-108.png)\n应该改为 index-server.js\n![Alt text](image-109.png)\n这里的 setMPA 是 html 组装插件 是用来控制页面组装的 可以分离\n这里匹配(match)也应该是 index-server.js 此外 我们只对 search 进行了服务端渲染\n所以这里需要改一改 如果有 index-server 这个入口 才进行 entry 的添加\n![Alt text](image-110.png)\n把这一段移动到大括号里边\nindex-server.js 也需要改一下\n![Alt text](image-111.png)\n打包构建\n`npm run build:ssr`服务端\n`node server/index.js` 本地 server\n![Alt text](image-112.png)\n这个报错是合理的 导出的时候是 module.export 但是导入的时候\n![Alt text](image-113.png)\n修改为\n![Alt text](image-114.png)\n![Alt text](image-115.png)\n\n### 打包组件库 框架\n\n![Alt text](image-88.png)\nroollup 适合打包组件 比较纯粹 但是 webpack 更加强大\n压缩版是开发的时候使用 非压缩版线上使用\n![Alt text](image-80.png)\n![Alt text](image-81.png)\n![Alt text](image-82.png)\ncdn 上边\n![Alt text](image-83.png)\n\n新建项目\n`npm i webpack webpack-cli -D`\n新建 `wegpack.config.js`\n`src/index.js`\n![Alt text](image-84.png)\n![Alt text](image-85.png)\n![Alt text](image-86.png)\n然后测试一下 将整个代码复制到浏览器控制台进行测试 将测试用例黏贴在函数下方即可\n这里边的 umd 就可以满足题目要求\n![Alt text](image-87.png)\n这里需要设置为 default 要不然还需要使用 libraryTarget.defalut 才能使用\n![Alt text](image-89.png)\n![Alt text](image-90.png)\n这里需要使用 TerserPlugin 其他的遇见 ES6 语法会报错 这个也是默认的 看一下 webpack 的依赖 发现依赖这个文件\n`npm i terser-webpack-plugin -D`\n![Alt text](image-91.png)\n![Alt text](image-92.png)\n![Alt text](image-93.png)\n![Alt text](image-94.png)\n![Alt text](image-95.png)\n使用钩子 prepublish 发布前会执行一下打包命令\n使用 npm login 登录账号 之后可以 npm publish\n测试功能是否正常\n\n### 构建和 Eslint\n\n![Alt text](image-67.png)\nEslint 检查代码\n![Alt text](image-68.png)\n![Alt text](image-69.png)\nerror 命中则抛出异常\n![Alt text](image-70.png)\n代码不正确则中断构建\n![Alt text](image-71.png)\nbuild 前面 添加一个检查\n![Alt text](image-72.png)\n![Alt text](image-73.png)\n一开始就用了 ESlint\n找到 Eslint-aalloy/airbnb 官方 github\neslint-confiairbnb\n![Alt text](image-74.png)\n`npm i eslint eslint-plugin-import eslint-plugin-react eslint-pluginjx-ally -D`\n`npm i elisnt-loader -D`\n![Alt text](image-75.png)\n`.eslintrc.js`\n![Alt text](image-76.png)\n`npm i babel-eslint -D`\n`npm i eslint-confiairbnb -D`\n![Alt text](image-77.png)\n![Alt text](image-78.png)\n如果继承多个 可以写成数组 还需要配置生效的环境\nrules 删掉 如果有和预设不一样的或者新的需求的 可以在 rules 添加\n如果需求为 4 个空格 但是预设里边时是两个\n![Alt text](image-79.png)\n\n### 代码分割和动态 import\n\n![Alt text](image-58.png)\n按需加载和懒加载(用到的才加载)\n![Alt text](image-59.png)\n![Alt text](image-60.png)\n\n![Alt text](image-61.png)\nsearch.js 使用了动态引用的语法 会分隔一个 js 文件\n实际使用了之后 再去加载 通过代码逻辑来控制\n![Alt text](image-65.png)\n`text.js`\n![Alt text](image-64.png)\n`index.js`\n![Alt text](image-62.png)\n动态 import 是一个括号 返回的是一个 promise 对象\n![Alt text](image-63.png)\n`onClick={this.loadComponent.bind(this)};`\n原理\n![Alt text](image-66.png)\n是 jsonP 的请求\n\n### ScopeHoisting\n\n![Alt text](image-48.png)\n![Alt text](image-49.png)\n![Alt text](image-50.png)\n![Alt text](image-51.png)\n![Alt text](image-52.png)\n![Alt text](image-53.png)\n\n![Alt text](image-54.png)\n`/* 0 */` module0 是入口代码 import 会被转化为 webpack_require\n![Alt text](image-55.png)\n传入的是个 module 数组 每个数组项都是一个 module\nharmony 是 es6 语法的简称\n手动开启 ScopeHoisting 如果是 productio 的话 代码会经过压缩\n![Alt text](image-56.png)\n只被引用一次 会内联进来 引用多次会提取出来 仍然存在闭包情况\n![Alt text](image-57.png)\n\n# 进阶用法\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-09-10：09：59（星期六）</em></span></p>\n'}, {'id': 17, 'title': '003基础篇Webpack进阶用法_003', 'date': '2024-03-18', 'content': '### 构建异常和中断处理\n\n![Alt text](image-145.png)\n![Alt text](image-146.png)\n![Alt text](image-147.png)\n![Alt text](image-148.png)\n![Alt text](image-149.png)\n这个时 webpack4 的写法\n![Alt text](image-150.png)\n这个是 webpack3 的写法 错误码改成了 1 服务端日志自动上报上去\n增加在开发阶段的体验\n\n### 优化构建时命令行的显示方式\n\n![Alt text](image-134.png)\n我们并不需要着重考虑这些东西 我们只需要考虑构建是否成功 error 或者 waring 的信息\n![Alt text](image-135.png)\n![Alt text](image-136.png)\n生产环境\n![Alt text](image-137.png)\n![Alt text](image-138.png)\n位置是有区别的\n![Alt text](image-139.png)\n明显的信息提示\n![Alt text](image-140.png)\n`npm i friendly-errors-webpack-plugin -D`\n\n```js\nprod.js\ncosnt FriendlyErrorsWebpackPlugin=require(\'friendly-errors-webpack-plugin\')\n\n```\n\n![Alt text](image-141.png)\nscopeHoisting 删掉 默认 production 会启动\n同样的加到 dev 里边去\n\n![Alt text](image-142.png)\n很明显的提示 构建成功了\n![Alt text](image-143.png)\n![Alt text](image-144.png)\nReact 中 组件的函数是不能支持箭头函数的\n\n## 进阶用法 3\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-09-20：07：28（星期六）</em></span></p>\n'}, {'id': 18, 'title': '004进阶篇编写可维护的webpack构建配置_001', 'date': '2024-03-18', 'content': '### 语义化版本\n\n![Alt text](image-50.png)\nalpha 内部测试 beta 小范围的测试 rc 公测\n![Alt text](image-51.png)\n![Alt text](image-52.png)\n大版本 此版本新增功能 修订好 bugFix\n![Alt text](image-53.png)\n`16.4.0-alpha.0`\n`16.4.0-alpha.1`\n\n### gitCommit 规范与 Changelog 生成\n\n![Alt text](image-47.png)\n![Alt text](image-48.png)\n![Alt text](image-49.png)\n只需要运行 changelog 就会自动生成\n\n### 发布构建包\n\n首先搜索包名 看看有没有被用过\n然后生成一下这个 changelog\n![Alt text](image-44.png)\n登录 npm 把字体和 dist 目录下都删除 持续集成之后还会生成 dist 目录\n![Alt text](image-45.png)\n发布之后自动提交 git 也会自动更新版本号\n![Alt text](image-46.png)\n\n### 持续集成\n\n![Alt text](image-33.png)\n产品快速迭代和质量保证\n![Alt text](image-34.png)\n![Alt text](image-35.png)\n![Alt text](image-36.png)\n![Alt text](image-37.png)\n![Alt text](image-38.png)\n激活项目\n![Alt text](image-39.png)\n在刚刚创建的项目中 将内容 git clone 下来 (这个是包含许可证的) 然后将我们的原来的项目 复制到克隆项目中 (builder-webpack) 然后将内容移动到根目录 创建\n`.travis.yml`\n![Alt text](image-40.png)\n注意 test 下面要有单元测试 上传到 github\n![Alt text](image-41.png)\n第一次报错 我们没有退回去 找不到 test\n![Alt text](image-42.png)\n第二次 我们配置本地路径和虚拟机路径不一样 是正确的 只需要修改一下\n\n```js\nassert.equal(\n  baseConfig.entry.index,\n  "/Users/cpselvis/my-project/builder-webpack/test/smoke/template/src/index/index.js"\n);\n\nassert.equal(\n  baseConfig.entry.index.indexOf(\n    "builder-webpack/test/smoke/template/src/index/index.js"\n  ) > -1,\n  true\n);\nassert.equal(\n  baseConfig.entry.search.indexOf(\n    "builder-webpack/test/smoke/template/src/index/index.js"\n  ) > -1,\n  true\n);\n```\n\n![Alt text](image-43.png)\n也可以把徽章添加到 README 中去\n\n### 单元测试\n\n![Alt text](image-26.png)\n细节的东西 单元测试的框架\njest 是 react 用的比较多 mocha 比较简单 也比较成熟\n详情请见本目录下 unit\n\n### 冒烟测试\n\n软件测试\n![Alt text](image-18.png)\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n![Alt text](image-21.png)\n详情见本目录下 smoke\n\n### 使用 Eslint 规范构建脚本\n\n![Alt text](image-8.png)\n`npm i eslint eslint-confiairbnb-base babel-eslint -D`\n安装完成之后 检查一下\n`./node_modules/.bin/eslint lib/`\n配置一下 eslint\n![Alt text](image-10.png)\nbuilder-webpack 下添加运行脚本\n![Alt text](image-9.png)\n可以看到报错信息\n![Alt text](image-11.png)\n然后将原来的 package.json 中依赖拷贝过来\n![Alt text](image-12.png)\n将项目相关的依赖 安装到 devDependencies 然后安装一下依赖\n`npm i`\n![Alt text](image-13.png)\n根据报错信息进行修改\n在 lib 下有需要用到的依赖 要安装到 dependencies 里边去\n![Alt text](image-14.png)\n禁用掉 eslint 的检查 说不让用 consolog\n![Alt text](image-15.png)\n\n### 构建配置包设计\n\n做的更加通用 webpack 构建包更加的通用 新的项目直接使用这个构建包\n![Alt text](image.png)\n四个方案\n![Alt text](image-1.png)\n\n小团队 10~20 12 方案结合起来是够用的\n![Alt text](image-2.png)\n对三种配置进行有效的组合\n![Alt text](image-3.png)\n![Alt text](image-4.png)\n![Alt text](image-5.png)\n\n`builder-webpack`\n`npm  init -y`\n![Alt text](image-6.png)\n\n#### 结尾安排\n\n本目录下边有源文件以及解析\n创建 test\n以及 README.\n.gitignore\n![Alt text](image-7.png)\n\n## 章节内容\n\n- 构建配置包设计\n- 功能模块设计和目录结构\n- 使用 ESLint 规范构建脚本\n- 冒烟测试介绍和实际运用\n- 单元测试和测试覆盖率\n- 持续集成和 Travis CI\n- 发布构建包到 npm 社区\n- Git Commit 规范和 changelog 生成\n- 语义化版本（Semantic Versioning）规范格式\n\n# webPack 第四章\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-09-22:03:15(星期六)</em></span></p>\n'}, {'id': 19, 'title': '004进阶篇编写可维护的webpack构建配置_SmokeTest', 'date': '2024-03-18', 'content': '在我们的 builder-webpack 文件夹下边创建 test 目录 下边创建\nsmoke/index.js\n和 template tempalte 拷贝一份 MYproject 的项目 编写 index.js\n安装 rimraf `npm i rimraf -D`\n\n首先 进入模板 changeDir 运行当前文件的目录 下的 template 删除当前目录下的\n\'dist\'文件夹 导入我们的配置 prod.js 当前目录下运行 webpack 命令 返回两个对象\n![Alt text](image-22.png)\n在 builder-webpack 文件夹下 运行 node test/smoke/index.js\n![Alt text](image-23.png)\nentry 为空 因为我们的当前项目是在 template 下边 但是 base.js 找的是 dirname 就是 base.js 本体下找 lib 下边 但是我们测试必须在 template 下边\n现在应该怎么办呢\n在 base.js 新建一行\n`const projectRoot=process.cwd()`因为我们运行测试的时候 将 process 进入到我们的 template 里边 那么 process.cwd 就是在我们的目录下边\n![Alt text](image-24.png) 都改一改 将`__dirname=projectRoot`替换\n第一步完成\n\n```js\nconst path = require("path");\nconst webpack = require("webpack");\nconst rimraf = require("rimraf");\nconst Mocha = require("mocha");\n\nconst mocha = new Mocha({\n  timeout: "10000ms",\n});\n\nprocess.chdir(path.join(__dirname, "template")); //\n\nrimraf("./dist", () => {\n  const prodConfig = require("../../lib/webpack.prod.js");\n\n  webpack(prodConfig, (err, stats) => {\n    //回调函数\n    if (err) {\n      //如果出错 打印错误信息\n      console.error(err);\n      process.exit(2);\n    }\n    console.log(\n      //正常 就输出对应的信息 color 不输出moudle 不输出children\n      stats.toString({\n        colors: true,\n        modules: false,\n        children: false,\n      })\n    );\n\n    console.log("Webpack build success, begin run test.");\n\n    mocha.addFile(path.join(__dirname, "html-test.js"));\n    mocha.addFile(path.join(__dirname, "css-js-test.js"));\n    mocha.run();\n  });\n});\n```\n\n看一下是不是有生成 html 和 css 文件生成\n新建 smoke/css-js-test.js+html-test\n用到的是 mocha 我们安装`npm i mocha -D`\n\n`html-test.js`\n`npm i glob-all -D`\n\n```js\nconst glob = require("glob-all");\n\ndescribe("Checking generated html files", () => {\n  it("should generate html files", (done) => {\n    //如果执行完成 就运行done函数\n    const files = glob.sync(["./dist/index.html", "./dist/search.html"]); //同步的方式 看看有没有生成出来\n\n    if (files.length > 0) {\n      done();\n    } else {\n      throw new Error("no html files generated");\n    }\n  });\n});\n```\n\n`css-js-test.js`\n\n```js\nconst glob = require("glob-all");\n\ndescribe("Checking generated css js files", () => {\n  it("should generate css js  files", (done) => {\n    //如果执行完成 就运行done函数\n    const files = glob.sync([\n      "./dist/index_*.js",\n      "./dist/index_*.css",\n      "./dist/search_*.js",\n      "./dist/search_*.css",\n    ]); //同步的方式 看看有没有生成出来\n\n    if (files.length > 0) {\n      done();\n    } else {\n      throw new Error("no html files generated");\n    }\n  });\n});\n```\n\n将用例加入到 index.js 中\n\n```js\nconst Mocha = require("mocha");\n\nconst mocha = new Mocha({\n  timeout: "10000ms", //设置一个超时时间 10s\n});\nconsole.log("webpack build sucees,begin run");\nmocha.addFile(path.join(__dirname, "html-test.js"));\nmocha.addFile(path.join(__dirname, "css-js-test.js"));\nmocha.run();\n```\n\n![Alt text](image-25.png)\n'}, {'id': 20, 'title': '004进阶篇编写可维护的webpack构建配置_unit', 'date': '2024-03-18', 'content': '### Mocha 测试框架\n\nMocha 也可以做很多异步的测试\n\n使用[Mocha](https://mochajs.org/)进行测试\n![Alt text](image-29.png)\n\n### 编写单元测试用例\n\n![Alt text](image-27.png)\n一个 It 就代表一个测试用例 except 断言 这里判断是否正确\n\n### 单元测试接入\n\n![Alt text](image-28.png)\n\n在 Chai 断言库中，except 并不是一个内置的关键字或方法。Chai 是一个 BDD（行为驱动开发）风格的断言库，用于在测试框架（如 Mocha）中编写更富有描述性和可读性的断言。它提供了一系列的断言方法，如 equal、notEqual、true、false、exist 等，用于验证代码的行为是否符合预期。\n\n**it**\nit 用于定义一个具体的测试用例。每个 it 块都应该包含一个描述性的名称和一个回调函数，该回调函数包含了测试代码。\n\n```js\nit("should return -1 when the value is not present", function () {\n  var array = [1, 2, 3];\n  var index = array.indexOf(4);\n  assert.equal(index, -1);\n});\n```\n\n### 实战\n\n在 test 下边新建一个 unit 文件夹 叫做单元测试 在 test 下创建 index.js 在 Unit 下边创建 webpackbasetest.js 来进行对 webpack-base.js 的测试\n入口 index.js 对总的进行管理\n\n```js\nconst path = require("path");\n\nprocess.chdir(path.join(__dirname, "smoke/template")); //运行的时候 还是需要跑到对应的路径下边去\n\ndescribe("builder-webpack test case", () => {\n  require("./unit/webpack-base-test");\n});\n```\n\n打开 webpack-base-test.js\n\n```js\ndescribe(\'webpack.base.js test case\',()={\n    const baseConfig=require(\'../../lib/webpack.base.config\');\n    console.log(baseConfig);\n    it(\'entry\',()=>{\n\n    })\n});\n```\n\n在 Builder-webpack 下边的 package.json 编写测试用例\n\n```js\n  "scripts": {\n    //"test": "./node_modules/.bin/_mocha", 会自动找到test/index.js\n    "test": "istanbul cover ./node_modules/.bin/_mocha",\n    "eslint": "eslint ./lib --fix"\n  },\n```\n\n运行之后 就会发现输出 base.config 安装断岩窟\n`npm i assets -D` 只有开发时候使用\n\n```js\nwebpackbasetest.js;\n\nconst assert = require("assert");\n\ndescribe("webpack.base.js test case", () => {\n  const baseConfig = require("../../lib/webpack.base.js");\n\n  it("entry", () => {\n    assert.equal(\n      baseConfig.entry.index,\n      "/Users/cpselvis/my-project/builder-webpack/test/smoke/template/src/index/index.js"\n    );\n    assert.equal(\n      baseConfig.entry.search,\n      "/Users/cpselvis/my-project/builder-webpack/test/smoke/template/src/search/index.js"\n    );\n  });\n});\n```\n\n![Alt text](image-30.png)\n这里复制的是这个路径\n![Alt text](image-31.png)\n之后就可以看到测试用例已经跑过了 每次发布版本的时候都可以跑一跑看一看对应的变量是不是和预想一样\n\n### 测试覆盖率\n\n推荐使用 istanbul\n`npm i -D istanbul`\n改一下 脚本\n\n```js\n  "scripts": {\n    //"test": "./node_modules/.bin/_mocha", 会自动找到test/index.js\n    "test": "istanbul cover ./node_modules/.bin/_mocha",\n    "eslint": "eslint ./lib --fix"\n  },\n```\n\n![Alt text](image-32.png)\n测试覆盖了 21 行 覆盖的分支是 28.57%\n'}, {'id': 21, 'title': '004进阶篇编写可维护的webpack构建配置_WebpackBaseJs', 'date': '2024-03-18', 'content': '#### Base.js\n\n资源解析与样式增强\n\n```js\nwebpack.base.js;\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /.js$/,\n        use: ["babel-loader"],\n      },\n      {\n        test: /.css$/,\n        use: [MiniCssExtractPlugin.loader, "css-loader"],\n      },\n      {\n        test: /.less$/,\n        use: [\n          MiniCssExtractPlugin.loader,\n          "css-loader",\n          "less-loader",\n          {\n            loader: "postcss-loader",\n            options: {\n              plugins: () => [\n                require("autoprefixer")({\n                  browsers: ["last 2 version", ">1%", "ios 7"],\n                }),\n              ],\n            },\n          },\n          {\n            loader: "px2rem-loader",\n            options: {\n              remUnit: 75,\n              remPrecision: 8,\n            },\n          },\n        ],\n      },\n      {\n        test: /.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: "file-loader",\n            options: {\n              name: "[name]_[hash:8].[ext]",\n            },\n          },\n        ],\n      },\n      {\n        test: /.(woff|woff2|eot|ttf|otf)$/,\n        use: [\n          {\n            loader: "file-loader",\n            options: {\n              name: "[name]_[hash:8][ext]",\n            },\n          },\n        ],\n      },\n    ],\n  },\n};\n```\n\n目录清理 多页面打包 命令行显示优化 错误捕获 css 提取\n\n```js\nbase.js\nconst autoprefixer = require(\'autoprefixer\');\nconst glob = require(\'glob\');\nconst path = require(\'path\');\nconst CleanWebpackPlugin = require(\'clean-webpack-plugin\');//目录清理\nconst FriendlyErrorsWebpackPlugin = require(\'friendly-errors-webpack-plugin\');\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\');//多页面打包\nconst MiniCssExtractPlugin = require(\'mini-css-extract-plugin\');\n\nconst projectRoot = process.cwd();\n\nconst setMPA = () => {//多页面打包\n  const entry = {};\n  const htmlWebpackPlugins = [];\n  const entryFiles = glob.sync(path.join(projectRoot, \'./src/*/index.js\'));\n\n  Object.keys(entryFiles)\n    .map((index) => {\n      const entryFile = entryFiles[index];\n      // \'/Users/cpselvis/my-project/src/index/index.js\'\n\n      const match = entryFile.match(/src\\/(.*)\\/index\\.js/);\n      const pageName = match && match[1];\n\n      entry[pageName] = entryFile;\n      return htmlWebpackPlugins.push(\n        new HtmlWebpackPlugin({\n          inlineSource: \'.css$\',\n          template: path.join(projectRoot, `./src/${pageName}/index.html`),\n          filename: `${pageName}.html`,\n          chunks: [\'vendors\', pageName],\n          inject: true,\n          minify: {\n            html5: true,\n            collapseWhitespace: true,\n            preserveLineBreaks: false,\n            minifyCSS: true,\n            minifyJS: true,\n            removeComments: false,\n          },\n        })\n      );\n    });\n\n  return {\n    entry,\n    htmlWebpackPlugins,\n  };\n};\n\nconst { entry, htmlWebpackPlugins } = setMPA();//多页面打包\nmodule.exports={\n    entry: entry,\n    ...\n    plugins: [\n    new MiniCssExtractPlugin({//css提取\n      filename: \'[name]_[contenthash:8].css\',\n    }),\n    new CleanWebpackPlugin(),//目录清理\n    new FriendlyErrorsWebpackPlugin(),//命令行优化\n    function errorPlugin() {//错误捕获\n      this.hooks.done.tap(\'done\', (stats) => {\n        if (stats.compilation.errors && stats.compilation.errors.length && process.argv.indexOf(\'--watch\') === -1) {\n          process.exit(1);\n        }\n      });\n    },\n  ].concat(htmlWebpackPlugins),//.concat多页面打包\n  stats: \'errors-only\',//错误捕获\n}\n```\n'}, {'id': 22, 'title': '004进阶篇编写可维护的webpack构建配置_WebpackDevJS', 'date': '2024-03-18', 'content': "webpack.dev.js\n\n```js\nnpm i webpack-merge -D\n\nconst merge = require('webpack-merge');\nconst webpack = require('webpack');\nconst baseConfig = require('./webpack.base');\n\nconst devConfig = {\n  mode: 'production',\n  plugins: [\n    new webpack.HotModuleReplacementPlugin(),//代码热更新\n  ],\n  devServer: {//devServer\n    contentBase: './dist',\n    hot: true,\n    stats: 'errors-only',\n  },\n  devtool: 'cheap-source-map',//sorcemap\n};\n\nmodule.exports = merge(baseConfig, devConfig);\n```\n"}, {'id': 23, 'title': '004进阶篇编写可维护的webpack构建配置_WebpackProdJS', 'date': '2024-03-18', 'content': '## Webpack.prod.js\n\n- 代码压缩\n- 文件指纹\n- Treeshaking\n- ScopeHoisting\n- 速度优化(基础包 CDN)\n- 体积优化(代码分隔)\n\nTreeshaking ScopeHoisting 是内置的\n\n```js\nconst merge = require("webpack-merge");\nconst cssnano = require("cssnano");\n\nconst HtmlWebpackExternalsPlugin = require("html-webpack-externals-plugin");\nconst OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");\nconst baseConfig = require("./webpack.base");\n\nconst prodConfig = {\n  mode: "production", //注意设置一下mod\n  plugins: [\n    new OptimizeCSSAssetsPlugin({\n      //这个是压缩体积\n      assetNameRegExp: /\\.css$/g,\n      cssProcessor: cssnano, //处理器 cssnano  删除重复的规则 无用的参数 无用的前缀\n      //用来压缩css体积\n    }),\n    new HtmlWebpackExternalsPlugin({\n      externals: [\n        {\n          module: "react",\n          entry: "https://11.url.cn/now/lib/16.2.0/react.min.js",\n          global: "React",\n        },\n        {\n          module: "react-dom",\n          entry: "https://11.url.cn/now/lib/16.2.0/react-dom.min.js",\n          global: "ReactDOM",\n        },\n      ],\n    }),\n  ],\n  optimization: {\n    splitChunks: {\n      //这个才是本题 这个用来分隔css 保证按需引入\n      minSize: 0, //最小的也会被分隔\n      cacheGroups: {\n        commons: {\n          name: "vendors",\n          chunks: "all",\n          minChunks: 2, //至少被两个chunks共相 才会被假如缓存组\n        },\n      },\n    },\n  },\n};\n\nmodule.exports = merge(baseConfig, prodConfig);\n```\n'}, {'id': 24, 'title': '004进阶篇编写可维护的webpack构建配置_WebpackSSRJS', 'date': '2024-03-18', 'content': 'webpack.ssr.js\n\n```js\nconst cssnano = require("cssnano");\nconst merge = require("webpack-merge");\nconst HtmlWebpackExternalsPlugin = require("html-webpack-externals-plugin");\nconst OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");\nconst baseConfig = require("./webpack.base");\n\nconst prodConfig = {\n  mode: "production",\n  module: {\n    rules: [\n      //对于css我们是不解析的\n      {\n        test: /\\.css$/,\n        use: "ignore-loader",\n      },\n      {\n        test: /\\.less$/,\n        use: "ignore-loader",\n      },\n    ],\n  },\n  plugins: [\n    new OptimizeCSSAssetsPlugin({\n      assetNameRegExp: /\\.css$/g,\n      cssProcessor: cssnano,\n    }),\n    new HtmlWebpackExternalsPlugin({\n      externals: [\n        {\n          module: "react",\n          entry: "https://11.url.cn/now/lib/16.2.0/react.min.js",\n          global: "React",\n        },\n        {\n          module: "react-dom",\n          entry: "https://11.url.cn/now/lib/16.2.0/react-dom.min.js",\n          global: "ReactDOM",\n        },\n      ],\n    }),\n  ],\n  optimization: {\n    splitChunks: {\n      minSize: 0,\n      cacheGroups: {\n        commons: {\n          name: "commons",\n          chunks: "all",\n          minChunks: 2,\n        },\n      },\n    },\n  },\n};\n\nmodule.exports = merge(baseConfig, prodConfig);\n```\n'}, {'id': 25, 'title': '005进阶篇Webpack构建速度与体积优化_001', 'date': '2024-03-18', 'content': '![Alt text](image-46.png)\n\n### 使用动态 Polyfill 服务\n\n![Alt text](image-39.png)\n![Alt text](image-40.png)\n![Alt text](image-41.png)\nes5-shin User-agent 会动态的\n![Alt text](image-42.png)\n![Alt text](image-43.png)\n![Alt text](image-44.png)\n最新版什么都给不用下发\n改为 iphonx\n![Alt text](image-45.png)\n\n可以看到下发的已经发生改变 国内的 UserAgent 被魔改 有可能不正确\n\n### 使用 webpack 进行图片压缩\n\n构建体积 我们会打开浏览器 network 看看资源加载的时序图\n![Alt text](image-36.png)\njs 和 css 都比较小 配置过 loader 就可以进行资源的优化\n![Alt text](image-37.png)\n可以定制 可以用其他插件对其进行优化\n压缩原理\n![Alt text](image-38.png)\n图片网站 [没有版权问题的图片网站](https://unsplash.com)\n\n```js\nimport bg from "./images/bg.jpg";\nimport logo from "./images/logo.png";\nimport "./search.less";\n\nclass Search extends React.Component {\n  render() {\n    const { Text } = this.state;\n    const addResult = largeNumber("999", "1");\n    return (\n      <div className="search-text">\n        {Text ? <Text /> : null}\n        {addResult}\n        <img src={bg} />\n        搜索文字的内容\n        <img src={logo} onClick={this.loadComponent.bind(this)} />\n      </div>\n    );\n  }\n}\n\n//webpack.prod.js\n {\ntest: /.(png|jpg|gif|jpeg)$/,\nuse: [\n    {\n        loader: \'file-loader\',\n        options: {\n            name: \'[name]_[hash:8].[ext]\'\n        }\n    },\n    {\n        loader: \'image-webpack-loader\',\n        options: {\n          mozjpeg: {\n            progressive: true,\n            quality: 65\n          },\n          // optipng.enabled: false will disable optipng\n          optipng: {\n            enabled: false,\n          },\n          pngquant: {\n            quality: \'65-90\',\n            speed: 4\n          },\n          gifsicle: {\n            interlaced: false,\n          },\n          // the webp option will enable WEBP\n          webp: {\n            quality: 75\n          }\n        }\n    }\n]\n},\n```\n\n### 使用 Tree Shaking 擦除无用的 JavaScript 和 CSS\n\n![Alt text](image-33.png)\n![Alt text](image-34.png)\n![Alt text](image-35.png)\n提取 css 为一个文件的插件配合使用\nprod.js\n\n```js\nconst PurgecssPlugin = require("purgecss-webpack-plugin");\nconst PATHS = {\n  src: path.join(__dirname, "src"),\n};\nnew PurgecssPlugin({\n  paths: glob.sync(`${PATHS.src}/**/*`, { nodir: true }),\n});\n//必须是绝对路径\n//如果是多页面 必须要使用 glob来匹配出来\n//这个glob就是一个用来匹配所有符合条件的库\n```\n\n### 缩小构建目标\n\nprod.js\n![Alt text](image-31.png)\n这些组件会被分析 但是是没有必要的\n![Alt text](image-32.png)\n\n- 解析的选项 当前项目找 先 nodemodules 找 父目录 但是第三方一般都在根目录 可以省去这些步骤\n- package 必须要有 main 字段 我们直接找 main 跟项目 index.js lib 下边的 index.js\n  这个优化 是只找 package 下 main 的入口文件\n- 如果引入 不加.js 没有找到对应文件 就找 index.json 默认支持这两种文件 优化 extension 配置\n\n我们直接 import react 是需要寻找的 如果我们预先处理过别名 就比较方便了\n\n```js\nresolve: {\n        alias: {\n            \'react\': path.resolve(__dirname, \'./node_modules/react/umd/react.production.min.js\'),\n            \'react-dom\': path.resolve(__dirname, \'./node_modules/react-dom/umd/react-dom.production.min.js\'),\n        },\n        extensions: [\'.js\'],\n        mainFields: [\'main\']\n    }\n```\n\n### 充分利用缓存提升二次构建速度\n\n生产环境 webpack.prod.js\n\n缓存策略非常的棒 浏览器缓存 服务端缓存 数据库缓存都是非常棒的\n![Alt text](image-28.png)\nbabel 第二次缓存非常的快 代码压缩缓存 代码压缩速度\n\n```js\nwebpack.prod.js\nnew HappyPack({\n  // 3) re-add the loaders you replaced above in #1:\n  loaders: [ \'babel-loader?cacheDirectory=true\' ]\n}),\n2.\noptimization: {\n    minimizer: [\n        new TerserPlugin({\n            parallel: true,\n            cache: true\n        })\n    ]\n},\n```\n\n可以查看`.node_modules/.cache/terser-webpack-plugin`目录下边\n安装插件\n![Alt text](image-29.png)\n\n```js\nwebpack.prod.js\nconst HardSourceWebpackPlugin = require(\'hard-source-webpack-plugin\');\nplugins: [\n        new HardSourceWebpackPlugin(),\n```\n\n![Alt text](image-30.png)\n显示显存空间\n\n### 进一步分包：预编译资源模块 DLLpuligin\n\n分包\n![Alt text](image-24.png)\n一个库就要指定一次 业务包 会被用很多次 提取生辰一个文件 一个页面可能会被下载多次\n![Alt text](image-25.png)\n分包过程\n![Alt text](image-26.png)\n再项目中引用\n![Alt text](image-27.png)\n对这个包的描述 基础包和业务包 只需要基础包就要 引入基础包的 json\n如果两者都需要 指定一下 mainfest 的 json 文件\n构建好之后 就会有一个基础包的插件 可以把很多个包都打包再一起\n创建一个新的文件 `webpack.dll.js` 这个库生成之后 还需要一个 RefPlugin 的插件 用来替换库应该\n\n```js\n//添加新的脚本 script\n"dll": "webpack --config webpack.dll.js"\n//webpack.dll.js\nconst path = require(\'path\');\nconst webpack = require(\'webpack\');\n\nmodule.exports = {\n    entry: {//入口\n        library: [// 框架业务包 分离为一个文件\n            \'react\',\n            \'react-dom\'\n        ]\n    },\n    output: {\n        filename: \'[name]_[chunkhash].dll.js\',// filename 和 path\n        //占位符之后就是 library.dll.js\n        path: path.join(__dirname, \'build/library\'),\n        //build文件 如果是dist就会清除 dist 也不会引用\n        library: \'[name]\'\n        //导出的库的名字 也叫library\n    },\n    plugins: [\n      //对包的描述和引用\n        new webpack.DllPlugin({\n            name: \'[name]_[hash]\',//基础包也可以有一个hash\n            path: path.join(__dirname, \'build/library/[name].json\')\n            //相同的目录下边 也放一个json\n        })\n    ]\n};\n\n```\n\n解释点 这里需要一个 chunkahs 是输出的对应的 chunk 文件 使用 chunkhash 管理对应的块 而 mainfest 和整个 dll 动态链接库都有关 所以使用 hash 只要有东西变化都要进行更新 重新下载 mainfest\n\n#### 在 webpack.prod.js 中引用我们的包\n\n```js\nnew webpack.DllReferencePlugin({\n    manifest: require(\'./build/library/library.json\')\n}),\n```\n\n`npm run build`\n\n这样可以提升构建速度 相对于生产环境来讲 可以保证基础库脱离主应用程序编译来进行\n总结来说，DLL 库的编译先于主程序的编译进行。这是因为 DLL 库是主程序所依赖的一部分代码，需要先编译好并提供给主程序使用。通过分离 DLL 库的编译和主程序的编译，可以实现构建过程的优化，提高构建速度。\n\n我们这里会自动清除 dist 目录下 文件 这个是相对于生产环境来说的 库分离出来 就可以保证基础库 react 不会重复编译 不分包 相当于每段被用到的都会被编译一次 因为 import 相当于插入\n\n### 多进程并行压缩代码\n\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n不支持 es6\n![Alt text](image-21.png)\n这个默认 webpack4 支持 es6 语法\n这个数值就是当前默认电脑 cpu 数量两倍减去 1\n![Alt text](image-22.png)\n首先安装一下\n![Alt text](image-23.png)\n这里注意一下装填位置\n\n### 多进程/多实例构建\n\n![Alt text](image-13.png)\n![Alt text](image-14.png)\n![Alt text](image-15.png)\n![Alt text](image-18.png)\n对 seacrch 界面多复制几份 直接构建 84s\n`npm i --save-dev happypack`\n\n```js\nconst Happypack = require("happypack");\nmodule: {\n        rules: [\n            {\n                test: /.js$/,\n                use: [\n                    \'happypack/loader\'\n                ]\n            },\n        ],\n    }\nplugins: [\n        new MiniCssExtractPlugin({\n            filename: \'[name]_[contenthash:8].css\'\n        }),\n        new HappyPack({\n            // 3) re-add the loaders you replaced above in #1:\n            loaders: [ \'babel-loader?cacheDirectory=true\' ]//我们刚刚替换的loader\n        }),\n]\n//共  23s\n```\n\n使用 thread.loader\n`npm i thread-loader -D`\n\n```js\nmodule: {\n  rules: [\n    {\n        test: /.js$/,\n        {\n          loader: \'thread-loader\',\n          options: {\n            workers: 3\n          }\n        },\n        \'babel-loader\',\n    },\n],\n\n```\n\n### 使用高版本的 webpack 和 Node.js\n\n![Alt text](image-16.png)\n![Alt text](image-17.png)\n\n### 体积分析：使用 webpack-bundle-analyzer\n\n![Alt text](image-6.png)\n可以看到 babel-polyfill 是面积很大的 有没有一种方法可以优化呢\n之后的章节会讲到这种\n![Alt text](image-7.png)\n![Alt text](image-8.png)\n`npm i webpack-bundle-analyzer -D`\n\n```js\nconst { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");\n```\n\n![Alt text](image-9.png)\n效果展示\n![Alt text](image-10.png)\n![Alt text](image-11.png)\n效果还不是特别明显我们可以增加一个 babelpolyfill\n使用命令 `npm i babel-polyfill -S`\n在 index.js(builderWebpack)中引入\n`import \'babel-polyfill\'`注释 react 和 react-dom 的分割\n![Alt text](image-12.png)\n\n### 速度分析：使用 speed-measure-webpack-plugin\n\n![Alt text](image-2.png)\n每个 loader 和插件的耗时状态 插件执行比较慢\n我们也可以针对性的对某个比较耗时的步骤进行优化 sassloader 比较耗时 可不可以使用 less 会更好一些\n对于这些插件 我们可以通过查看插件的源码 看看有没有地方可以进行优化\n\n![Alt text](image-3.png)\n插件的用法\n![Alt text](image-4.png)\n`npm i --save-dev speed-measure-webpack-plugin`\n只在开发环境可用\n\n```js\nconst SpeedMeasureWebpackPlugin = require("speed-measure-webpack-plugin");\nconst smp = new SpeedMeasureWebpackPlugin();\n\nmodule.exports = smp.wrap({\n  entry: entry,\n  output: {\n    path: path.join(__dirname, "dist"),\n    filename: "[name]_[chunkhash:8].js",\n  },\n  mode: "production",\n  module: {\n    rules: [{}],\n  },\n});\n```\n\n用定义的对象将模块包裹起来 使用 build 即可看到效果 非常的明显\n![Alt text](image-5.png)\n\n### 初级分析：使用 webpack 内置的 stats\n\n使用 webpack 内置的 stats\n![Alt text](image.png)\n![Alt text](image-1.png)\n运行成功 此外 如果关闭 FriendlyErrorWebpackPlugin 和 status error-only 就可以看到更为详细的信息\n\n## 005 进阶篇 Webpack 构建速度与体积优化\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-10-17：48：14（星期日）</em></span></p>\n'}, {'id': 26, 'title': '006原理篇源码掌握Webpack打包原理_001', 'date': '2024-03-18', 'content': '### Tapable 是如何和 webpack 进行关联起来的？\n\n![Alt text](image-26.png)\n查看这段代码 option 创建 compiler 对象 然后给插件传递一个 compiler 对象\n所以我们的插件 必须有一个 apply 方法 然后这个方法用来接收一个对象 输入的有 plugin 并且是个数组 挨个的将 compiler 对象传递给这个插件\n然后这个插件就可以调用 compiler 对象的 hooks 对这个 compiler 对象的关键节点进行监听 一旦触发 插件就可以自动的进行执行\n最后一行就是内部插件的执行\n结论\n\n1. 插件必须有 apply 方法 接受一个 compiler 对象\n2. 插件对事件进行监听 一旦触发 插件就会自动执行 文件写入 代码构建等等\n\n![Alt text](image-27.png)\n![Alt text](image-28.png)\n![Alt text](image-29.png)\n\nrun 就是入口 同步使用 call 来执行 异步使用 promise 执行 执行过这段代码之后 插件就具备了 监听 hook 的功能\n![Alt text](image-30.png)\n先注入进来 然后是外部传递 内部插件 webpack-cli 的 run 方法\n\n### Tapable 插件架构与 Hooks 设计\n\n![Alt text](image-18.png)\ntapable 是发布订阅的模块\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n监听钩子 做不同的事情\n\n熔断 遇见 return 返回\n流水 结果传递给下一个插件\n异步 并行\n![Alt text](image-21.png)\n![Alt text](image-22.png)\n\n![Alt text](image-23.png)\n![Alt text](image-24.png)\n![Alt text](image-25.png)\n\n```js\nconst { SyncHook } = require("tapable");\n\nconst hook = new SyncHook(["arg1", "arg2", "arg3"]);\n//传参是一个数组\n\nhook.tap("hook1", (arg1, arg2, arg3) => {\n  //绑定\n  console.log(arg1, arg2, arg3);\n});\n\nhook.call(1, 2, 3); //执行\n```\n\n```js\nconst { SyncHook, AsyncSeriesHook } = require("tapable");\n\nclass Car {\n  constructor() {\n    this.hooks = {\n      accelerate: new SyncHook(["newspeed"]),\n      brake: new SyncHook(),\n      calculateRoutes: new AsyncSeriesHook(["source", "target", "routesList"]),\n    }; //这个是对象\n  }\n}\n\nconst myCar = new Car();\n\n//绑定同步钩子\nmyCar.hooks.brake.tap("WarningLampPlugin", () =>\n  console.log("WarningLampPlugin")\n);\n\n//绑定同步钩子 并传参\nmyCar.hooks.accelerate.tap("LoggerPlugin", (newSpeed) =>\n  console.log(`Accelerating to ${newSpeed}`)\n);\n\n//绑定一个异步Promise钩子\nmyCar.hooks.calculateRoutes.tapPromise(\n  "calculateRoutes tapPromise",\n  (source, target, routesList, callback) => {\n    // return a promise\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        console.log(`tapPromise to ${source} ${target} ${routesList}`);\n        resolve();\n      }, 1000);\n    });\n  }\n);\n\nmyCar.hooks.brake.call();\nmyCar.hooks.accelerate.call(10);\n\nconsole.time("cost"); //开始计时\n\n//执行异步钩子\nmyCar.hooks.calculateRoutes.promise("Async", "hook", "demo").then(\n  () => {\n    console.timeEnd("cost"); //结束计时 输出计时时间\n  },\n  (err) => {\n    console.error(err);\n    console.timeEnd("cost");\n  }\n);\n```\n\n### webpack-cli 源码阅读\n\n有点干 后边还会自己手写 不着急这个\n\n![Alt text](image-13.png)\n![Alt text](image-14.png)\n有些命令 并不会实例化 webpack\n![Alt text](image-15.png)\n![Alt text](image-16.png)\n![Alt text](image-17.png)\n\n### webpack 启动过程分析\n\n![Alt text](image.png)\n\n`node_dodules/.bin` 运行之后 会在这个目录下边找对应的命令 这个是 npm 找到对应的命令\n然后找`node_modules` 下边的 webpack 和 webpack_cli 如果想要在 node_modules/bin 有对应的命令 必须在对应插件的 package.json 有对应的 bin 字段进行指定\n这个下面 webpack/package.json 对应的有\n![Alt text](image-3.png)\n\n![Alt text](image-4.png)\n然后 node 就会在这个插件下的 bin 找到对应的插件\n\n全局安装命令 是在 User/local/bin 去找 在 linux 中 bin 目录存放的是系统中基于值编码的可执行文件\n这些文件是 Linux 系统启动和运行过程中必需的同样的 各种工具的启动命令也一般在 bin 下边找\n![Alt text](image-1.png)\n\n然后看一下这个实际文件的 js 文件内容实际是什么\n![Alt text](image-2.png)\nexitcode 0 error null 如果报错 会修改 exitcode 并让 error 跑出来\n\n![Alt text](image-6.png)\n![Alt text](image-5.png)\n2\n开一个子进程 快速执行一个命令 而不需要手动在命令行执行命令\n![Alt text](image-7.png)\n3 通过 reqire 来判断\n![Alt text](image-8.png)\n4 webpack 数组 cli-webpack 所有特性 和 command 更轻量级\nwebpack 分离出来了 但是还是需要调用 cli 只需要 cli 和 webpack 其中一个\ncli 更加丰富一点\n5 ![Alt text](image-9.png)\n判断有没有被安装 两个都安装应该是 2 只安装一个数量就是 1\n![Alt text](image-10.png)\n![Alt text](image-11.png)\n这里出现了 run command 方法 是用来对应自动安装的 manager 是 npm 或者 yarn\n![Alt text](image-12.png)\n\n# 章节 6\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-16-19：39：15（星期六）</em></span></p>\n'}, {'id': 27, 'title': '006原理篇源码掌握Webpack打包原理_002', 'date': '2024-03-18', 'content': '```js\n(function(modules) {\n    var installedModules = {};\n\n    function _webpack_require_( moduleId)\n        {if (installedModules[moduleId])\n            return installedModules[moduleId].exports;\n\n    var module = installedModules [moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n        };\n\n    modules[moduleId].call(module.exports,module,module.exports，_webpack_require_);\n    module.l = true;\n    return module.exports;\n}\n    webpack_require___(0);\n})([\n/* 0 module */\n(function (module，_webpack_exports__, _webpack_require__) {\n    ...\n}),\n/*1 module */\n(function ( module，_webpack_exports_, __webpack_require__) {...\n}),\n/*n module */\n(function (module，_webpack_exports__, _webpack_require__) {\n    ...\n})\n\n```\n\n### (4)\n\n```js\nconstructor(options) {//我们传入了webpack的配置\n        const { entry, output } = options;\n        this.entry = entry;\n        this.output = output;\n        this.modules = [];//\n    }\nemitFiles() {\n    const outputPath = path.join(this.output.path, this.output.filename);\n    let modules = \'\';\n    this.modules.map((_module) => {\n        modules += `\'${ _module.filename }\': function (require, module, exports) { ${ _module.transformCode } },`\n    });\n\n    const bundle = `\n        (function(modules) {\n            function require(fileName) {\n                const fn = modules[fileName];\n\n                const module = { exports : {} };\n\n                fn(require, module, module.exports);\n\n                return module.exports;\n            }\n\n            require(\'${this.entry}\');\n        })({${modules}})\n    `;\n\n    fs.writeFileSync(outputPath, bundle, \'utf-8\');\n}\n```\n\n### 动手编写一个简易的 webpack(下)(3)\n\n```js\nconstructor(options) {\n    const { entry, output } = options;\n    this.entry = entry;\n    this.output = output;\n    this.modules = [];\n}\nrun() {\n    const entryModule = this.buildModule(this.entry, true);\n    this.modules.push(entryModule);\n    this.modules.map((_module) => {//处理依赖\n        _module.dependencies.map((dependency) => {\n            this.modules.push(this.buildModule(dependency));\n        });\n        //不断遍历dependencies 依赖 每个module的模块\n    });\n    //console.log\n    this.emitFiles(this.modules);//生成文件\n}\nbuildModule(filename, isEntry) {\n    let ast;\n    if (isEntry) {//如果是入口模块\n        ast = getAST(filename);//绝对路径\n    } else {//根目录 找到src\n        let absolutePath = path.join(process.cwd(), \'./src\', filename);//相对路径 转化为绝对路径\n        ast = getAST(absolutePath);\n    }\n\n    return {\n        filename,\n        dependencies: getDependencis(ast),\n        transformCode: transform(ast)\n    };\n}\n```\n\n输出的效果\n![Alt text](image-49.png)\n\n### 动手编写一个简易的 webpack(下)(2)\n\nparser\n\n```js\nes6->ast\ngetDependencis: (ast) => {\n    const dependencies = [];\n    traverse(ast, {\n      ImportDeclaration: ({ node }) => {//分析import语句\n        dependencies.push(node.source.value);//\n      },\n    });\n    return dependencies;\n  },\n```\n\nast->es5\n\n```js\ntransform: (ast) => {\n    const { code } = transformFromAst(ast, null, {\n      presets: ["env"],//ast null presets  env es2015 2016都可以解析出来\n    });\n\n    return code;\n  },\n```\n\n安装`npm i babel-preset-env -S`\n新建文件 `.babelrc` 指定 env 模板\n\n```js\n{\n    "presets":[\n        "@babel/preset-env"\n    ]\n}\n```\n\n效果\n![效果](image-48.png)\n\n### 动手编写一个简易的 webpack(下)\n\n![Alt text](image-46.png)\n![Alt text](image-47.png)\n\nsrc/index.js\n\n```js\nimport { greeting } from "./greeting.js";\n\ndocument.write(greeting("Jane"));\n\n//greeting .js\nexport function greeting(name) {\n  return "hello" + name;\n}\n```\n\n```js\nsimplePack.config.js;\n("use strict");\n\nconst path = require("path");\n\nmodule.exports = {\n  entry: path.join(__dirname, "./src/index.js"),\n  output: {\n    path: path.join(__dirname, "./dist"),\n    filename: "main.js",\n  },\n};\n```\n\nlib/\n\n```js\n//模块内容 与功能\nindex.js\nparser 解析Ast语法树 Es6->Es5 分析依赖\ncompile 执行文件的输出\n```\n\nwebpack/index.js\n\n```js\nconst Compiler = require("./compiler"); //实例化\n\nconst options = require("../simplepack.config"); //获取我们的配置\n\nnew Compiler(options).run(); //入口\n```\n\ncompiler.js\n\n```js\nmodule.exports = class Compiler {\n  constructor(options) {\n    const { entry, output } = options;\n    this.entry = entry;\n    this.output = output;\n    this.modules = [];\n  } //构造函数\n\n  run() {} //入口\n\n  buildModule(filename, isEntry) {} //模块构建\n\n  emitFiles() {} //生成文件\n};\n```\n\nparser\n\n```js\nconst fs = require("fs");\nconst babylon = require("babylon"); //安装babylon\nconst traverse = require("babel-traverse").default;\nconst { transformFromAst } = require("babel-core");\n\nmodule.exports = {\n  //导出函数\n  getAST: (path) => {\n    //path=>code\n    const content = fs.readFileSync(path, "utf-8");\n\n    return babylon.parse(content, {\n      sourceType: "module",\n    });\n  },\n  getDependencis: (ast) => {\n    const dependencies = [];\n    traverse(ast, {\n      ImportDeclaration: ({ node }) => {\n        dependencies.push(node.source.value);\n      },\n    });\n    return dependencies;\n  },\n  transform: (ast) => {\n    const { code } = transformFromAst(ast, null, {\n      presets: ["env"],\n    });\n\n    return code;\n  },\n};\n```\n\n测试一下\n\n```js\ntest.js;\nconst { getAST } = require("./parser");\nconst path = require("path");\nconsole.log(getAST(path.join(__dirname, "../src/index.js")));\n```\n\n### 动手编写一个简易的 webpack(上)\n\n![Alt text](image-41.png)\n![Alt text](image-42.png)\nes import 是静态分析的\ncjs require 是动态分析的 动态 reqire\n一般都是通过 es6\n![Alt text](image-43.png)\n\n1. 模板引擎\n2. 变成语言 es6->es5\n\n![Alt text](image-44.png)\n引入第 0 个模块\n![Alt text](image-45.png)\n\n### webpack 流程篇：文件生成\n\njs chunkhase css contentHash\n\n### webpack 流程篇：模块构建和 chunk 生成阶段\n\n![Alt text](image-34.png)\n![Alt text](image-35.png)\n![Alt text](image-36.png)\n模块构建\ncontextmodule 是前面有路径的 Module\n![Alt text](image-37.png)\n![Alt text](image-38.png)\n![Alt text](image-39.png)\n![Alt text](image-40.png)\n\n### webpack 流程篇：准备阶段\n\n![Alt text](image-31.png)\n一类型的东西收归\n\nast compilation 模块的编译 准备阶段 模块打包 模块优化 输出磁盘\n![Alt text](image-32.png)\n![Alt text](image-33.png)\n转换为内部的插件\n\n# Ch6-2\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-17-14：32：45（星期日）</em></span></p>\n'}, {'id': 28, 'title': '006原理篇源码掌握Webpack打包原理_webpackCore', 'date': '2024-03-18', 'content': '![Alt text](image-44.png)\n\n```js\nwebpack中为什么这样写 (function(modules) {\n    var installedModules = {};\n\n    function _webpack_require_( moduleId)\n        {if (installedModules[moduleId])\n            return installedModules[moduleId].exports;\n\n    var module = installedModules [moduleId] = {\n        i: moduleId,\n        l: false,\n        exports: {}\n        };\n\n    modules[moduleId].call(module.exports,module,module.exports，_webpack_require_);\n    module.l = true;\n    return module.exports;\n}\n    webpack_require___(0);\n})([\n/* 0 module */\n(function (module，_webpack_exports__, _webpack_require__) {\n    ...\n}),\n/*1 module */\n(function ( module，_webpack_exports_, __webpack_require__) {...\n}),\n/*n module */\n(function (module，_webpack_exports__, _webpack_require__) {\n    ...\n})\n```\n\n在 webpack 中，这样的代码结构是 webpack 打包模块时生成的启动脚本（bootstrap）的一部分，它定义了如何加载和解析打包后的模块。\n\n以下是对该段代码的逐行解释：\n\n1. **立即调用的函数表达式（IIFE）**:\n\n   ```javascript\n   (function (modules) {\n     // ...\n   })([\n     ,\n     ,/* 0 module */\n     /* 1 module */\n     /* n module */\n   ]);\n   ```\n\n   这是一个立即调用的函数表达式，它接受一个参数 `modules`，这个参数是一个数组，包含了所有打包后的模块。每个模块都是一个函数，当调用时，会执行模块的代码，并返回模块的导出对象。\n\n2. **模块缓存**:\n\n   ```javascript\n   var installedModules = {};\n   ```\n\n   `installedModules` 对象用于缓存已经加载过的模块。这可以确保一个模块只被加载和执行一次，后续的引用都会直接从缓存中获取。\n\n3. **`_webpack_require_` 函数**:\n   这个函数负责加载并运行指定的模块。它的工作方式如下：\n\n   - 检查模块是否已经缓存 (`installedModules[moduleId]`)。\n   - 如果已经缓存，直接返回模块的导出对象。\n   - 如果没有缓存，创建一个新的模块对象，并设置其 `exports` 属性为一个空对象。\n   - 执行模块代码（`modules[moduleId].call(module.exports, module, module.exports, _webpack_require_)`）。\n   - 将模块标记为已加载 (`module.l = true`)。\n   - 返回模块的导出对象。\n\n4. **入口模块**:\n\n   ```javascript\n   _webpack_require___(0);\n   ```\n\n   这一行调用了 `_webpack_require_` 函数，并传入 `0` 作为参数。`0` 通常代表入口模块的 ID，即 webpack 配置中指定的入口文件。这行代码会触发整个依赖图的加载过程。\n\n5. **模块定义**:\n\n   ```javascript\n   /* 0 module */\n   (function (module, _webpack_exports__, _webpack_require__) {\n       // ...\n   }),\n   /* 1 module */\n   (function (module, _webpack_exports_, __webpack_require__) {\n       // ...\n   }),\n   // ...\n   ```\n\n   每个模块都是一个函数，它接受三个参数：`module`、`_webpack_exports_` 和 `_webpack_require_`。\n\n   - `module` 是模块对象，用于存储模块的元信息和导出对象。\n   - `_webpack_exports_` 是模块的导出对象，通常简写为 `exports`。\n   - `_webpack_require_` 是用于加载其他模块的函数，通常简写为 `require`。\n\n每个模块函数内部定义了模块的代码和导出。当 `_webpack_require_` 函数被调用以加载某个模块时，该模块的函数就会被执行，其导出的内容（通常是附加到 `_webpack_exports_` 对象上的属性）就会被返回并缓存起来。\n\n这样的设计允许 webpack 将多个模块打包成一个文件，并通过一个统一的入口点来加载整个应用程序。同时，由于模块被缓存，所以即使一个模块被多次引用，它也只会被加载和执行一次。\n\n### Qusetio1\n\n在 webpack 的打包结果中，每个模块通常被包裹在一个立即调用的函数表达式（IIFE）中，这是因为 IIFE 提供了模块的作用域隔离。这是模块化打包的一种常见技巧，旨在确保每个模块的内部状态（例如变量、函数等）不会意外地泄露到全局作用域中，或者与其他模块产生冲突。\n\n在 JavaScript 中，如果你只是定义了一个函数，比如 `function myModule() {...}`，那么 `myModule` 会成为全局作用域的一部分（除非它在另一个函数或模块的作用域内定义）。这可能会导致命名冲突，特别是当多个脚本或模块在同一个环境中运行时。\n\n通过将每个模块包裹在一个 IIFE 中，webpack 创建了一个局部作用域，模块的所有内容（包括变量、函数等）都只在这个局部作用域内可见。这样，即使两个模块都定义了一个名为 `myFunction` 的函数，这两个函数也不会互相干扰，因为它们是各自作用域内的不同实体。\n\n这里的 IIFE 看起来像这样：\n\n```javascript\n(function (module, exports, __webpack_require__) {\n  // 模块代码\n})(/* 传递给函数的参数 */);\n```\n\n括号包裹函数是为了立即调用它。如果不加括号，函数只是被定义，并不会执行。加上括号后，函数会立即执行，并传入相应的参数（例如模块 ID、导出对象、`require` 函数等）。\n\n因此，`function` 被括号包裹起来并不仅仅是“传入一个函数”，而是为了立即执行这个函数，从而初始化模块，设置其内部状态，并返回其导出的值。这是 JavaScript 中模块化的一个常见模式，确保每个模块都有它自己的私有作用域，并且可以安全地与其他模块共存。\n'}, {'id': 29, 'title': '007原理篇编写Loader和插件_001', 'date': '2024-03-29', 'content': '### 实战开发一个自动合成雪碧图的 loader\n\n![Alt text](image-20.png)\n减少小图片的请求频次 要求\n![Alt text](image-21.png)\n![Alt text](image-22.png)\n返回图片和宽高 原理\n![Alt text](image-23.png)\n验证官方的插件是否可用\n![Alt text](image-24.png)\n\n#### 开发我们的 Loader\n\n![Alt text](image-25.png)\n![Alt text](image-26.png)\n这个合图 是一个异步的过程 用 this.async 定义一下 callback 匹配所有\n以问好为结尾的 Img\n![Alt text](image-27.png)\n只需要匹配到路径就可以了 此外 还需要将原来位置的路径替换掉\n\n### 更复杂的 loader 的开发场\n\n![Alt text](image-15.png)\n`npm i loader-utils -S`\n\n1. Loader 参数获取\n2. 异常处理\n3. 异步的 Loader 比较耗时\n4. loader 如何进行文件输出\n\n![Alt text](image-16.png)\n同步 CallBack 是 Loader 的上下文回调参数\n![Alt text](image-17.png)\n任务是耗时的任务 比如文件的读写 内容处理等等\n![Alt text](image-18.png)\n\n![Alt text](image-19.png)\n使用 fielLoader\nwebpack_public_path 是全局变量\n\n```js\nconst { runLoaders } = require("loader-runner");\nconst fs = require("fs");\nconst path = require("path");\n\nrunLoaders(\n  {\n    resource: path.join(__dirname, "./src/demo.txt"),\n    loaders: [\n      {\n        loader: path.join(__dirname, "./src/raw-loader.js"),\n        options: {\n          //传递参数 1\n          name: "test",\n        },\n      },\n    ],\n    context: {\n      emitFile: () => {},\n    },\n    readResource: fs.readFile.bind(fs),\n  },\n  (err, result) => {\n    err ? console.log(err) : console.log(result);\n  }\n);\n```\n\n```js\nconst loaderUtils = require("loader-utils"); //引入 1\nconst fs = require("fs");\nconst path = require("path");\n\nmodule.exports = function (source) {\n  const { name } = loaderUtils.getOptions(this); //获取 1\n\n  const url = loaderUtils.interpolateName(this, "[name].[ext]", {\n    source,\n  });\n\n  console.log(url);\n  this.emitFile(path.join(__dirname, url), source);\n\n  // this.cacheable(false);\n  // const callback = this.async();//3. 回调函数的方式\n\n  const json = JSON.stringify(source)\n    .replace("foo", "")\n    .replace(/\\u2028/g, "\\\\u2028")\n    .replace(/\\u2029/g, "\\\\u2029");\n\n  // fs.readFile(path.join(__dirname, \'./async.txt\'), \'utf-8\', (err, data) => {//异步处理 3.\n  //     if (err) {\n  //         callback(err, \'\');\n  //     }\n  //     callback(null, data);\n  // });\n  //\n\n  // throw new Error(\'Error\');//错误处理 2.\n  return `export default ${json}`; //仅返回一个值 2.\n  // this.callback(null//内置的error//, json, 2, 3, 4);更多的使用的是这种方式 也可以回传多一个值  2.\n  //   this.callback(new Error("Eroor"), json); 2.\n};\n```\n\n```js\nnpm i loader-utils -D\nconst loaderUtils = require("loader-utils");\nmodule.exports = function (source) {\n  console.log("Loader a is excuted!");\n  const url = loaderUtils.interpolateName(this, "[name].[ext]", source);\n  //文件名称和它的占位符 index.js 输出之后 还是index.js\n  console.log(url);\n  this.emitFile(url, source);\n  return source;\n};\n```\n\n### 使用 loader-runner 高效进行 loader 的调试\n\n本地开发 Loader\n![Alt text](image-8.png)\n![Alt text](image-9.png)\n资源的路经 数组 除了 Loadd 提供额外上下文 查询我们的数组 下边就是回调函数\n![Alt text](image-10.png)\n将文件转化为 String\n![Alt text](image-11.png)\n![Alt text](image-12.png)\n\n#### 高效开发 Loader 的调试\n\n![Alt text](image-13.png)\n\n```js\nmodule.exports = function (source) {\n  const json = JSON.stringify(source)\n    .replace("foo", "")\n    .replace(/\\u2028/g, "\\\\u2028")\n    .replace(/\\u2029/g, "\\\\u2029");\n\n  return `export default ${json}`;\n};\n\nrunLoaer.js;\nconst { runLoaders } = require("loader-runner");\nconst fs = require("fs");\nconst path = require("path");\n\nrunLoaders(\n  {\n    resource: path.join(__dirname, "./src/demo.txt"),\n    //资源的绝对路径\n    loaders: [\n      {\n        loader: path.join(__dirname, "./src/raw-loader.js"),\n        options: {\n          name: "test",\n        },\n      },\n    ],\n    context: {\n      //   emitFile: () => {},\n       minisize:true; //压缩上下文\n    },\n    readResource: fs.readFile.bind(fs),\n  },\n  (err, result) => {\n    err ? console.log(err) : console.log(result);\n  }\n);\n```\n\n![Alt text](image-14.png)\n\n### loader 的链式调用与执行顺序\n\n执行顺序 从右到左 必须导出为函数\n\n![Alt text](image.png)\n![Alt text](image-1.png)\n串行执行的 先执行 less 然后执行 css 然后执行 style 从后往前\n![Alt text](image-2.png)\n![Alt text](image-3.png)\n![Alt text](image-4.png)\n使用这个函数生成 Loader WebCli\n![Alt text](image-5.png)\n![Alt text](image-6.png)\n\n```js\nnpm 命令\n"build": "webpack"\n\nWebpack.config.js;\nconst path = require("path");\n\nmodule.exports = {\n  entry: "./src/index.js",\n  output: {\n    path: path.join(__dirname, "dist"),\n    filename: "main.js",\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        use: [\n          path.resolve("./loaders/a-loader"),\n          path.resolve("./loaders/b-loader"),\n        ],\n      },\n    ],\n  },\n};\n\na - loader;\nconst loaderUtils = require("loader-utils");\nmodule.exports = function (source) {\n  console.log("Loader a is excuted!");\n\n  const url = loaderUtils.interpolateName(this, "[name].[ext]", source);\n\n  console.log(url);\n  this.emitFile(url, source);\n  return source;\n};\n\nb - loader;\nmodule.exports = function (source) {\n  console.log("Loader b is excuted!");\n  return source;\n};\n\nnpm run build\n![Alt text](image-7.png)\n```\n\n# This title\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-21-17:41:55(星期四)</em></span></p>\n'}, {'id': 30, 'title': '007原理篇编写Loader和插件_002', 'date': '2024-03-29', 'content': '### 实战开发一个压缩构建资源为 zip 包的插件\n\n![Alt text](image-41.png)\n![Alt text](image-42.png)\njsZip 官方文档\n![Alt text](image-43.png)\n输出到 dist 目录\n![Alt text](image-44.png)\n`cp -r my-plugin zip-plugin`\n`npm i jszip -S`\n\n```js\nconst JSZip = require("jszip"); //安装jsZip\nconst path = require("path");\nconst RawSource = require("webpack-sources").RawSource; //\nconst zip = new JSZip();\n\nmodule.exports = class ZipPlugin {\n  constructor(options) {\n    this.options = options; //接受参数\n  }\n\n  apply(compiler) {\n    //这里是tab还是tapAsync看是不是异步的  因为是异步的所以 需要加上Async\n    compiler.hooks.emit.tapAsync("ZipPlugin", (compilation, callback) => {\n      //钩子获取对象 传入回调参数\n      const folder = zip.folder(this.options.filename);\n      //创建目录\n\n      for (let filename in compilation.assets) {\n        //处理一下compilation的函数\n        const source = compilation.assets[filename].source(); //就是它的value\n        // console.log(compilation.assets[filename]);\n        folder.file(filename, source); //添加到folder里边去\n      }\n      /*\n一旦generateAsync方法完成了ZIP文件的生成，它将返回一个Promise，\n该Promise在解析时将传递ZIP文件的二进制内容（作为Buffer对象）。\n然后，您可以在.then((content) => { ... }的回调函数中处理这个Buffer对象，\n例如将其写入文件或通过网络发送。*/\n      zip\n        .generateAsync({\n          //将文件生成出来为zip\n          type: "nodebuffer",\n        })\n        .then((content) => {\n          //也可以只用压缩leval和算法 这里继续\n          const outputPath = path.join(\n            compilation.options.output.path, //dist目录\n            this.options.filename + ".zip" //fielname main.js\n          ); //输出目录 可以设置为项目的output\n\n          const outputRelativePath = path.relative(\n            //相对路径函数\n            compilation.options.output.path,\n            outputPath\n          ); //将内容挂载\n          compilation.assets[outputRelativePath] = new RawSource(content);\n          //buffer转化为source 二进制转换为代码\n\n          callback(); //调用一下callback\n        });\n    });\n  }\n};\n```\n\n`console.log(compilation.assets[filename]);`\n![Alt text](image-45.png)\n`const source = compilation.assets[filename].source();`\n![Alt text](image-48.png)\n`zip.generateAsync({type: "nodebuffer",}).then((content) => {`\n将 content 输出出来可以看到 就是一个 buffer 二进制机器码\n![Alt text](image-46.png)\n`compilation.options`输出\n![Alt text](image-47.png)\n可以获得各种经过 webpack 处理的信息\n\n### 更复杂的插件开发场景\n\n![Alt text](image-37.png)\n![Alt text](image-38.png)\n最终会将这两个对象收集起来\n![Alt text](image-39.png)\n生成的静态资源 如何处理写入 emit 阶段 监听 hook 获取这个对象 读取这个对象\n可以在 [webpack_source](https://www.npmjs.com/package/webpack-sources) 查看所有的\n这个位置应该是 compile.hook.emit\n![Alt text](image-40.png)\n扩展自身的拓展\n\n---\n\n### - 插件基本结构介绍\n\n编写插件 Loader 处理静态资源 插件全过程够可以运行\n![Alt text](image-28.png)\n![Alt text](image-29.png)\n必须有 Apply 方法 而且还是一个类\n\n![Alt text](image-30.png)\n![Alt text](image-31.png)\n![Alt text](image-32.png)\n\n![Alt text](image-34.png)\n![Alt text](image-33.png)\n![Alt text](image-35.png)\n![Alt text](image-36.png)\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-21-19：06：44（星期四）</em></span></p>\n'}, {'id': 31, 'title': '008实战篇React全家桶和Webpack开发商城项目_001', 'date': '2024-03-29', 'content': '### - 登录注册模块开发\n\n![Alt text](image-10.png)\n![Alt text](image-11.png)\n![Alt text](image-12.png)\n\n---\n\n### - 数据库实体和表结构设计\n\n![Alt text](image-5.png)\n\n---\n\n### React 全家桶环境搭建\n\n我们没有直接使用 react 创建是因为我们在第四章已经创建了 对应的 config 配置\n所以我们可以直接使用 action 存放 redux 的组件 asset 存放各种资源 component 存放我们各种组件 reducers 粗放我们各种 reducer app.js 是我们的容器组件 app.less 是我们容器组件的样式 index.html 是我们的模板 index.js 时入口模板 store.js 是我们的 store\n已经把 redux 加入进来了 一个时 actions 一个是 reducers 一个是 store\n\n![Alt text](image-6.png)\n![Alt text](image-7.png)\n\n```js\nmkdir react-redux-project\ncd react-redux-project\nnpm init -y\nnpm i react react-dom redux react-redux -S\nnpm i @babel/core -D\nnpm i builder-webpack-geektime -D\n\n//创建\nsrc webpack.prod.js webpack.dev.js\n\nnpm i webpack webpack-cli -D\n\n// package.json田间两个script脚本\n"build":"webpack --config webpack.prod.js",\n"dev":"webpack --config webpack.dev.js",\n//直接填写一行就可以了\nmodule.exports=require(\'builder-webpack-geektime/lib/webpack.prod\')\nmodule.exports=require(\'builder-webpack-geektime/lib/webpack.prod\')\n```\n\napp.js 是逻辑组件 app.less 逻辑组件的样式 store.js 就是 store\ntoDo 的 Mvc 的应用看看正确不正确\n![Alt text](image-8.png)\n\n---\n\n### 商城界面 UI 设计与模块拆分\n\n![Alt text](image-2.png)\n![Alt text](image-3.png)\n![Alt text](image-4.png)\n\n---\n\n### 商城技术栈选型和整体架构\n\n![Alt text](image.png)\nkoa2 和 mysql\n这些后端没有使用 Rpc 和消息队列等功能\n![Alt text](image-1.png)\npc 和 h5 还有小程序 最后一层可以使用 k8s 做集群部署的\n\n# 项目\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-23-15:35:34(星期六)</em></span></p>\n'}, {'id': 32, 'title': '008实战篇React全家桶和Webpack开发商城项目_002', 'date': '2024-03-29', 'content': '---\n### - 玩转 webpack 结束语\n---\n\n### - 功能开发总结\n\n![Alt text](image-16.png)\n\n---\n\n### - 谈谈 Web 商城的性能优化策略\n\n![Alt text](image-15.png)\n串行的\n\n---\n\n### - 商品模块开发\n\n![Alt text](image-13.png)\n![Alt text](image-14.png)\n\n# This title\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-23-15：36：19（星期六）</em></span></p>\n'}, {'id': 33, 'title': '009-final_001', 'date': '2024-03-29', 'content': '### vite 的构建原理\n\n![Alt text](image-26.png)\n使用 Esbuild(golang 进行开发) golang 是静态语言 是比 js 这种动态语言要快\n![Alt text](image-27.png)\n![Alt text](image-28.png)\n![Alt text](image-29.png)\n![Alt text](image-30.png)\n![Alt text](image-31.png)\n![Alt text](image-32.png)\n![Alt text](image-33.png)\n![Alt text](image-34.png)\n\n### bundle 和 bundleless 的区别\n\n![Alt text](image-17.png)\n![Alt text](image-18.png)\n![Alt text](image-19.png)\n![Alt text](image-20.png)\n![Alt text](image-21.png)\n![Alt text](image-22.png)\n![Alt text](image-23.png)\n![Alt text](image-24.png)\n![Alt text](image-25.png)\n开发阶段使用 bundleless 生产阶段使用 bundle\n\n---\n\n### web5 新特性概览\n\n![Alt text](image.png)\n![Alt text](image-1.png)\n![Alt text](image-2.png)\n![Alt text](image-3.png)\nrequireInclude 是引入库 但是并不马上执行 模块预加载 w5 被废弃\n![Alt text](image-4.png)\n![Alt text](image-5.png)\n![Alt text](image-6.png)\n![Alt text](image-7.png)\n动态加载模块\nwebpack4 的\n![Alt text](image-8.png)\nwebpack5\n![Alt text](image-9.png)\n![Alt text](image-10.png)\nmemory 或者 filesystem\n![Alt text](image-11.png)\n嵌套的 treeshaking\n![Alt text](image-12.png)\n不使用就不打包\n![Alt text](image-13.png)\n\n![Alt text](image-14.png)\n微前端 可以通过动态加载 CDN 的方式去实现一个应用暴露出来的代码\n这个是有网络请求的 需要两个应用分别在不同的端口 好处是\n两个独立应用之间的代码共享 需要打包成 npm 应用 然后发布出去两个应用分别 require 进来就可以了\n组件模块代码共享就变得更加方便了\n![Alt text](image-15.png)\nshared 比如 react 和 reactdom 都被共享 可以进行一个共享\n![Alt text](image-16.png)\n生产者 remote 消费者 host\n\n<p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);">Edit by</span><em style="color: rgba(91, 255, 247, 0.65);">@02sDarling</em></p><p style="text-align:right"> <span style="font-size: small; color: rgba(128, 128, 128, 0.5);"><em>2024-03-23-20：20：39（星期六）</em></span></p>\n'}, {'id': 34, 'title': 'builder-webpack_README', 'date': '2024-03-18', 'content': ''}, {'id': 35, 'title': 'builder-webpack_README', 'date': '2024-03-18', 'content': ''}, {'id': 36, 'title': 'server_README', 'date': '2024-03-18', 'content': '### 部署\n\n```shell\n查看守护进程：pm2 list\n查看日志：pm2 log [id|name]\n重启：pm2 restart [id|name]\n```\n'}, {'id': 37, 'title': 'docs_API', 'date': '2024-03-18', 'content': '# API 文档\n\n所有的接口都部署在: `127.0.0.1:8001/api/v1` 下\n\n## 接口-商品\n\n### 商品列表\n\n``` sh\n/goods?page=1&per_page=10\n```\n\nGET\n\n调用例子：\n\n```\n➜  ~ curl -X GET "http://127.0.0.1:8001/v1/goods?page=1&per_page=3"\n[{"id":100000,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:47.000Z","updateDate":"2018-07-10T01:57:47.000Z","create_date":"2018-07-10T01:57:47.000Z","update_date":"2018-07-10T01:57:47.000Z"},{"id":100001,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:59.000Z","updateDate":"2018-07-10T01:57:59.000Z","create_date":"2018-07-10T01:57:59.000Z","update_date":"2018-07-10T01:57:59.000Z"},{"id":100002,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:58:00.000Z","updateDate":"2018-07-10T01:58:00.000Z","create_date":"2018-07-10T01:58:00.000Z","update_date":"2018-07-10T01:58:00.000Z"}]%\n```\n\n### 商品详情\n\n``` sh\n/goods/:id\n```\n\nGET\n\n调用例子：\n\n```\n➜  ~ curl -X GET "http://127.0.0.1:8001/v1/article/100000"\n{"id":100000,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:47.000Z","updateDate":"2018-07-10T01:57:47.000Z","create_date":"2018-07-10T01:57:47.000Z","update_date":"2018-07-10T01:57:47.000Z"}%\n```\n\n### 发布商品\n\n```sh\n/goods/new\n```\n\nPOST\n\n调用例子：\n```\n➜  ~ curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDEsInVzZXJuYW1lIjoid2VicGFjayIsImVtYWlsIjoidGVzdEBxcS5jb20iLCJhdmF0YXIiOiIvL3FwaWMudXJsLmNuL2ZlZWRzX3BpYy9hak5WZHFIWkxMQks3UXlKbmljTXVpY3dXVnJLaHVJYzQyNndFWWJJYVNsYVhaUkR1cXMyaDRYQS8iLCJ0eXBlIjoyfSwiZXhwIjoxNTY5NjYyNDkyLCJpYXQiOjE1NjkwNTc2OTJ9._cc7B2Q565rL-hKK25Lppw4IDVEkQP17qky0boVTlrA\' -X POST -d "title=test&content=test&thumbnail=https://avatars1.githubusercontent.com/u/18289264\\?s\\=460\\&v\\=4&category=1&cid=1" "http://127.0.0.1:8001/v1/goods/new"\n{"id":null,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"update_date":"2018-07-10T01:58:13.520Z","create_date":"2018-07-10T01:58:13.520Z","createDate":"2018-07-10T01:58:13.520Z","updateDate":"2018-07-10T01:58:13.520Z"}%\n```\n\n### 修改商品\n\n```sh\n/article/:id\n```\n\nPUT\n\n调用例子：\n```\n➜  ~ curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM2OTgxNDkxLCJpYXQiOjE1MzY5Nzc4OTF9.KX2IpCZJB05XNT5krWWJivZyThkLzeuxyHnprNyPuo0\' -X PUT -d "title=test1&content=11111&thumbnail=123&&cid=2"  "http://127.0.0.1:8001/v1/article/100454"\n```\n\n## 接口-订单\n\n### 订单列表（管理员可以查看）\n\n```sh\n/order?page=1&per_page=10\n```\n\n调用例子\n\n```\n➜  ~ curl "http://127.0.0.1:8001/v1/order?page=1&per_page=10"\n```\n\n### 下单接口\n\n```sh\n/order/new\n```\n\nPOST\n\n调用例子\n\n```\n➜  ~ curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDEsInVzZXJuYW1lIjoid2VicGFjayIsImVtYWlsIjoidGVzdEBxcS5jb20iLCJhdmF0YXIiOiIvL3FwaWMudXJsLmNuL2ZlZWRzX3BpYy9hak5WZHFIWkxMQks3UXlKbmljTXVpY3dXVnJLaHVJYzQyNndFWWJJYVNsYVhaUkR1cXMyaDRYQS8iLCJ0eXBlIjoyfSwiZXhwIjoxNTY5NjYyNDkyLCJpYXQiOjE1NjkwNTc2OTJ9._cc7B2Q565rL-hKK25Lppw4IDVEkQP17qky0boVTlrA\' -X POST -d "gids[0]=1&gids[1]=2" "http://127.0.0.1:8001/api/v1/order/new"\n\n\n## 接口-周刊\n\n### 周刊列表\n\n```sh\n/article/weekly?page=1&per_page=1\n```\n\n调用例子：\n```sh\n➜  ~ curl -X GET "http://127.0.0.1:8001/v1/article/weekly?page=1&per_page=3"\n```\n\n### 设置周刊\n```sh\n/article/:id/weekly\n```\n\n调用例子：\n\n```\n➜  ~ curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM2OTgxNDkxLCJpYXQiOjE1MzY5Nzc4OTF9.KX2IpCZJB05XNT5krWWJivZyThkLzeuxyHnprNyPuo0\' -X POST -d "is_weekly=1"  "http://127.0.0.1:8001/v1/article/100454/top"\n```\n\n备注：is_weekly传入1，代表设置为周刊，is_weekly传入0代表取消周刊设置\n\n## 接口-类目\n\n### 文章类目\n\n```sh\n/category\n```\n\nGET\n\n### 新增类目\n\n仅管理员有权限\n\n```sh\n/category/new\n```\n\nPOST\n\n调用例子：\n```\n➜  ~curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDUsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRTaWV3c3cwSGhCRExUb1BMbGNwaEYuOHJBUFVyVnhrOUZKdVpSLjB6Y3lPQnFKVkNPWmtrQyIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wOS0xMlQwNzo1NjowNC4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDktMTJUMDc6NTY6MDQuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wOS0xMlQwNzo1NjowNC4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA5LTEyVDA3OjU2OjA0LjAwMFoifSwiZXhwIjoxNTM2ODExNDY2LCJpYXQiOjE1MzY4MDc4NjZ9.O2JSfTffSMIgA3VBiC6wxyYOVrSEPzBuKwcfXgUbQlw\' -X POST -d "name=Web开发" "http://127.0.0.1:8001/v1/category/new"\n```\n\n## 接口-评论\n\n### 评论列表\n\n```sh\n/article/:id/comment\n```\n\n调用例子\n\n```\n➜  ~ curl "http://127.0.0.1:8001/v1/article/100454/comment?page=1&per_page=10"\n```\n\n### 发表评论\n\n```sh\n/article/:id/comment/new\n```\n\nPOST\n\n调用例子\n\n```\n➜  ~ curl -H \'authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM2OTg2MDA5LCJpYXQiOjE1MzY5ODI0MDl9.-ozkHCrCOXgA0ZoRMcUhH8JU1iqm6GgRsidTjYUKBhk\' -X POST -d "content=test12" "http://127.0.0.1:8001/v1/article/100454/comment/new"\n```\n\n## 接口-文章点赞\n\n### 喜欢文章\n\n```sh\n/article/:id/starred\n```\n\nPUT\n\n调用例子\n\n```\n➜  ~  curl -H "authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM3MDAxNDEzLCJpYXQiOjE1MzY5OTc4MTN9.kVoHjRueD2_lFVlOkJ4RrASSiJ-zVmBFYdjVj-M8ez4" -X PUT "http://127.0.0.1:8001/v1/article/100454/starred"\n```\n\n### 取消喜欢文章\n\n```sh\n/article/:id/starred\n```\n\nDELETE\n\n调用例子\n\n```\n➜  ~  curl -H "authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM3MDAxNDEzLCJpYXQiOjE1MzY5OTc4MTN9.kVoHjRueD2_lFVlOkJ4RrASSiJ-zVmBFYdjVj-M8ez4" -X DELETE "http://127.0.0.1:8001/v1/article/100454/starred"\n```\n\n\n## 接口-用户\n\n### 登陆\n\n```sh\n/user/login\n```\n\nPOST\n\n调用例子：\n\n```\n➜  ~  curl -X POST -d "username=test&password=123456" "http://127.0.0.1:8001/v1/user/login"\n{"message":"登录成功","user":{"username":"test","email":"test@qq.com","avatar":"https://avatars1.githubusercontent.com/u/18289264?s=460&v=4"},"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDEsInVzZXJuYW1lIjoidGVzdCIsInBhc3N3b3JkIjoiJDJiJDA1JFp6QWptVTl1TlU0VWQ2Q0JhNmJxRnU0ZWN5WHpwMUJ3Mkk5MU9xV1psWDJkanlLUEcyOEh5IiwiZW1haWwiOiJ0ZXN0QHFxLmNvbSIsImF2YXRhciI6Imh0dHBzOi8vYXZhdGFyczEuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvMTgyODkyNjQ_cz00NjAmdj00IiwidHlwZSI6MiwiY3JlYXRlRGF0ZSI6IjIwMTgtMDctMTBUMDE6NDY6MTEuMDAwWiIsInVwZGF0ZURhdGUiOiIyMDE4LTA3LTEwVDAxOjQ2OjExLjAwMFoiLCJjcmVhdGVfZGF0ZSI6IjIwMTgtMDctMTBUMDE6NDY6MTEuMDAwWiIsInVwZGF0ZV9kYXRlIjoiMjAxOC0wNy0xMFQwMTo0NjoxMS4wMDBaIn0sImV4cCI6MTUzMTE5MDg3OCwiaWF0IjoxNTMxMTg3Mjc4fQ._ot63GFTJTvYGZ6O0Mt8BBDxp4PQKT6u6zX5VtWHLs4"}%\n```\n\n### 注册\n\n```sh\n/user/register\n```\n\nPOST\n\n调用例子：\n```\n➜  ~ curl -X POST -d  "username=test&password=123456&email=test@qq.com" "http://127.0.0.1:8001/v1/user/register"\n{"message":"注册成功","user":{"id":null,"username":"test","password":"$2b$05$ZzAjmU9uNU4Ud6CBa6bqFu4ecyXzp1Bw2I91OqWZlX2djyKPG28Hy","email":"test@qq.com","avatar":"https://avatars1.githubusercontent.com/u/18289264?s=460&v=4","type":2,"update_date":"2018-07-10T01:46:11.413Z","create_date":"2018-07-10T01:46:11.413Z","createDate":"2018-07-10T01:46:11.413Z","updateDate":"2018-07-10T01:46:11.413Z"}}%\n```\n\n### 查询某个用户信息\n\n```sh\n/user/:id\n```\n\nGET\n\n调用例子：\n\n```\n➜  ~ curl "http://127.0.0.1:8001/v1/user/100001"\n```\n\n### 修改当前用户信息\n\n```sh\n/user\n```\n\nPUT\n\n调用例子：\n\n\n```\n➜  ~ curl -H "authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjp7ImlkIjoxMDAwMDAsInVzZXJuYW1lIjoiY3BzZWx2aXMiLCJwYXNzd29yZCI6IiQyYiQwNSRYY3JRb0x2ZEp4Y3JHb3QybkhGcjAuLnNjczJ3cFV4YUZDRG1ieTc3aTQzajdDeUVYYUlkbSIsImVtYWlsIjoiY3BzZWx2aXNAZ21haWwuY29tIiwiYXZhdGFyIjoiaHR0cHM6Ly9hdmF0YXJzMS5naXRodWJ1c2VyY29udGVudC5jb20vdS8xODI4OTI2ND9zPTQ2MCZ2PTQiLCJ0eXBlIjowLCJjcmVhdGVEYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlRGF0ZSI6IjIwMTgtMDYtMjZUMDQ6MzM6NDcuMDAwWiIsImNyZWF0ZV9kYXRlIjoiMjAxOC0wNi0yNlQwNDozMzo0Ny4wMDBaIiwidXBkYXRlX2RhdGUiOiIyMDE4LTA2LTI2VDA0OjMzOjQ3LjAwMFoifSwiZXhwIjoxNTM3OTY2ODA3LCJpYXQiOjE1MzczNjIwMDd9.uSY4A6SioW9O2u0CI5goUCXF9djaCPeAtlLZIHjWpck" -X PUT "name=aaa" "http://127.0.0.1:8001/v1/user"\n```\n\n### 发布的文章\n\n``` sh\n/user/:id/article?page=1&per_page=10\n```\n\nGET\n\n调用例子：\n\n```\n➜  ~ curl -X GET "http://127.0.0.1:8001/v1//user/:id/article?page=1&per_page=3"\n[{"id":100000,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:47.000Z","updateDate":"2018-07-10T01:57:47.000Z","create_date":"2018-07-10T01:57:47.000Z","update_date":"2018-07-10T01:57:47.000Z"},{"id":100001,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:59.000Z","updateDate":"2018-07-10T01:57:59.000Z","create_date":"2018-07-10T01:57:59.000Z","update_date":"2018-07-10T01:57:59.000Z"},{"id":100002,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:58:00.000Z","updateDate":"2018-07-10T01:58:00.000Z","create_date":"2018-07-10T01:58:00.000Z","update_date":"2018-07-10T01:58:00.000Z"}]%\n```\n\n### 点赞的文章\n\n``` sh\n/user/:id/starred?page=1&per_page=10\n```\n\nGET\n\n调用例子：\n\n```\n➜  ~ curl -X GET "http://127.0.0.1:8001/v1//user/:id/starred?page=1&per_page=3"\n[{"id":100000,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:47.000Z","updateDate":"2018-07-10T01:57:47.000Z","create_date":"2018-07-10T01:57:47.000Z","update_date":"2018-07-10T01:57:47.000Z"},{"id":100001,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:57:59.000Z","updateDate":"2018-07-10T01:57:59.000Z","create_date":"2018-07-10T01:57:59.000Z","update_date":"2018-07-10T01:57:59.000Z"},{"id":100002,"title":"test","description":"test","content":"test","thumbnail":"https://avatars1.githubusercontent.com/u/18289264\\\\?s\\\\=460\\\\","cid":1,"uid":1,"isWeekly":null,"createDate":"2018-07-10T01:58:00.000Z","updateDate":"2018-07-10T01:58:00.000Z","create_date":"2018-07-10T01:58:00.000Z","update_date":"2018-07-10T01:58:00.000Z"}]%\n```\n'}, {'id': 38, 'title': 'simple-pack_readme', 'date': '2024-03-21', 'content': 'simple-pack\n\n可以将 es5 语法转化为 es5 语法\n\n- 通过 babylon 生成 Ast\n- 通过 babel-core 将 Ast 重新生成源码\n\n可以分析模块之间的依赖关系\n\n- 通过 babel-traverse 的 importDeclaration 方法获取依赖属性\n\n生成 js 文件可以在浏览器中运行\n\n环境为 Node 环境\n'}]